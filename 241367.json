{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","commits":[{"id":"70b55953b6a72596cb534ead735a8b849a473cac","date":1363634568,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestRandomStoredFields#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"088a7ef694fd43d5d9a4d200c4005865f773d1e7","date":1371136274,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setUseCompoundFile(false);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(_TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = _TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = _TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<Integer>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<String,Document>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae14298f4eec6d5faee6a149f88ba57d14a6f21a","date":1396971290,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e","date":1406737224,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.shutdown();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(TEST_VERSION_CURRENT, new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.shutdown();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"103857ec20f79f31c7a00310a91ed001b9a6ef17","date":1412698959,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["57d5dad190acf63cb17e05df3882de97b1105c1c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs);\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c","date":1453060490,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          StoredDocument doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dbc046116d49cd3d0c50f7169cabaa295bc23a4a","date":1552989114,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        DirectoryReader r = maybeWrapWithMergingReader(w.getReader());\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        IndexReader r = w.getReader();\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BaseStoredFieldsFormatTestCase#testRandomStoredFields().mjava","sourceNew":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        DirectoryReader r = maybeWrapWithMergingReader(w.getReader());\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(100);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testRandomStoredFields() throws IOException {\n    Directory dir = newDirectory();\n    Random rand = random();\n    RandomIndexWriter w = new RandomIndexWriter(rand, dir, newIndexWriterConfig(new MockAnalyzer(random())).setMaxBufferedDocs(TestUtil.nextInt(rand, 5, 20)));\n    //w.w.setNoCFSRatio(0.0);\n    final int docCount = atLeast(200);\n    final int fieldCount = TestUtil.nextInt(rand, 1, 5);\n\n    final List<Integer> fieldIDs = new ArrayList<>();\n\n    FieldType customType = new FieldType(TextField.TYPE_STORED);\n    customType.setTokenized(false);\n    Field idField = newField(\"id\", \"\", customType);\n\n    for(int i=0;i<fieldCount;i++) {\n      fieldIDs.add(i);\n    }\n\n    final Map<String,Document> docs = new HashMap<>();\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: build index docCount=\" + docCount);\n    }\n\n    FieldType customType2 = new FieldType();\n    customType2.setStored(true);\n    for(int i=0;i<docCount;i++) {\n      Document doc = new Document();\n      doc.add(idField);\n      final String id = \"\"+i;\n      idField.setStringValue(id);\n      docs.put(id, doc);\n      if (VERBOSE) {\n        System.out.println(\"TEST: add doc id=\" + id);\n      }\n\n      for(int field: fieldIDs) {\n        final String s;\n        if (rand.nextInt(4) != 3) {\n          s = TestUtil.randomUnicodeString(rand, 1000);\n          doc.add(newField(\"f\"+field, s, customType2));\n        } else {\n          s = null;\n        }\n      }\n      w.addDocument(doc);\n      if (rand.nextInt(50) == 17) {\n        // mixup binding of field name -> Number every so often\n        Collections.shuffle(fieldIDs, random());\n      }\n      if (rand.nextInt(5) == 3 && i > 0) {\n        final String delID = \"\"+rand.nextInt(i);\n        if (VERBOSE) {\n          System.out.println(\"TEST: delete doc id=\" + delID);\n        }\n        w.deleteDocuments(new Term(\"id\", delID));\n        docs.remove(delID);\n      }\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: \" + docs.size() + \" docs in index; now load fields\");\n    }\n    if (docs.size() > 0) {\n      String[] idsList = docs.keySet().toArray(new String[docs.size()]);\n\n      for(int x=0;x<2;x++) {\n        DirectoryReader r = maybeWrapWithMergingReader(w.getReader());\n        IndexSearcher s = newSearcher(r);\n\n        if (VERBOSE) {\n          System.out.println(\"TEST: cycle x=\" + x + \" r=\" + r);\n        }\n\n        int num = atLeast(1000);\n        for(int iter=0;iter<num;iter++) {\n          String testID = idsList[rand.nextInt(idsList.length)];\n          if (VERBOSE) {\n            System.out.println(\"TEST: test id=\" + testID);\n          }\n          TopDocs hits = s.search(new TermQuery(new Term(\"id\", testID)), 1);\n          assertEquals(1, hits.totalHits.value);\n          Document doc = r.document(hits.scoreDocs[0].doc);\n          Document docExp = docs.get(testID);\n          for(int i=0;i<fieldCount;i++) {\n            assertEquals(\"doc \" + testID + \", field f\" + fieldCount + \" is wrong\", docExp.get(\"f\"+i),  doc.get(\"f\"+i));\n          }\n        }\n        r.close();\n        w.forceMerge(1);\n      }\n    }\n    w.close();\n    dir.close();\n  }\n\n","bugFix":["f83af14a2a8131b14d7aee6274c740334e0363d3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["6613659748fe4411a7dcf85266e55db1f95f7315"],"55980207f1977bd1463465de1659b821347e2fa8":["d0ef034a4f10871667ae75181537775ddcf8ade4","103857ec20f79f31c7a00310a91ed001b9a6ef17"],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"6613659748fe4411a7dcf85266e55db1f95f7315":["088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"dbc046116d49cd3d0c50f7169cabaa295bc23a4a":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["70b55953b6a72596cb534ead735a8b849a473cac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d0ef034a4f10871667ae75181537775ddcf8ade4":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"103857ec20f79f31c7a00310a91ed001b9a6ef17":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"70b55953b6a72596cb534ead735a8b849a473cac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["71da933d30aea361ccc224d6544c451cbf49916d"],"71da933d30aea361ccc224d6544c451cbf49916d":["dbc046116d49cd3d0c50f7169cabaa295bc23a4a"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["103857ec20f79f31c7a00310a91ed001b9a6ef17"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ae14298f4eec6d5faee6a149f88ba57d14a6f21a"],"55980207f1977bd1463465de1659b821347e2fa8":[],"54a6bea0b991120a99ad0e2f72ae853fd5ecae0e":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"6613659748fe4411a7dcf85266e55db1f95f7315":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"dbc046116d49cd3d0c50f7169cabaa295bc23a4a":["71da933d30aea361ccc224d6544c451cbf49916d"],"088a7ef694fd43d5d9a4d200c4005865f773d1e7":["6613659748fe4411a7dcf85266e55db1f95f7315"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["70b55953b6a72596cb534ead735a8b849a473cac"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["55980207f1977bd1463465de1659b821347e2fa8","103857ec20f79f31c7a00310a91ed001b9a6ef17"],"103857ec20f79f31c7a00310a91ed001b9a6ef17":["55980207f1977bd1463465de1659b821347e2fa8","6654c5f3ec2e4a84ef867c82d4eec872c2372c8c"],"70b55953b6a72596cb534ead735a8b849a473cac":["088a7ef694fd43d5d9a4d200c4005865f773d1e7"],"ae14298f4eec6d5faee6a149f88ba57d14a6f21a":["54a6bea0b991120a99ad0e2f72ae853fd5ecae0e"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["dbc046116d49cd3d0c50f7169cabaa295bc23a4a"],"6654c5f3ec2e4a84ef867c82d4eec872c2372c8c":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"71da933d30aea361ccc224d6544c451cbf49916d":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}