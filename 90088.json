{"path":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","commits":[{"id":"ca83400a04ed1cbfa09560d2e7184f93f5d75363","date":1428921124,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"/dev/null","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    long ms = System.currentTimeMillis();\n    int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS,  () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0,0);\n      for(int i=0;i< ITERS;i++){\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes,0,b.bytes.length);\n        if(STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \"+ (System.currentTimeMillis()-ms));\n    ms = System.currentTimeMillis();\n\n    runInThreads(THREADS,  ()-> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ (System.currentTimeMillis()-ms));\n\n\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93c4a0fd70c7b102c0dcc58e54802670eb4ee728","date":1428956153,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    long ms = System.currentTimeMillis();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes b = l.get(i % l.size());\n          stringBytes1.reset(b.bytes, 0, b.bytes.length);\n          if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n        }\n\n      }\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \"+ (System.currentTimeMillis()-ms));\n    ms = System.currentTimeMillis();\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        String a = null;\n        CharArr arr = new CharArr();\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes sb = l.get(i % l.size());\n          arr.reset();\n          ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n          a = arr.toString();\n        }\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ (System.currentTimeMillis()-ms));\n\n\n\n  }\n\n","sourceOld":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    long ms = System.currentTimeMillis();\n    int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS,  () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0,0);\n      for(int i=0;i< ITERS;i++){\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes,0,b.bytes.length);\n        if(STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \"+ (System.currentTimeMillis()-ms));\n    ms = System.currentTimeMillis();\n\n    runInThreads(THREADS,  ()-> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ (System.currentTimeMillis()-ms));\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bcf9886c8ff537aafde14de48ebf744f5673f08b","date":1439041198,"type":3,"author":"Ramkumar Aiyengar","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes b = l.get(i % l.size());\n          stringBytes1.reset(b.bytes, 0, b.bytes.length);\n          if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n        }\n\n      }\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        String a = null;\n        CharArr arr = new CharArr();\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes sb = l.get(i % l.size());\n          arr.reset();\n          ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n          a = arr.toString();\n        }\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","sourceOld":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    long ms = System.currentTimeMillis();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes b = l.get(i % l.size());\n          stringBytes1.reset(b.bytes, 0, b.bytes.length);\n          if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n        }\n\n      }\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \"+ (System.currentTimeMillis()-ms));\n    ms = System.currentTimeMillis();\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        String a = null;\n        CharArr arr = new CharArr();\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes sb = l.get(i % l.size());\n          arr.reset();\n          ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n          a = arr.toString();\n        }\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ (System.currentTimeMillis()-ms));\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","sourceOld":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes b = l.get(i % l.size());\n          stringBytes1.reset(b.bytes, 0, b.bytes.length);\n          if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n        }\n\n      }\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, new Runnable() {\n      @Override\n      public void run() {\n        String a = null;\n        CharArr arr = new CharArr();\n        for (int i = 0; i < ITERS; i++) {\n          JavaBinCodec.StringBytes sb = l.get(i % l.size());\n          arr.reset();\n          ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n          a = arr.toString();\n        }\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bca807fcb2fa11c40a0c929d869a16376c24932b","date":1476974181,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new MapBackedCache<>(new HashMap<>()) ;\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","sourceOld":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new MapBackedCache<>(new HashMap<>()) ;\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","sourceOld":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new Cache<JavaBinCodec.StringBytes, String>() {\n      private HashMap<JavaBinCodec.StringBytes, String> cache = new HashMap<>();\n\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return cache.put(key, val);\n\n      }\n\n      @Override\n      public String get(JavaBinCodec.StringBytes key) {\n        return cache.get(key);\n      }\n\n      @Override\n      public String remove(JavaBinCodec.StringBytes key) {\n        return cache.remove(key);\n      }\n\n      @Override\n      public void clear() {\n        cache.clear();\n\n      }\n    };\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"220577719e3753e52195ed66dc9af6c4e65e2873","date":1550042623,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/common/util/TestJavaBinCodec#testPerf().mjava","sourceNew":"  private void testPerf() throws InterruptedException {\n    final ArrayList<StringBytes> l = new ArrayList<>();\n    Cache<StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<StringBytes, String> cache1 = new MapBackedCache<>(new HashMap<>()) ;\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    StringBytes stringBytes = new StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      StringBytes stringBytes1 = new StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","sourceOld":"  private void testPerf() throws InterruptedException {\n    final ArrayList<JavaBinCodec.StringBytes> l = new ArrayList<>();\n    Cache<JavaBinCodec.StringBytes, String> cache = null;\n   /* cache = new ConcurrentLRUCache<JavaBinCodec.StringBytes,String>(10000, 9000, 10000, 1000, false, true, null){\n      @Override\n      public String put(JavaBinCodec.StringBytes key, String val) {\n        l.add(key);\n        return super.put(key, val);\n      }\n    };*/\n    Runtime.getRuntime().gc();\n    printMem(\"before cache init\");\n\n    Cache<JavaBinCodec.StringBytes, String> cache1 = new MapBackedCache<>(new HashMap<>()) ;\n    final JavaBinCodec.StringCache STRING_CACHE = new JavaBinCodec.StringCache(cache1);\n\n//    STRING_CACHE = new JavaBinCodec.StringCache(cache);\n    byte[] bytes = new byte[0];\n    JavaBinCodec.StringBytes stringBytes = new JavaBinCodec.StringBytes(null,0,0);\n\n    for(int i=0;i<10000;i++) {\n      String s = String.valueOf(random().nextLong());\n      int end = s.length();\n      int maxSize = end * 4;\n      if (bytes == null || bytes.length < maxSize) bytes = new byte[maxSize];\n      int sz = ByteUtils.UTF16toUTF8(s, 0, end, bytes, 0);\n      STRING_CACHE.get(stringBytes.reset(bytes, 0, sz));\n    }\n    printMem(\"after cache init\");\n\n    RTimer timer = new RTimer();\n    final int ITERS = 1000000;\n    int THREADS = 10;\n\n    runInThreads(THREADS, () -> {\n      JavaBinCodec.StringBytes stringBytes1 = new JavaBinCodec.StringBytes(new byte[0], 0, 0);\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes b = l.get(i % l.size());\n        stringBytes1.reset(b.bytes, 0, b.bytes.length);\n        if (STRING_CACHE.get(stringBytes1) == null) throw new RuntimeException(\"error\");\n      }\n\n    });\n\n\n\n    printMem(\"after cache test\");\n    System.out.println(\"time taken by LRUCACHE \" + timer.getTime());\n    timer = new RTimer();\n\n    runInThreads(THREADS, () -> {\n      String a = null;\n      CharArr arr = new CharArr();\n      for (int i = 0; i < ITERS; i++) {\n        JavaBinCodec.StringBytes sb = l.get(i % l.size());\n        arr.reset();\n        ByteUtils.UTF8toUTF16(sb.bytes, 0, sb.bytes.length, arr);\n        a = arr.toString();\n      }\n    });\n\n    printMem(\"after new string test\");\n    System.out.println(\"time taken by string creation \"+ timer.getTime());\n\n\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"220577719e3753e52195ed66dc9af6c4e65e2873":["bca807fcb2fa11c40a0c929d869a16376c24932b"],"ca83400a04ed1cbfa09560d2e7184f93f5d75363":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["3a0c04b71951333291abc7f317109a6a5957bd28","bca807fcb2fa11c40a0c929d869a16376c24932b"],"bca807fcb2fa11c40a0c929d869a16376c24932b":["3a0c04b71951333291abc7f317109a6a5957bd28"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["93c4a0fd70c7b102c0dcc58e54802670eb4ee728"],"3a0c04b71951333291abc7f317109a6a5957bd28":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"93c4a0fd70c7b102c0dcc58e54802670eb4ee728":["ca83400a04ed1cbfa09560d2e7184f93f5d75363"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["220577719e3753e52195ed66dc9af6c4e65e2873"]},"commit2Childs":{"220577719e3753e52195ed66dc9af6c4e65e2873":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ca83400a04ed1cbfa09560d2e7184f93f5d75363":["93c4a0fd70c7b102c0dcc58e54802670eb4ee728"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ca83400a04ed1cbfa09560d2e7184f93f5d75363"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"bca807fcb2fa11c40a0c929d869a16376c24932b":["220577719e3753e52195ed66dc9af6c4e65e2873","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"bcf9886c8ff537aafde14de48ebf744f5673f08b":["3a0c04b71951333291abc7f317109a6a5957bd28"],"3a0c04b71951333291abc7f317109a6a5957bd28":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","bca807fcb2fa11c40a0c929d869a16376c24932b"],"93c4a0fd70c7b102c0dcc58e54802670eb4ee728":["bcf9886c8ff537aafde14de48ebf744f5673f08b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}