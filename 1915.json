{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"/dev/null","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d31002d4824498d05fb6c4676a515b1fef8f41ce","date":1486389627,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"41f60ea1802fda42d3c91d023406066d00ddb5f8","date":1535615991,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert StringHelper.compare(bytesPerDim, cellMinPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert StringHelper.compare(bytesPerDim, cellMaxPacked, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d774afea15a18cc375fae2ffaa8319935d0a7b2a","date":1536414150,"type":3,"author":"iverase","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue1, state.scratchPackedValue2, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchPackedValue1, state.scratchPackedValue2, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim;\n      assert splitDim < numDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numDims=\" + numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b88a121b875f9ae2ac50f85cf46dcb680f126357","date":1555416009,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert FutureArrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert FutureArrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a14a9a6131884330f34844dabc1ece206ceaea9","date":1561954503,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchIterator);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchIterator, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchDocIDs);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchDocIDs, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb94bf667d51f9c390c99d97afb36b7caab6b6e9","date":1599548621,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDReader#intersect(IntersectState,byte[],byte[]).mjava","sourceNew":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*config.bytesPerDim, config.bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*config.bytesPerDim, config.bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchIterator);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchIterator, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", config.numIndexDims=\" + config.numIndexDims;\n      assert splitDim < config.numIndexDims: \"splitDim=\" + splitDim + \", config.numIndexDims=\" + config.numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == config.bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * config.bytesPerDim, splitDim * config.bytesPerDim + config.bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + config.bytesPerDim) <= 0: \"config.bytesPerDim=\" + config.bytesPerDim + \" splitDim=\" + splitDim + \" config.numIndexDims=\" + config.numIndexDims + \" config.numDims=\" + config.numDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * config.bytesPerDim, splitDim * config.bytesPerDim + config.bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + config.bytesPerDim) >= 0: \"config.bytesPerDim=\" + config.bytesPerDim + \" splitDim=\" + splitDim + \" config.numIndexDims=\" + config.numIndexDims + \" config.numDims=\" + config.numDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, config.packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*config.bytesPerDim, config.bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*config.bytesPerDim, splitDimValue.bytes, splitDimValue.offset, config.bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, config.packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*config.bytesPerDim, config.bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","sourceOld":"  private void intersect(IntersectState state, byte[] cellMinPacked, byte[] cellMaxPacked) throws IOException {\n\n    /*\n    System.out.println(\"\\nR: intersect nodeID=\" + state.index.getNodeID());\n    for(int dim=0;dim<numDims;dim++) {\n      System.out.println(\"  dim=\" + dim + \"\\n    cellMin=\" + new BytesRef(cellMinPacked, dim*bytesPerDim, bytesPerDim) + \"\\n    cellMax=\" + new BytesRef(cellMaxPacked, dim*bytesPerDim, bytesPerDim));\n    }\n    */\n\n    Relation r = state.visitor.compare(cellMinPacked, cellMaxPacked);\n\n    if (r == Relation.CELL_OUTSIDE_QUERY) {\n      // This cell is fully outside of the query shape: stop recursing\n    } else if (r == Relation.CELL_INSIDE_QUERY) {\n      // This cell is fully inside of the query shape: recursively add all points in this cell without filtering\n      addAll(state, false);\n      // The cell crosses the shape boundary, or the cell fully contains the query, so we fall through and do full filtering:\n    } else if (state.index.isLeafNode()) {\n      \n      // TODO: we can assert that the first value here in fact matches what the index claimed?\n      \n      // In the unbalanced case it's possible the left most node only has one child:\n      if (state.index.nodeExists()) {\n        // Leaf node; scan and filter all points in this block:\n        int count = readDocIDs(state.in, state.index.getLeafBlockFP(), state.scratchIterator);\n\n        // Again, this time reading values and checking with the visitor\n        visitDocValues(state.commonPrefixLengths, state.scratchDataPackedValue, state.scratchMinIndexPackedValue, state.scratchMaxIndexPackedValue, state.in, state.scratchIterator, count, state.visitor);\n      }\n\n    } else {\n      \n      // Non-leaf node: recurse on the split left and right nodes\n      int splitDim = state.index.getSplitDim();\n      assert splitDim >= 0: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n      assert splitDim < numIndexDims: \"splitDim=\" + splitDim + \", numIndexDims=\" + numIndexDims;\n\n      byte[] splitPackedValue = state.index.getSplitPackedValue();\n      BytesRef splitDimValue = state.index.getSplitDimValue();\n      assert splitDimValue.length == bytesPerDim;\n      //System.out.println(\"  splitDimValue=\" + splitDimValue + \" splitDim=\" + splitDim);\n\n      // make sure cellMin <= splitValue <= cellMax:\n      assert Arrays.compareUnsigned(cellMinPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) <= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n      assert Arrays.compareUnsigned(cellMaxPacked, splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim, splitDimValue.bytes, splitDimValue.offset, splitDimValue.offset + bytesPerDim) >= 0: \"bytesPerDim=\" + bytesPerDim + \" splitDim=\" + splitDim + \" numIndexDims=\" + numIndexDims + \" numDataDims=\" + numDataDims;\n\n      // Recurse on left sub-tree:\n      System.arraycopy(cellMaxPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushLeft();\n      intersect(state, cellMinPacked, splitPackedValue);\n      state.index.pop();\n\n      // Restore the split dim value since it may have been overwritten while recursing:\n      System.arraycopy(splitPackedValue, splitDim*bytesPerDim, splitDimValue.bytes, splitDimValue.offset, bytesPerDim);\n\n      // Recurse on right sub-tree:\n      System.arraycopy(cellMinPacked, 0, splitPackedValue, 0, packedIndexBytesLength);\n      System.arraycopy(splitDimValue.bytes, splitDimValue.offset, splitPackedValue, splitDim*bytesPerDim, bytesPerDim);\n      state.index.pushRight();\n      intersect(state, splitPackedValue, cellMaxPacked);\n      state.index.pop();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["f6652c943595e92c187ee904c382863013eae28f"],"d31002d4824498d05fb6c4676a515b1fef8f41ce":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["8a14a9a6131884330f34844dabc1ece206ceaea9"],"f6652c943595e92c187ee904c382863013eae28f":["d774afea15a18cc375fae2ffaa8319935d0a7b2a"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["d31002d4824498d05fb6c4676a515b1fef8f41ce"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8a14a9a6131884330f34844dabc1ece206ceaea9":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"d774afea15a18cc375fae2ffaa8319935d0a7b2a":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["d31002d4824498d05fb6c4676a515b1fef8f41ce","9856095f7afb5a607bf5e65077615ed91273508c"],"b88a121b875f9ae2ac50f85cf46dcb680f126357":["8a14a9a6131884330f34844dabc1ece206ceaea9"],"d31002d4824498d05fb6c4676a515b1fef8f41ce":["41f60ea1802fda42d3c91d023406066d00ddb5f8"],"f6652c943595e92c187ee904c382863013eae28f":["b88a121b875f9ae2ac50f85cf46dcb680f126357"],"bb94bf667d51f9c390c99d97afb36b7caab6b6e9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"41f60ea1802fda42d3c91d023406066d00ddb5f8":["d774afea15a18cc375fae2ffaa8319935d0a7b2a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"8a14a9a6131884330f34844dabc1ece206ceaea9":["bb94bf667d51f9c390c99d97afb36b7caab6b6e9"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"d774afea15a18cc375fae2ffaa8319935d0a7b2a":["f6652c943595e92c187ee904c382863013eae28f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}