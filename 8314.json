{"path":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","commits":[{"id":"ecb12132f7aef3ad5be4b300f3cea59aa03b6820","date":1339628268,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // preserve initial values and boost (if any)\n        SolrInputField destField = doc.containsKey(dest) ? \n          doc.getField(dest) : new SolrInputField(dest); \n        \n        boolean modified = false;\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n\n          for (Object val : doc.getFieldValues(fname)) {\n            // preserve existing dest boost (multiplicitive), ignore src boost\n            destField.addValue(val, 1.0f);\n          }\n          modified=true;\n        }\n\n        if (modified) doc.put(dest, destField);\n\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["94a12ae67fdc5a05d48b0155e4c22eaadc00aacc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"94a12ae67fdc5a05d48b0155e4c22eaadc00aacc","date":1420375701,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // preserve initial values and boost (if any)\n        SolrInputField destField = doc.containsKey(dest) ? \n          doc.getField(dest) : new SolrInputField(dest); \n        \n        boolean modified = false;\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n\n          for (Object val : srcFieldValues) {\n            // preserve existing dest boost (multiplicitive), ignore src boost\n            destField.addValue(val, 1.0f);\n          }\n          modified=true;\n        }\n\n        if (modified) doc.put(dest, destField);\n\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // preserve initial values and boost (if any)\n        SolrInputField destField = doc.containsKey(dest) ? \n          doc.getField(dest) : new SolrInputField(dest); \n        \n        boolean modified = false;\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n\n          for (Object val : doc.getFieldValues(fname)) {\n            // preserve existing dest boost (multiplicitive), ignore src boost\n            destField.addValue(val, 1.0f);\n          }\n          modified=true;\n        }\n\n        if (modified) doc.put(dest, destField);\n\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":["ecb12132f7aef3ad5be4b300f3cea59aa03b6820"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0","date":1446511397,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            // preserve existing dest boost (multiplicitive), ignore src boost\n            destField.addValue(val, 1.0f);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (String dest : destMap.keySet()) {\n          doc.put(dest, destMap.get(dest));\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // preserve initial values and boost (if any)\n        SolrInputField destField = doc.containsKey(dest) ? \n          doc.getField(dest) : new SolrInputField(dest); \n        \n        boolean modified = false;\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n\n          for (Object val : srcFieldValues) {\n            // preserve existing dest boost (multiplicitive), ignore src boost\n            destField.addValue(val, 1.0f);\n          }\n          modified=true;\n        }\n\n        if (modified) doc.put(dest, destField);\n\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acd9883560fd89e6448b2b447302fe543040cd4f","date":1488478696,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (String dest : destMap.keySet()) {\n          doc.put(dest, destMap.get(dest));\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            // preserve existing dest boost (multiplicitive), ignore src boost\n            destField.addValue(val, 1.0f);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (String dest : destMap.keySet()) {\n          doc.put(dest, destMap.get(dest));\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","date":1571070979,"type":3,"author":"Koen De Groote","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (Map.Entry<String, SolrInputField> entry : destMap.entrySet()) {\n          doc.put(entry.getKey(), entry.getValue());\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (String dest : destMap.keySet()) {\n          doc.put(dest, destMap.get(dest));\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (Map.Entry<String, SolrInputField> entry : destMap.entrySet()) {\n          doc.put(entry.getKey(), entry.getValue());\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (String dest : destMap.keySet()) {\n          doc.put(dest, destMap.get(dest));\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              if (log.isDebugEnabled()) {\n                log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate('{}') returned true, \" +\n                    \"but replacement pattern did not match, field skipped.\", fname);\n              }\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (Map.Entry<String, SolrInputField> entry : destMap.entrySet()) {\n          doc.put(entry.getKey(), entry.getValue());\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate(\\\"{}\\\") returned true, \" +\n                  \"but replacement pattern did not match, field skipped.\", fname);\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (Map.Entry<String, SolrInputField> entry : destMap.entrySet()) {\n          doc.put(entry.getKey(), entry.getValue());\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/CloneFieldUpdateProcessorFactory#getInstance(SolrQueryRequest,SolrQueryResponse,UpdateRequestProcessor).mjava","sourceNew":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              if (log.isDebugEnabled()) {\n                log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate('{}') returned true, but replacement pattern did not match, field skipped.\"\n                    , fname);\n              }\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (Map.Entry<String, SolrInputField> entry : destMap.entrySet()) {\n          doc.put(entry.getKey(), entry.getValue());\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public final UpdateRequestProcessor getInstance(SolrQueryRequest req,\n                                                  SolrQueryResponse rsp,\n                                                  UpdateRequestProcessor next) {\n    final FieldNameSelector srcSelector = getSourceSelector();\n    return new UpdateRequestProcessor(next) {\n      @Override\n      public void processAdd(AddUpdateCommand cmd) throws IOException {\n\n        final SolrInputDocument doc = cmd.getSolrInputDocument();\n\n        // destination may be regex replace string, which can cause multiple output fields.\n        Map<String,SolrInputField> destMap = new HashMap<>();\n\n        // preserve initial values and boost (if any)\n        for (final String fname : doc.getFieldNames()) {\n          if (! srcSelector.shouldMutate(fname)) continue;\n          \n          Collection<Object> srcFieldValues = doc.getFieldValues(fname);\n          if(srcFieldValues == null || srcFieldValues.isEmpty()) continue;\n          \n          String resolvedDest = dest;\n\n          if (pattern != null) {\n            Matcher matcher = pattern.matcher(fname);\n            if (matcher.find()) {\n              resolvedDest = matcher.replaceAll(dest);\n            } else {\n              if (log.isDebugEnabled()) {\n                log.debug(\"CloneFieldUpdateProcessor.srcSelector.shouldMutate('{}') returned true, \" +\n                    \"but replacement pattern did not match, field skipped.\", fname);\n              }\n              continue;\n            }\n          }\n          SolrInputField destField;\n          if (doc.containsKey(resolvedDest)) {\n            destField = doc.getField(resolvedDest);\n          } else {\n            SolrInputField targetField = destMap.get(resolvedDest);\n            if (targetField == null) {\n              destField = new SolrInputField(resolvedDest);\n            } else {\n              destField = targetField;\n            }\n          }\n\n          for (Object val : srcFieldValues) {\n            destField.addValue(val);\n          }\n          // put it in map to avoid concurrent modification...\n          destMap.put(resolvedDest, destField);\n        }\n\n        for (Map.Entry<String, SolrInputField> entry : destMap.entrySet()) {\n          doc.put(entry.getKey(), entry.getValue());\n        }\n        super.processAdd(cmd);\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"94a12ae67fdc5a05d48b0155e4c22eaadc00aacc":["ecb12132f7aef3ad5be4b300f3cea59aa03b6820"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["acd9883560fd89e6448b2b447302fe543040cd4f"],"740d649f013f07efbeb73ca854f106c60166e7c0":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"],"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0":["94a12ae67fdc5a05d48b0155e4c22eaadc00aacc"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"575e66bd4b2349209027f6801184da7fc3cba13f":["740d649f013f07efbeb73ca854f106c60166e7c0"],"ecb12132f7aef3ad5be4b300f3cea59aa03b6820":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"acd9883560fd89e6448b2b447302fe543040cd4f":["a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["575e66bd4b2349209027f6801184da7fc3cba13f"],"b0b597c65628ca9e73913a07e81691f8229bae35":["acd9883560fd89e6448b2b447302fe543040cd4f","7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0"]},"commit2Childs":{"94a12ae67fdc5a05d48b0155e4c22eaadc00aacc":["a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0"],"7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0":["740d649f013f07efbeb73ca854f106c60166e7c0","b0b597c65628ca9e73913a07e81691f8229bae35"],"740d649f013f07efbeb73ca854f106c60166e7c0":["575e66bd4b2349209027f6801184da7fc3cba13f"],"a82f17a4aec53026c4ca0f2fa62ad8eaed017bb0":["acd9883560fd89e6448b2b447302fe543040cd4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ecb12132f7aef3ad5be4b300f3cea59aa03b6820"],"ecb12132f7aef3ad5be4b300f3cea59aa03b6820":["94a12ae67fdc5a05d48b0155e4c22eaadc00aacc"],"575e66bd4b2349209027f6801184da7fc3cba13f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"acd9883560fd89e6448b2b447302fe543040cd4f":["7b22e06bed98cf8dceb4f71c4d5265e798e7fbd0","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}