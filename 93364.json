{"path":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","commits":[{"id":"5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb","date":1354558878,"type":0,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig();\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig() {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["2dd7584d68ce0dfc89c2fab5bef208382e2e6628"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig();\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig() {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07bc5b253e2373a655fc734d650af4ac46c8614","date":1386093923,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig();\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig() {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":["b34acf30a377e146cfc8f7da3ec9a01e944403e1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig();\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig() {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b34acf30a377e146cfc8f7da3ec9a01e944403e1","date":1469718024,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":["b07bc5b253e2373a655fc734d650af4ac46c8614"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2dd7584d68ce0dfc89c2fab5bef208382e2e6628","date":1502153250,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":["5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[UScript.CODE_LIMIT];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a9381336c4dc91cc20829fb628036012963dc440","date":1515945231,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public RuleBasedBreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (RuleBasedBreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public RuleBasedBreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (RuleBasedBreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fcc05d435c845d2b3c7c10faeb6674cc37ad3527","date":1519133993,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public RuleBasedBreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (RuleBasedBreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1a3e7b7017a06c652c79a772b1259178f6908877","date":1522103499,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public RuleBasedBreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (RuleBasedBreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d61a3e0821ed080b9b21e1328bbaa91dcf79f7d7","date":1522191940,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","pathOld":"lucene/analysis/icu/src/java/org/apache/lucene/analysis/icu/segmentation/ICUTokenizerFactory#inform(ResourceLoader).mjava","sourceNew":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public RuleBasedBreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (RuleBasedBreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","sourceOld":"  @Override\n  public void inform(ResourceLoader loader) throws IOException {\n    assert tailored != null : \"init must be called first!\";\n    if (tailored.isEmpty()) {\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords);\n    } else {\n      final BreakIterator breakers[] = new BreakIterator[1 + UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT)];\n      for (Map.Entry<Integer,String> entry : tailored.entrySet()) {\n        int code = entry.getKey();\n        String resourcePath = entry.getValue();\n        breakers[code] = parseRules(resourcePath, loader);\n      }\n      config = new DefaultICUTokenizerConfig(cjkAsWords, myanmarAsWords) {\n        \n        @Override\n        public BreakIterator getBreakIterator(int script) {\n          if (breakers[script] != null) {\n            return (BreakIterator) breakers[script].clone();\n          } else {\n            return super.getBreakIterator(script);\n          }\n        }\n        // TODO: we could also allow codes->types mapping\n      };\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b94236357aaa22b76c10629851fe4e376e0cea82":["2dd7584d68ce0dfc89c2fab5bef208382e2e6628","a9381336c4dc91cc20829fb628036012963dc440"],"b34acf30a377e146cfc8f7da3ec9a01e944403e1":["b07bc5b253e2373a655fc734d650af4ac46c8614"],"fcc05d435c845d2b3c7c10faeb6674cc37ad3527":["b94236357aaa22b76c10629851fe4e376e0cea82"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb"],"d61a3e0821ed080b9b21e1328bbaa91dcf79f7d7":["fcc05d435c845d2b3c7c10faeb6674cc37ad3527","1a3e7b7017a06c652c79a772b1259178f6908877"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["b07bc5b253e2373a655fc734d650af4ac46c8614","b34acf30a377e146cfc8f7da3ec9a01e944403e1"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["b34acf30a377e146cfc8f7da3ec9a01e944403e1","2dd7584d68ce0dfc89c2fab5bef208382e2e6628"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["b34acf30a377e146cfc8f7da3ec9a01e944403e1","2dd7584d68ce0dfc89c2fab5bef208382e2e6628"],"b07bc5b253e2373a655fc734d650af4ac46c8614":["5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb"],"1a3e7b7017a06c652c79a772b1259178f6908877":["fcc05d435c845d2b3c7c10faeb6674cc37ad3527"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a9381336c4dc91cc20829fb628036012963dc440":["2dd7584d68ce0dfc89c2fab5bef208382e2e6628"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb","b07bc5b253e2373a655fc734d650af4ac46c8614"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["b07bc5b253e2373a655fc734d650af4ac46c8614","b34acf30a377e146cfc8f7da3ec9a01e944403e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d61a3e0821ed080b9b21e1328bbaa91dcf79f7d7"],"2dd7584d68ce0dfc89c2fab5bef208382e2e6628":["b34acf30a377e146cfc8f7da3ec9a01e944403e1"]},"commit2Childs":{"5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb":["407687e67faf6e1f02a211ca078d8e3eed631027","b07bc5b253e2373a655fc734d650af4ac46c8614","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"b94236357aaa22b76c10629851fe4e376e0cea82":["fcc05d435c845d2b3c7c10faeb6674cc37ad3527"],"b34acf30a377e146cfc8f7da3ec9a01e944403e1":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","3b013574eedcdbac35dc7e35b0ee616ffc38895d","2dd7584d68ce0dfc89c2fab5bef208382e2e6628"],"fcc05d435c845d2b3c7c10faeb6674cc37ad3527":["d61a3e0821ed080b9b21e1328bbaa91dcf79f7d7","1a3e7b7017a06c652c79a772b1259178f6908877"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"d61a3e0821ed080b9b21e1328bbaa91dcf79f7d7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"b07bc5b253e2373a655fc734d650af4ac46c8614":["b34acf30a377e146cfc8f7da3ec9a01e944403e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"1a3e7b7017a06c652c79a772b1259178f6908877":["d61a3e0821ed080b9b21e1328bbaa91dcf79f7d7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5d76c4ba90dcb3d7e77f4454d13b4c9beb9c16cb","407687e67faf6e1f02a211ca078d8e3eed631027"],"a9381336c4dc91cc20829fb628036012963dc440":["b94236357aaa22b76c10629851fe4e376e0cea82"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"2dd7584d68ce0dfc89c2fab5bef208382e2e6628":["b94236357aaa22b76c10629851fe4e376e0cea82","58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","a9381336c4dc91cc20829fb628036012963dc440"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","58884af1f68e9d61c217c753fbd6266d86a63b14","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","74f45af4339b0daf7a95c820ab88c1aea74fbce0","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}