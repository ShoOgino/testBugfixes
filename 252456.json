{"path":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","commits":[{"id":"d38eb16935a27250e66a031c80560615df637f95","date":1288085332,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public int advance(int target) throws IOException {\n//      int n = target - start;\n//      do {\n//        if (target >= maxDoc)\n//          return pos = NO_MORE_DOCS;\n//        if (n >= numDocs_) {\n//          int idx = readerIndex(target);\n//          if (enumCache[idx] == null) {\n//            try {\n//              DocValues indexValues = subReaders[idx].docValues(id);\n//              if (indexValues != null) // nocommit does that work with default\n//                // values?\n//                enumCache[idx] = indexValues.getEnum(this.attributes());\n//              else\n//                enumCache[idx] = new DummyEnum(this.attributes(),\n//                    subSlices[idx].length, attr.type());\n//            } catch (IOException ex) {\n//              // nocommit what to do here?\n//              throw new RuntimeException(ex);\n//            }\n//          }\n//          current = enumCache[idx];\n//          start = subSlices[idx].start;\n//          numDocs_ = subSlices[idx].length;\n//          n = target - start;\n//        }\n//        target = start + numDocs_;\n//      } while ((n = current.advance(n)) == NO_MORE_DOCS);\n      return pos = start + current.docID();\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39f3757037aa8f710c0cbf9a76a332de735f58b0","date":1288384416,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","sourceNew":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) // we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum(this.attributes());\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        } else {\n          return currentDoc = currentStart + currentEnum.advance(relativeDoc);\n        }\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","sourceOld":"    @Override\n    public int advance(int target) throws IOException {\n//      int n = target - start;\n//      do {\n//        if (target >= maxDoc)\n//          return pos = NO_MORE_DOCS;\n//        if (n >= numDocs_) {\n//          int idx = readerIndex(target);\n//          if (enumCache[idx] == null) {\n//            try {\n//              DocValues indexValues = subReaders[idx].docValues(id);\n//              if (indexValues != null) // nocommit does that work with default\n//                // values?\n//                enumCache[idx] = indexValues.getEnum(this.attributes());\n//              else\n//                enumCache[idx] = new DummyEnum(this.attributes(),\n//                    subSlices[idx].length, attr.type());\n//            } catch (IOException ex) {\n//              // nocommit what to do here?\n//              throw new RuntimeException(ex);\n//            }\n//          }\n//          current = enumCache[idx];\n//          start = subSlices[idx].start;\n//          numDocs_ = subSlices[idx].length;\n//          n = target - start;\n//        }\n//        target = start + numDocs_;\n//      } while ((n = current.advance(n)) == NO_MORE_DOCS);\n      return pos = start + current.docID();\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","sourceNew":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) // we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum(this.attributes());\n          currentEnum.copyReferences(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        } else {\n          return currentDoc = currentStart + currentEnum.advance(relativeDoc);\n        }\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","sourceOld":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) // we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum(this.attributes());\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        } else {\n          return currentDoc = currentStart + currentEnum.advance(relativeDoc);\n        }\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","date":1291778725,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","sourceNew":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) {// we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        }\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum(this.attributes());\n          currentEnum.copyReferences(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        }\n        target = currentMax; // make sure that we advance to the next enum if the current is exhausted\n\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","sourceOld":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) // we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum(this.attributes());\n          currentEnum.copyReferences(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        } else {\n          return currentDoc = currentStart + currentEnum.advance(relativeDoc);\n        }\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a465ec8e22527bb8add54f75551ee9557a56de25","date":1295309224,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","sourceNew":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) {// we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        }\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum();\n          currentEnum.copyFrom(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        }\n        target = currentMax; // make sure that we advance to the next enum if the current is exhausted\n\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","sourceOld":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) {// we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        }\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum(this.attributes());\n          currentEnum.copyReferences(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        }\n        target = currentMax; // make sure that we advance to the next enum if the current is exhausted\n\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"605b061fadf71aa6458c0005eaae83a98350c403","date":1307117658,"type":5,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/values/MultiIndexDocValues.MultiValuesEnum#advance(int).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/values/MultiDocValues.MultiValuesEnum#advance(int).mjava","sourceNew":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) {// we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        }\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum();\n          currentEnum.copyFrom(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        }\n        target = currentMax; // make sure that we advance to the next enum if the current is exhausted\n\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","sourceOld":"    @Override\n    public int advance(int target) throws IOException {\n      assert target > currentDoc : \"target \" + target\n          + \" must be > than the current doc \" + currentDoc;\n      int relativeDoc = target - currentStart;\n      do {\n        if (target >= maxDoc) {// we are beyond max doc\n          return currentDoc = NO_MORE_DOCS;\n        }\n        if (target >= currentMax) {\n          final int idx = ReaderUtil.subIndex(target, starts);\n          currentEnum.close();\n          currentEnum = docValuesIdx[idx].docValues.getEnum();\n          currentEnum.copyFrom(this);\n          currentStart = docValuesIdx[idx].start;\n          currentMax = currentStart + docValuesIdx[idx].length;\n          relativeDoc = target - currentStart;\n        }\n        target = currentMax; // make sure that we advance to the next enum if the current is exhausted\n\n      } while ((relativeDoc = currentEnum.advance(relativeDoc)) == NO_MORE_DOCS);\n      return currentDoc = currentStart + relativeDoc;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"605b061fadf71aa6458c0005eaae83a98350c403":["a465ec8e22527bb8add54f75551ee9557a56de25"],"39f3757037aa8f710c0cbf9a76a332de735f58b0":["d38eb16935a27250e66a031c80560615df637f95"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["3bb13258feba31ab676502787ab2e1779f129b7a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d38eb16935a27250e66a031c80560615df637f95":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a465ec8e22527bb8add54f75551ee9557a56de25":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b"],"3bb13258feba31ab676502787ab2e1779f129b7a":["39f3757037aa8f710c0cbf9a76a332de735f58b0","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"605b061fadf71aa6458c0005eaae83a98350c403":[],"39f3757037aa8f710c0cbf9a76a332de735f58b0":["3bb13258feba31ab676502787ab2e1779f129b7a"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["a465ec8e22527bb8add54f75551ee9557a56de25"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d38eb16935a27250e66a031c80560615df637f95","3bb13258feba31ab676502787ab2e1779f129b7a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d38eb16935a27250e66a031c80560615df637f95":["39f3757037aa8f710c0cbf9a76a332de735f58b0"],"a465ec8e22527bb8add54f75551ee9557a56de25":["605b061fadf71aa6458c0005eaae83a98350c403"],"3bb13258feba31ab676502787ab2e1779f129b7a":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["605b061fadf71aa6458c0005eaae83a98350c403","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}