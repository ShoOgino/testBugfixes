{"path":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","commits":[{"id":"717e5ceb2acae36d422ec75e5a4ce9fac40506e1","date":1501239603,"type":0,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  protected static ZkStateReader buildClusterState(String string, int replicationFactor, String ... liveNodes) {\n    return buildClusterState(string, replicationFactor, 10, liveNodes);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  protected static ZkStateReader buildClusterState(String string, int replicationFactor, String ... liveNodes) {\n    return buildClusterState(string, replicationFactor, 10, liveNodes);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","pathOld":"/dev/null","sourceNew":"  protected static ZkStateReader buildClusterState(String string, int replicationFactor, String ... liveNodes) {\n    return buildClusterState(string, replicationFactor, 10, liveNodes);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f6c2c088b7e829984b5bca4359702c0d5ccc62b","date":1581143367,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","sourceNew":"  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, String ... liveNodes) {\n    return buildClusterState(clusterDescription, replicationFactor, 10, liveNodes);\n  }\n\n","sourceOld":"  protected static ZkStateReader buildClusterState(String string, int replicationFactor, String ... liveNodes) {\n    return buildClusterState(string, replicationFactor, 10, liveNodes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ClusterStateMockUtil#buildClusterState(String,int,String...).mjava","sourceNew":"  /**\n   * This method lets you construct a complex ClusterState object by using simple strings of letters.\n   *\n   * c = collection, s = slice, r = replica (nrt type, default), n = nrt replica, t = tlog replica, p = pull replica, \\d = node number (r2 means the replica is on node 2),\n   * state = [A,R,D,F], * = replica to replace, binds to the left.\n   *\n   * For example:\n   * csrr2rD*sr2csr\n   *\n   * Creates:\n   *\n   * 'csrr2rD*'\n   * A collection, a shard, a replica on node 1 (the default) that is active (the default), a replica on node 2, and a replica on node 1\n   * that has a state of down and is the replica we will be looking to put somewhere else (the *).\n   *\n   * 'sr2'\n   * Then, another shard that has a replica on node 2.\n   *\n   * 'csr'\n   * Then, another collection that has a shard with a single active replica on node 1.\n   *\n   * Result:\n   *        {\n   *         \"collection2\":{\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica5\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}}}},\n   *         \"collection1\":{\n   *           \"replicationFactor\":\"1\",\n   *           \"shards\":{\n   *             \"slice1\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\n   *                 \"replica3 (bad)\":{\n   *                   \"state\":\"down\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"},\n   *                 \"replica2\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"},\n   *                 \"replica1\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl1_\",\n   *                   \"base_url\":\"http://baseUrl1\"}}},\n   *             \"slice2\":{\n   *               \"state\":\"active\",\n   *               \"replicas\":{\"replica4\":{\n   *                   \"state\":\"active\",\n   *                   \"node_name\":\"baseUrl2_\",\n   *                   \"base_url\":\"http://baseUrl2\"}}}}}}\n   *\n   */\n  @SuppressWarnings(\"resource\")\n  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, String ... liveNodes) {\n    Map<String,Slice> slices = null;\n    Map<String,Replica> replicas = null;\n    Map<String,Object> collectionProps = new HashMap<>();\n    collectionProps.put(ZkStateReader.REPLICATION_FACTOR, Integer.toString(replicationFactor));\n    Map<String,DocCollection> collectionStates = new HashMap<>();\n    DocCollection docCollection = null;\n    String collName = null;\n    String sliceName = null;\n    Slice slice = null;\n    int replicaCount = 1;\n\n    Matcher m = BLUEPRINT.matcher(clusterDescription);\n    while (m.find()) {\n      Replica replica;\n      switch (m.group(1)) {\n        case \"c\":\n          slices = new HashMap<>();\n          docCollection = new DocCollection(collName = \"collection\" + (collectionStates.size() + 1), slices, collectionProps, DocRouter.DEFAULT);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"s\":\n          replicas = new HashMap<>();\n          if(collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          slice = new Slice(sliceName = \"slice\" + (slices.size() + 1), replicas, null,  collName);\n          slices.put(slice.getName(), slice);\n\n          // hack alert: the DocCollection constructor copies over active slices to its active slice map in the constructor\n          // but here we construct the DocCollection before creating the slices which breaks code that calls DocCollection.getActiveSlices\n          // so here we re-create doc collection with the latest slices map to workaround this problem\n          // todo: a better fix would be to have a builder class for DocCollection that builds the final object once all the slices and replicas have been created.\n          docCollection = docCollection.copyWithSlices(slices);\n          collectionStates.put(docCollection.getName(), docCollection);\n          break;\n        case \"r\":\n        case \"n\":\n        case \"t\":\n        case \"p\":\n          String node = m.group(2);\n          String replicaName = \"replica\" + replicaCount++;\n          String stateCode = m.group(3);\n\n          Map<String, Object> replicaPropMap = makeReplicaProps(sliceName, node, replicaName, stateCode, m.group(1));\n          if (collName == null) collName = \"collection\" + (collectionStates.size() + 1);\n          if (sliceName == null) collName = \"slice\" + (slices.size() + 1);\n\n          // O(n^2) alert! but this is for mocks and testing so shouldn't be used for very large cluster states\n          boolean leaderFound = false;\n          for (Map.Entry<String, Replica> entry : replicas.entrySet()) {\n            Replica value = entry.getValue();\n            if (\"true\".equals(value.get(Slice.LEADER)))  {\n              leaderFound = true;\n              break;\n            }\n          }\n          if (!leaderFound && !m.group(1).equals(\"p\")) {\n            replicaPropMap.put(Slice.LEADER, \"true\");\n          }\n          replica = new Replica(replicaName, replicaPropMap, collName, sliceName);\n          replicas.put(replica.getName(), replica);\n\n          // hack alert: re-create slice with existing data and new replicas map so that it updates its internal leader attribute\n          slice = new Slice(slice.getName(), replicas, null, collName);\n          slices.put(slice.getName(), slice);\n          // we don't need to update doc collection again because we aren't adding a new slice or changing its state\n          break;\n        default:\n          break;\n      }\n    }\n\n    ClusterState clusterState = new ClusterState(new HashSet<>(Arrays.asList(liveNodes)), collectionStates);\n    MockZkStateReader reader = new MockZkStateReader(clusterState, collectionStates.keySet());\n\n    String json;\n    json = new String(Utils.toJSON(clusterState), StandardCharsets.UTF_8);\n    System.err.println(json);\n\n    return reader;\n  }\n\n","sourceOld":"  public static ZkStateReader buildClusterState(String clusterDescription, int replicationFactor, String ... liveNodes) {\n    return buildClusterState(clusterDescription, replicationFactor, 10, liveNodes);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","717e5ceb2acae36d422ec75e5a4ce9fac40506e1"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["7f6c2c088b7e829984b5bca4359702c0d5ccc62b"],"7f6c2c088b7e829984b5bca4359702c0d5ccc62b":["560c18d71dad43d675158783c3840f8c80d6d39c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"717e5ceb2acae36d422ec75e5a4ce9fac40506e1":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","717e5ceb2acae36d422ec75e5a4ce9fac40506e1","560c18d71dad43d675158783c3840f8c80d6d39c"],"560c18d71dad43d675158783c3840f8c80d6d39c":["7f6c2c088b7e829984b5bca4359702c0d5ccc62b"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7f6c2c088b7e829984b5bca4359702c0d5ccc62b":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}