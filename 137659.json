{"path":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","commits":[{"id":"b0f2476332da483dc2ea1fdd80b5968380653166","date":1316180489,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,boolean,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param morePopular return only suggested words that are as frequent or more frequent than the searched word\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      suggestion.string = s.termAsString != null ? s.termAsString : s.term.utf8ToChars(spare).toString();\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param morePopular return only suggested words that are as frequent or more frequent than the searched word\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      boolean morePopular, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    // see line 341 of spellchecker. this is certainly very very nice for perf,\n    // but is it really the right way to go?\n    if (!morePopular && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (!morePopular) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      suggestion.string = s.termAsString != null ? s.termAsString : s.term.utf8ToChars(spare).toString();\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"66c26763d21cb6a60acfa6b3511a16ec34e7c345","date":1316182593,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      suggestion.string = s.termAsString != null ? s.termAsString : s.term.utf8ToChars(spare).toString();\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param morePopular return only suggested words that are as frequent or more frequent than the searched word\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      suggestion.string = s.termAsString != null ? s.termAsString : s.term.utf8ToChars(spare).toString();\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0","date":1322229341,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      suggestion.string = s.termAsString != null ? s.termAsString : s.term.utf8ToChars(spare).toString();\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ac0d54bf0c091b2781da45d4c3958d5437953b2","date":1322230800,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","pathOld":"modules/suggest/src/java/org/apache/lucene/search/spell/DirectSpellChecker#suggestSimilar(Term,int,IndexReader,SuggestMode,float).mjava","sourceNew":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","sourceOld":"  /**\n   * Suggest similar words.\n   * \n   * <p>Unlike {@link SpellChecker}, the similarity used to fetch the most\n   * relevant terms is an edit distance, therefore typically a low value\n   * for numSug will work very well.\n   * \n   * @param term Term you want to spell check on\n   * @param numSug the maximum number of suggested words\n   * @param ir IndexReader to find terms from\n   * @param suggestMode specifies when to return suggested words\n   * @param accuracy return only suggested words that match with this similarity\n   * @return sorted list of the suggested words according to the comparator\n   * @throws IOException\n   */\n  public SuggestWord[] suggestSimilar(Term term, int numSug, IndexReader ir, \n      SuggestMode suggestMode, float accuracy) throws IOException {\n    final CharsRef spare = new CharsRef();\n    String text = term.text();\n    if (minQueryLength > 0 && text.codePointCount(0, text.length()) < minQueryLength)\n      return new SuggestWord[0];\n    \n    if (lowerCaseTerms) {\n      term = new Term(term.field(), text.toLowerCase(Locale.ENGLISH));\n    }\n    \n    int docfreq = ir.docFreq(term);\n    \n    if (suggestMode==SuggestMode.SUGGEST_WHEN_NOT_IN_INDEX && docfreq > 0) {\n      return new SuggestWord[0];\n    }\n    \n    int maxDoc = ir.maxDoc();\n    \n    if (maxQueryFrequency >= 1f && docfreq > maxQueryFrequency) {\n      return new SuggestWord[0];\n    } else if (docfreq > (int) Math.ceil(maxQueryFrequency * (float)maxDoc)) {\n      return new SuggestWord[0];\n    }\n    \n    if (suggestMode!=SuggestMode.SUGGEST_MORE_POPULAR) docfreq = 0;\n    \n    if (thresholdFrequency >= 1f) {\n      docfreq = Math.max(docfreq, (int) thresholdFrequency);\n    } else if (thresholdFrequency > 0f) {\n      docfreq = Math.max(docfreq, (int)(thresholdFrequency * (float)maxDoc)-1);\n    }\n    \n    Collection<ScoreTerm> terms = null;\n    int inspections = numSug * maxInspections;\n    \n    // try ed=1 first, in case we get lucky\n    terms = suggestSimilar(term, inspections, ir, docfreq, 1, accuracy, spare);\n    if (maxEdits > 1 && terms.size() < inspections) {\n      HashSet<ScoreTerm> moreTerms = new HashSet<ScoreTerm>();\n      moreTerms.addAll(terms);\n      moreTerms.addAll(suggestSimilar(term, inspections, ir, docfreq, maxEdits, accuracy, spare));\n      terms = moreTerms;\n    }\n    \n    // create the suggestword response, sort it, and trim it to size.\n    \n    SuggestWord suggestions[] = new SuggestWord[terms.size()];\n    int index = suggestions.length - 1;\n    for (ScoreTerm s : terms) {\n      SuggestWord suggestion = new SuggestWord();\n      if (s.termAsString == null) {\n        UnicodeUtil.UTF8toUTF16(s.term, spare);\n        s.termAsString = spare.toString();\n      }\n      suggestion.string = s.termAsString;\n      suggestion.score = s.score;\n      suggestion.freq = s.docfreq;\n      suggestions[index--] = suggestion;\n    }\n    \n    ArrayUtil.mergeSort(suggestions, Collections.reverseOrder(comparator));\n    if (numSug < suggestions.length) {\n      SuggestWord trimmed[] = new SuggestWord[numSug];\n      System.arraycopy(suggestions, 0, trimmed, 0, numSug);\n      suggestions = trimmed;\n    }\n    return suggestions;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0":["66c26763d21cb6a60acfa6b3511a16ec34e7c345"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["0ac0d54bf0c091b2781da45d4c3958d5437953b2"],"b0f2476332da483dc2ea1fdd80b5968380653166":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"66c26763d21cb6a60acfa6b3511a16ec34e7c345":["b0f2476332da483dc2ea1fdd80b5968380653166"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0ac0d54bf0c091b2781da45d4c3958d5437953b2":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"da6c07e76d701edbcc45c3e83ad8464a5e44a4c0":["0ac0d54bf0c091b2781da45d4c3958d5437953b2"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b0f2476332da483dc2ea1fdd80b5968380653166":["66c26763d21cb6a60acfa6b3511a16ec34e7c345"],"66c26763d21cb6a60acfa6b3511a16ec34e7c345":["da6c07e76d701edbcc45c3e83ad8464a5e44a4c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b0f2476332da483dc2ea1fdd80b5968380653166"],"0ac0d54bf0c091b2781da45d4c3958d5437953b2":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}