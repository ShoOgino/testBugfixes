{"path":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","commits":[{"id":"a1b3a24d5d9b47345473ff564f5cc127a7b526b4","date":1306277076,"type":1,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2e10cb22a8bdb44339e282925a29182bb2f3174d","date":1306841137,"type":1,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"solr/src/java/org/apache/solr/util/ByteUtils#UTF8toUTF16(byte[],int,int,char[],int).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /** Converts utf8 to utf16 and returns the number of 16 bit Java chars written.\n   * Full characters are read, even if this reads past the length passed (and can result in\n   * an ArrayOutOfBoundsException if invalid UTF8 is passed).  Explicit checks for valid UTF8 are not performed.\n   * The char[] out should probably have enough room to hold the worst case of each byte becoming a Java char.\n   */\n  public static int UTF8toUTF16(byte[] utf8, int offset, int len, char[] out, int out_offset) {\n    int out_start = out_offset;\n    final int limit = offset + len;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < 0xffff) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & 0x3FFL) + 0xDC00);          \n        }\n      }\n    }\n\n    return out_offset - out_start;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"867c935d21f9b0e5740841f988a4919546dcb374","date":1322417002,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b3be20ca1091c0b7cdb2308b9023606a5e451cec","date":1327877325,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b=\" + b;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b=\" + b;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b=\" + b;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","pathOld":"lucene/src/java/org/apache/lucene/util/UnicodeUtil#UTF8toUTF16(byte[],int,int,CharsRef).mjava","sourceNew":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b=\" + b;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","sourceOld":"  /**\n   * Interprets the given byte array as UTF-8 and converts to UTF-16. The {@link CharsRef} will be extended if \n   * it doesn't provide enough space to hold the worst case of each byte becoming a UTF-16 codepoint.\n   * <p>\n   * NOTE: Full characters are read, even if this reads past the length passed (and\n   * can result in an ArrayOutOfBoundsException if invalid UTF-8 is passed).\n   * Explicit checks for valid UTF-8 are not performed. \n   */\n  // TODO: broken if chars.offset != 0\n  public static void UTF8toUTF16(byte[] utf8, int offset, int length, CharsRef chars) {\n    int out_offset = chars.offset = 0;\n    final char[] out = chars.chars =  ArrayUtil.grow(chars.chars, length);\n    final int limit = offset + length;\n    while (offset < limit) {\n      int b = utf8[offset++]&0xff;\n      if (b < 0xc0) {\n        assert b < 0x80;\n        out[out_offset++] = (char)b;\n      } else if (b < 0xe0) {\n        out[out_offset++] = (char)(((b&0x1f)<<6) + (utf8[offset++]&0x3f));\n      } else if (b < 0xf0) {\n        out[out_offset++] = (char)(((b&0xf)<<12) + ((utf8[offset]&0x3f)<<6) + (utf8[offset+1]&0x3f));\n        offset += 2;\n      } else {\n        assert b < 0xf8: \"b=\" + b;\n        int ch = ((b&0x7)<<18) + ((utf8[offset]&0x3f)<<12) + ((utf8[offset+1]&0x3f)<<6) + (utf8[offset+2]&0x3f);\n        offset += 3;\n        if (ch < UNI_MAX_BMP) {\n          out[out_offset++] = (char)ch;\n        } else {\n          int chHalf = ch - 0x0010000;\n          out[out_offset++] = (char) ((chHalf >> 10) + 0xD800);\n          out[out_offset++] = (char) ((chHalf & HALF_MASK) + 0xDC00);          \n        }\n      }\n    }\n    chars.length = out_offset - chars.offset;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["867c935d21f9b0e5740841f988a4919546dcb374"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["867c935d21f9b0e5740841f988a4919546dcb374","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["867c935d21f9b0e5740841f988a4919546dcb374","b3be20ca1091c0b7cdb2308b9023606a5e451cec"],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"867c935d21f9b0e5740841f988a4919546dcb374":["a1b3a24d5d9b47345473ff564f5cc127a7b526b4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"2e10cb22a8bdb44339e282925a29182bb2f3174d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a1b3a24d5d9b47345473ff564f5cc127a7b526b4"]},"commit2Childs":{"b3be20ca1091c0b7cdb2308b9023606a5e451cec":["817882884229bace7dc5d1b75f6b0e4aa1e47122","3a119bbc8703c10faa329ec201c654b3a35a1e3e","5b6fdfce35d0adb18836cf8711abe487a934df33"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":[],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","a1b3a24d5d9b47345473ff564f5cc127a7b526b4","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"a1b3a24d5d9b47345473ff564f5cc127a7b526b4":["5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","867c935d21f9b0e5740841f988a4919546dcb374","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"867c935d21f9b0e5740841f988a4919546dcb374":["b3be20ca1091c0b7cdb2308b9023606a5e451cec","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"2e10cb22a8bdb44339e282925a29182bb2f3174d":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","5b6fdfce35d0adb18836cf8711abe487a934df33","cd5edd1f2b162a5cfa08efd17851a07373a96817","2e10cb22a8bdb44339e282925a29182bb2f3174d"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}