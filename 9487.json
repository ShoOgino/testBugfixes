{"path":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","commits":[{"id":"ff403346522eaa9de75403763e297e83a3ea585c","date":1384904731,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","pathOld":"/dev/null","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<FacetRange>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","pathOld":"/dev/null","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<FacetRange>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<FacetRange>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f719faa74f7213d4a395510dbc1f1b7cb178484","date":1410881394,"type":5,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/contrib/analytics/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","pathOld":"solr/core/src/java/org/apache/solr/analytics/util/RangeEndpointCalculator#getRanges().mjava","sourceNew":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","sourceOld":"  public List<FacetRange> getRanges(){\n\n    final T start = getValue(request.getStart());\n    T end = getValue(request.getEnd()); // not final, hardend may change this\n    \n    if( end.compareTo(start) < 0 ){\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"range facet 'end' comes before 'start': \"+end+\" < \"+start);\n    }\n    \n    // explicitly return the gap.  compute this early so we are more \n    // likely to catch parse errors before attempting math\n    final String[] gaps = request.getGaps();\n    String gap = gaps[0];\n    \n    final EnumSet<FacetRangeInclude> include = request.getInclude();\n        \n    T low = start;\n    \n    List<FacetRange> ranges = new ArrayList<>();\n    \n    int gapCounter = 0;\n    \n    while (low.compareTo(end) < 0) {\n      if (gapCounter<gaps.length) {\n        gap = gaps[gapCounter++];\n      }\n      T high = addGap(low,gap);\n      if (end.compareTo(high) < 0) {\n        if (request.isHardEnd()){\n          high = end;\n        } else {\n          end = high;\n        }\n      }\n      \n      if (high.compareTo(low) < 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop (is gap negative? did the math overflow?)\");\n      }\n      \n      if (high.compareTo(low) == 0) {\n        throw new SolrException (SolrException.ErrorCode.BAD_REQUEST, \"range facet infinite loop: gap is either zero, or too small relative start/end and caused underflow: \" + low + \" + \" + gap + \" = \" + high );\n      }\n      \n      final boolean includeLower = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.LOWER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == low.compareTo(start)));\n      final boolean includeUpper = (include.contains(FacetRangeInclude.ALL) ||\n                                    include.contains(FacetRangeInclude.UPPER) ||\n                                   (include.contains(FacetRangeInclude.EDGE) && \n                                   0 == high.compareTo(end)));\n      \n      final String lowS = formatValue(low);\n      final String highS = formatValue(high);\n\n      ranges.add( new FacetRange(lowS,lowS,highS,includeLower,includeUpper) );\n      low = high;\n    }\n    \n    final Set<FacetRangeOther> others = request.getOthers();\n    if (null != others && 0 < others.size() ) {\n      \n      // no matter what other values are listed, we don't do\n      // anything if \"none\" is specified.\n      if( !others.contains(FacetRangeOther.NONE) ) {\n        \n        boolean all = others.contains(FacetRangeOther.ALL);\n\n        if (all || others.contains(FacetRangeOther.BEFORE)) {\n          // include upper bound if \"outer\" or if first gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.BEFORE.toString(), \n                                        null, formatValue(start), false, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                            !(include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE)) ) );\n          \n        }\n        if (all || others.contains(FacetRangeOther.AFTER)) {\n          // include lower bound if \"outer\" or if last gap doesn't already include it\n          ranges.add( new FacetRange(FacetRangeOther.AFTER.toString(), \n                                        formatValue(end), null, include.contains(FacetRangeInclude.OUTER) || include.contains(FacetRangeInclude.ALL) ||\n                                                   !(include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE)), false) );\n        }\n        if (all || others.contains(FacetRangeOther.BETWEEN)) {\n          ranges.add( new FacetRange(FacetRangeOther.BETWEEN.toString(), formatValue(start), formatValue(end),\n                                        include.contains(FacetRangeInclude.LOWER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL),\n                                        include.contains(FacetRangeInclude.UPPER) || include.contains(FacetRangeInclude.EDGE) || include.contains(FacetRangeInclude.ALL)) );\n        }\n      }\n      \n    }\n  \n    return ranges;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ff403346522eaa9de75403763e297e83a3ea585c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ff403346522eaa9de75403763e297e83a3ea585c"],"ff403346522eaa9de75403763e297e83a3ea585c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0f719faa74f7213d4a395510dbc1f1b7cb178484":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f719faa74f7213d4a395510dbc1f1b7cb178484"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0f719faa74f7213d4a395510dbc1f1b7cb178484"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","ff403346522eaa9de75403763e297e83a3ea585c"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"ff403346522eaa9de75403763e297e83a3ea585c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0f719faa74f7213d4a395510dbc1f1b7cb178484":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}