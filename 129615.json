{"path":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#setupAllFields().mjava","commits":[{"id":"96ecd141e96e7a7a65822d7fada5ddc585b21149","date":1534786652,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#setupAllFields().mjava","pathOld":"/dev/null","sourceNew":"  private static void setupAllFields() throws IOException {\n\n    IndexSchema schema = h.getCore().getLatestSchema();\n\n    // Add all the types before the fields.\n    Map<String, Map<String, String>> fieldsToAdd = new HashMap<>();\n\n    // We need our special id fields to find the docs later.\n    typesHolder.addFieldType(schema, idNotStoredDv, RetrieveFieldType.TEST_TYPE.STRING);\n    fieldsToAdd.put(idNotStoredDv, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n    typesHolder.addFieldType(schema, idStoredNotDv, RetrieveFieldType.TEST_TYPE.STRING);\n    fieldsToAdd.put(idStoredNotDv, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"false\"));\n\n    for (RetrieveFieldType.TEST_TYPE type : RetrieveFieldType.solrClassMap.keySet()) {\n      // We happen to be naming the fields and types identically.\n      String myName = type.toString() + storedNotDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + storedAndDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + notStoredDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + storedNotDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"true\"));\n\n      myName = type.toString() + storedAndDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"true\", \"multiValued\", \"true\"));\n\n      myName = type.toString() + notStoredDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"true\"));\n    }\n\n    schema = typesHolder.addFieldTypes(schema);\n\n    for (Map.Entry<String, Map<String, String>> ent : fieldsToAdd.entrySet()) {\n      fieldsHolder.addField(schema, ent.getKey(), ent.getKey(), ent.getValue());\n    }\n    schema = fieldsHolder.addFields(schema);\n\n    h.getCore().setLatestSchema(schema);\n\n    // All that setup work and we're only going to add a very few docs!\n    for (int idx = 0; idx < 10; ++idx) {\n      addDocWithAllFields(idx);\n    }\n    assertU(commit());\n    // Now we need to massage the expected values returned based on the docValues type 'cause it's weird.\n    final RefCounted<SolrIndexSearcher> refCounted = h.getCore().getNewestSearcher(true);\n    try {\n      //static Map<String, Map<String, List<String>>>\n      for (Map<String, List<String>> docFieldsEnt : allFieldValuesInput.values()) {\n        for (Map.Entry<String, List<String>> oneField : docFieldsEnt.entrySet()) {\n          RetrieveField field = fieldsHolder.getTestField(oneField.getKey());\n          field.expectedValsAsStrings(refCounted.get().getSlowAtomicReader().getFieldInfos().fieldInfo(field.name),\n              oneField.getValue());\n        }\n      }\n    } finally {\n      refCounted.decref();\n    }\n   }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#setupAllFields().mjava","pathOld":"solr/core/src/test/org/apache/solr/response/TestRetrieveFieldsOptimizer#setupAllFields().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private static void setupAllFields() throws IOException {\n\n    IndexSchema schema = h.getCore().getLatestSchema();\n\n    // Add all the types before the fields.\n    Map<String, Map<String, String>> fieldsToAdd = new HashMap<>();\n\n    // We need our special id fields to find the docs later.\n    typesHolder.addFieldType(schema, idNotStoredDv, RetrieveFieldType.TEST_TYPE.STRING);\n    fieldsToAdd.put(idNotStoredDv, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n    typesHolder.addFieldType(schema, idStoredNotDv, RetrieveFieldType.TEST_TYPE.STRING);\n    fieldsToAdd.put(idStoredNotDv, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"false\"));\n\n    for (RetrieveFieldType.TEST_TYPE type : RetrieveFieldType.solrClassMap.keySet()) {\n      // We happen to be naming the fields and types identically.\n      String myName = type.toString() + storedNotDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + storedAndDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + notStoredDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + storedNotDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"true\"));\n\n      myName = type.toString() + storedAndDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"true\", \"multiValued\", \"true\"));\n\n      myName = type.toString() + notStoredDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"true\"));\n    }\n\n    schema = typesHolder.addFieldTypes(schema);\n\n    for (Map.Entry<String, Map<String, String>> ent : fieldsToAdd.entrySet()) {\n      fieldsHolder.addField(schema, ent.getKey(), ent.getKey(), ent.getValue());\n    }\n    schema = fieldsHolder.addFields(schema);\n\n    h.getCore().setLatestSchema(schema);\n\n    // All that setup work and we're only going to add a very few docs!\n    for (int idx = 0; idx < 10; ++idx) {\n      addDocWithAllFields(idx);\n    }\n    assertU(commit());\n    // Now we need to massage the expected values returned based on the docValues type 'cause it's weird.\n    final RefCounted<SolrIndexSearcher> refCounted = h.getCore().getNewestSearcher(true);\n    try {\n      //static Map<String, Map<String, List<String>>>\n      for (Map<String, List<String>> docFieldsEnt : allFieldValuesInput.values()) {\n        for (Map.Entry<String, List<String>> oneField : docFieldsEnt.entrySet()) {\n          RetrieveField field = fieldsHolder.getTestField(oneField.getKey());\n          field.expectedValsAsStrings(refCounted.get().getSlowAtomicReader().getFieldInfos().fieldInfo(field.name),\n              oneField.getValue());\n        }\n      }\n    } finally {\n      refCounted.decref();\n    }\n   }\n\n","sourceOld":"  private static void setupAllFields() throws IOException {\n\n    IndexSchema schema = h.getCore().getLatestSchema();\n\n    // Add all the types before the fields.\n    Map<String, Map<String, String>> fieldsToAdd = new HashMap<>();\n\n    // We need our special id fields to find the docs later.\n    typesHolder.addFieldType(schema, idNotStoredDv, RetrieveFieldType.TEST_TYPE.STRING);\n    fieldsToAdd.put(idNotStoredDv, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n    typesHolder.addFieldType(schema, idStoredNotDv, RetrieveFieldType.TEST_TYPE.STRING);\n    fieldsToAdd.put(idStoredNotDv, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"false\"));\n\n    for (RetrieveFieldType.TEST_TYPE type : RetrieveFieldType.solrClassMap.keySet()) {\n      // We happen to be naming the fields and types identically.\n      String myName = type.toString() + storedNotDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + storedAndDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + notStoredDvSv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"false\"));\n\n      myName = type.toString() + storedNotDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"false\", \"multiValued\", \"true\"));\n\n      myName = type.toString() + storedAndDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"true\", \"docValues\", \"true\", \"multiValued\", \"true\"));\n\n      myName = type.toString() + notStoredDvMv;\n      typesHolder.addFieldType(schema, myName, type);\n      fieldsToAdd.put(myName, map(\"stored\", \"false\", \"docValues\", \"true\", \"multiValued\", \"true\"));\n    }\n\n    schema = typesHolder.addFieldTypes(schema);\n\n    for (Map.Entry<String, Map<String, String>> ent : fieldsToAdd.entrySet()) {\n      fieldsHolder.addField(schema, ent.getKey(), ent.getKey(), ent.getValue());\n    }\n    schema = fieldsHolder.addFields(schema);\n\n    h.getCore().setLatestSchema(schema);\n\n    // All that setup work and we're only going to add a very few docs!\n    for (int idx = 0; idx < 10; ++idx) {\n      addDocWithAllFields(idx);\n    }\n    assertU(commit());\n    // Now we need to massage the expected values returned based on the docValues type 'cause it's weird.\n    final RefCounted<SolrIndexSearcher> refCounted = h.getCore().getNewestSearcher(true);\n    try {\n      //static Map<String, Map<String, List<String>>>\n      for (Map<String, List<String>> docFieldsEnt : allFieldValuesInput.values()) {\n        for (Map.Entry<String, List<String>> oneField : docFieldsEnt.entrySet()) {\n          RetrieveField field = fieldsHolder.getTestField(oneField.getKey());\n          field.expectedValsAsStrings(refCounted.get().getSlowAtomicReader().getFieldInfos().fieldInfo(field.name),\n              oneField.getValue());\n        }\n      }\n    } finally {\n      refCounted.decref();\n    }\n   }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e98520789adb1d5ad05afb4956eca0944a929688"],"e98520789adb1d5ad05afb4956eca0944a929688":["96ecd141e96e7a7a65822d7fada5ddc585b21149"]},"commit2Childs":{"96ecd141e96e7a7a65822d7fada5ddc585b21149":["e98520789adb1d5ad05afb4956eca0944a929688"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["96ecd141e96e7a7a65822d7fada5ddc585b21149"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"e98520789adb1d5ad05afb4956eca0944a929688":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}