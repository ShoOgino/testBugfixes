{"path":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ab99e8c71442b92c320e218141dee04a9b91ce8","date":1269203801,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7f8e68717c68517265937c911e1ce9f25750247","date":1274071103,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new WhitespaceAnalyzer(TEST_VERSION_CURRENT)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"163fe85a71d778fd2b7747f65ca27b54829e2e57","date":1279898785,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b103252dee6afa1b6d7a622c773d178788eb85a","date":1280180143,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3242a09f703274d3b9283f2064a1a33064b53a1b","date":1280263474,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8dc26bfa5ebbc55b5a04fbec545dfcec647b046b","date":1280297653,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b21422ff1d1d56499dec481f193b402e5e8def5b","date":1281472367,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(random,\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c","date":1281646583,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = newDirectory(random);\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(random,\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(random,\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a05409176bd65129d67a785ee70e881e238a9aef","date":1282582843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory(random);\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(random,\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = newDirectory(random);\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(random,\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1f653cfcf159baeaafe5d01682a911e95bba4012","date":1284122058,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory(random);\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(random,\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["d19974432be9aed28ee7dca73bdf01d139e763a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"132903c28af3aa6f67284b78de91c0f0a99488c2","date":1284282129,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f3c3298e3b8617605888ca94ac7fd2d168bd098d","date":1292263235,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2888aa4df16d409b75b6c6dade16ed119e3ddbce","date":1292267123,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n    lmp.setUseCompoundDocStore(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockRAMDirectory.Failure failure = new MockRAMDirectory.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        @Override\n        public MockRAMDirectory.Failure reset() {\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockRAMDirectory dir)  throws IOException {\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockRAMDirectory dir = new MockRAMDirectory();\n    IndexWriter modifier = new IndexWriter(dir, new IndexWriterConfig(\n        TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2));\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(new Field(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(new Field(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(new Field(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(new Field(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    modifier.optimize();\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // in the !ac case, a new segments file won't be created but in\n    // this case, creation of the cfs file happens next so we need\n    // the doc (to test that it's okay that we don't lose deletes if\n    // failing while creating the cfs file)\n\n    boolean failed = false;\n    try {\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2c5f0cb44df114db4228c8f77861714b5cabaea","date":1302542431,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962d04139994fce5193143ef35615499a9a96d78","date":1302693744,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n    \n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1509f151d7692d84fae414b2b799ac06ba60fcb4","date":1314451621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], Field.Store.YES,\n                        Field.Index.NOT_ANALYZED));\n      doc.add(newField(\"country\", unindexed[i], Field.Store.YES,\n                        Field.Index.NO));\n      doc.add(newField(\"contents\", unstored[i], Field.Store.NO,\n                        Field.Index.ANALYZED));\n      doc.add(newField(\"city\", text[i], Field.Store.YES,\n                        Field.Index.ANALYZED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":["04f07771a2a7dd3a395700665ed839c3dae2def2"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n    modifier.setInfoStream(VERBOSE ? System.out : null);\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d14e8d18c0e3970c20354dbeeb49da11bd587fbd","date":1321041051,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now optimize\");\n    }\n\n    modifier.optimize();\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","pathOld":"lucene/src/test/org/apache/lucene/index/TestIndexWriterDelete#testErrorAfterApplyDeletes().mjava","sourceNew":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","sourceOld":"  // This test tests that buffered deletes are cleared when\n  // an Exception is hit during flush.\n  public void testErrorAfterApplyDeletes() throws IOException {\n\n    MockDirectoryWrapper.Failure failure = new MockDirectoryWrapper.Failure() {\n        boolean sawMaybe = false;\n        boolean failed = false;\n        Thread thread;\n        @Override\n        public MockDirectoryWrapper.Failure reset() {\n          thread = Thread.currentThread();\n          sawMaybe = false;\n          failed = false;\n          return this;\n        }\n        @Override\n        public void eval(MockDirectoryWrapper dir)  throws IOException {\n          if (Thread.currentThread() != thread) {\n            // don't fail during merging\n            return;\n          }\n          if (sawMaybe && !failed) {\n            boolean seen = false;\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                seen = true;\n                break;\n              }\n            }\n            if (!seen) {\n              // Only fail once we are no longer in applyDeletes\n              failed = true;\n              if (VERBOSE) {\n                System.out.println(\"TEST: mock failure: now fail\");\n                new Throwable().printStackTrace(System.out);\n              }\n              throw new IOException(\"fail after applyDeletes\");\n            }\n          }\n          if (!failed) {\n            StackTraceElement[] trace = new Exception().getStackTrace();\n            for (int i = 0; i < trace.length; i++) {\n              if (\"applyDeletes\".equals(trace[i].getMethodName())) {\n                if (VERBOSE) {\n                  System.out.println(\"TEST: mock failure: saw applyDeletes\");\n                  new Throwable().printStackTrace(System.out);\n                }\n                sawMaybe = true;\n                break;\n              }\n            }\n          }\n        }\n      };\n\n    // create a couple of files\n\n    String[] keywords = { \"1\", \"2\" };\n    String[] unindexed = { \"Netherlands\", \"Italy\" };\n    String[] unstored = { \"Amsterdam has lots of bridges\",\n        \"Venice has lots of canals\" };\n    String[] text = { \"Amsterdam\", \"Venice\" };\n\n    MockDirectoryWrapper dir = newDirectory();\n    IndexWriter modifier = new IndexWriter(dir, newIndexWriterConfig(\n                                                                     TEST_VERSION_CURRENT, new MockAnalyzer(random, MockTokenizer.WHITESPACE, false)).setMaxBufferedDeleteTerms(2).setReaderPooling(false).setMergePolicy(newLogMergePolicy()));\n\n    LogMergePolicy lmp = (LogMergePolicy) modifier.getConfig().getMergePolicy();\n    lmp.setUseCompoundFile(true);\n\n    dir.failOn(failure.reset());\n\n    FieldType custom1 = new FieldType();\n    custom1.setStored(true);\n    for (int i = 0; i < keywords.length; i++) {\n      Document doc = new Document();\n      doc.add(newField(\"id\", keywords[i], StringField.TYPE_STORED));\n      doc.add(newField(\"country\", unindexed[i], custom1));\n      doc.add(newField(\"contents\", unstored[i], TextField.TYPE_UNSTORED));\n      doc.add(newField(\"city\", text[i], TextField.TYPE_STORED));\n      modifier.addDocument(doc);\n    }\n    // flush (and commit if ac)\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: now full merge\");\n    }\n\n    modifier.forceMerge(1);\n    if (VERBOSE) {\n      System.out.println(\"TEST: now commit\");\n    }\n    modifier.commit();\n\n    // one of the two files hits\n\n    Term term = new Term(\"city\", \"Amsterdam\");\n    int hitCount = getHitCount(dir, term);\n    assertEquals(1, hitCount);\n\n    // open the writer again (closed above)\n\n    // delete the doc\n    // max buf del terms is two, so this is buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: delete term=\" + term);\n    }\n\n    modifier.deleteDocuments(term);\n\n    // add a doc (needed for the !ac case; see below)\n    // doc remains buffered\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: add empty doc\");\n    }\n    Document doc = new Document();\n    modifier.addDocument(doc);\n\n    // commit the changes, the buffered deletes, and the new doc\n\n    // The failure object will fail on the first write after the del\n    // file gets created when processing the buffered delete\n\n    // in the ac case, this will be when writing the new segments\n    // files so we really don't need the new doc, but it's harmless\n\n    // a new segments file won't be created but in this\n    // case, creation of the cfs file happens next so we\n    // need the doc (to test that it's okay that we don't\n    // lose deletes if failing while creating the cfs file)\n    boolean failed = false;\n    try {\n      if (VERBOSE) {\n        System.out.println(\"TEST: now commit for failure\");\n      }\n      modifier.commit();\n    } catch (IOException ioe) {\n      // expected\n      failed = true;\n    }\n\n    assertTrue(failed);\n\n    // The commit above failed, so we need to retry it (which will\n    // succeed, because the failure is a one-shot)\n\n    modifier.commit();\n\n    hitCount = getHitCount(dir, term);\n\n    // Make sure the delete was successfully flushed:\n    assertEquals(0, hitCount);\n\n    modifier.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["06584e6e98d592b34e1329b384182f368d2025e8"],"132903c28af3aa6f67284b78de91c0f0a99488c2":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"c7f8e68717c68517265937c911e1ce9f25750247":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["8dc26bfa5ebbc55b5a04fbec545dfcec647b046b","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"c19f985e36a65cc969e8e564fe337a0d41512075":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["c19f985e36a65cc969e8e564fe337a0d41512075"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["a05409176bd65129d67a785ee70e881e238a9aef"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","c19f985e36a65cc969e8e564fe337a0d41512075"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a05409176bd65129d67a785ee70e881e238a9aef":["ab9633cb67e3c0aec3c066147a23a957d6e7ad8c"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["2888aa4df16d409b75b6c6dade16ed119e3ddbce"],"b21422ff1d1d56499dec481f193b402e5e8def5b":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c19f985e36a65cc969e8e564fe337a0d41512075"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f3c3298e3b8617605888ca94ac7fd2d168bd098d":["132903c28af3aa6f67284b78de91c0f0a99488c2"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["c7f8e68717c68517265937c911e1ce9f25750247","4b103252dee6afa1b6d7a622c773d178788eb85a"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["c7f8e68717c68517265937c911e1ce9f25750247","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["c7f8e68717c68517265937c911e1ce9f25750247"],"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c":["b21422ff1d1d56499dec481f193b402e5e8def5b"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"06584e6e98d592b34e1329b384182f368d2025e8":["1509f151d7692d84fae414b2b799ac06ba60fcb4"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["29ef99d61cda9641b6250bf9567329a6e65f901d","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["f2c5f0cb44df114db4228c8f77861714b5cabaea","962d04139994fce5193143ef35615499a9a96d78"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["132903c28af3aa6f67284b78de91c0f0a99488c2","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"962d04139994fce5193143ef35615499a9a96d78":["bde51b089eb7f86171eb3406e38a274743f9b7ac","f2c5f0cb44df114db4228c8f77861714b5cabaea"],"8dc26bfa5ebbc55b5a04fbec545dfcec647b046b":["3242a09f703274d3b9283f2064a1a33064b53a1b"],"2888aa4df16d409b75b6c6dade16ed119e3ddbce":["f3c3298e3b8617605888ca94ac7fd2d168bd098d"],"a3776dccca01c11e7046323cfad46a3b4a471233":["c19f985e36a65cc969e8e564fe337a0d41512075","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d14e8d18c0e3970c20354dbeeb49da11bd587fbd":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"132903c28af3aa6f67284b78de91c0f0a99488c2":["f3c3298e3b8617605888ca94ac7fd2d168bd098d","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"c7f8e68717c68517265937c911e1ce9f25750247":["3242a09f703274d3b9283f2064a1a33064b53a1b","4b103252dee6afa1b6d7a622c773d178788eb85a","163fe85a71d778fd2b7747f65ca27b54829e2e57"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c19f985e36a65cc969e8e564fe337a0d41512075":["f2c5f0cb44df114db4228c8f77861714b5cabaea","29ef99d61cda9641b6250bf9567329a6e65f901d","bde51b089eb7f86171eb3406e38a274743f9b7ac","a3776dccca01c11e7046323cfad46a3b4a471233"],"f2c5f0cb44df114db4228c8f77861714b5cabaea":["b3e06be49006ecac364d39d12b9c9f74882f9b9f","962d04139994fce5193143ef35615499a9a96d78"],"1f653cfcf159baeaafe5d01682a911e95bba4012":["132903c28af3aa6f67284b78de91c0f0a99488c2"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a05409176bd65129d67a785ee70e881e238a9aef":["1f653cfcf159baeaafe5d01682a911e95bba4012"],"1509f151d7692d84fae414b2b799ac06ba60fcb4":["06584e6e98d592b34e1329b384182f368d2025e8"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c19f985e36a65cc969e8e564fe337a0d41512075","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"b21422ff1d1d56499dec481f193b402e5e8def5b":["ab9633cb67e3c0aec3c066147a23a957d6e7ad8c"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["962d04139994fce5193143ef35615499a9a96d78"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"f3c3298e3b8617605888ca94ac7fd2d168bd098d":["2888aa4df16d409b75b6c6dade16ed119e3ddbce"],"3242a09f703274d3b9283f2064a1a33064b53a1b":["8dc26bfa5ebbc55b5a04fbec545dfcec647b046b"],"4b103252dee6afa1b6d7a622c773d178788eb85a":["b21422ff1d1d56499dec481f193b402e5e8def5b","3242a09f703274d3b9283f2064a1a33064b53a1b"],"163fe85a71d778fd2b7747f65ca27b54829e2e57":["4b103252dee6afa1b6d7a622c773d178788eb85a"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["c7f8e68717c68517265937c911e1ce9f25750247"],"ab9633cb67e3c0aec3c066147a23a957d6e7ad8c":["a05409176bd65129d67a785ee70e881e238a9aef"],"06584e6e98d592b34e1329b384182f368d2025e8":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":[],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["1509f151d7692d84fae414b2b799ac06ba60fcb4","135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233"],"962d04139994fce5193143ef35615499a9a96d78":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"8dc26bfa5ebbc55b5a04fbec545dfcec647b046b":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2888aa4df16d409b75b6c6dade16ed119e3ddbce":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["135621f3a0670a9394eb563224a3b76cc4dddc0f","a3776dccca01c11e7046323cfad46a3b4a471233","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}