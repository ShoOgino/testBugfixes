{"path":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":null,"sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"/dev/null","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"28427ef110c4c5bf5b4057731b83110bd1e13724","date":1276701452,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n\n    BytesRef lastVal=new BytesRef(\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\");\n    BytesRef internalKey = new BytesRef();\n    BytesRef prevKey=new BytesRef();\n    BytesRef tmp;\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n      BytesRef t = termsEnum.next();\n      if (t==null) t=lastVal;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        tmp = prevKey; prevKey=internalKey; internalKey=tmp;\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(t);\n              if (cmp == 0) {\n                docsEnum = termsEnum.docs(delDocs, docsEnum);\n                int doc;\n                while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n                  vals[doc] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termsEnum.seek(internalKey);\n                  t = termsEnum.term();\n                } else {\n                  t = termsEnum.next();\n                }\n\n                if (t==null) t = lastVal;\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          TermsEnum.SeekStatus result = termsEnum.seek(internalKey);\n          t = termsEnum.term();\n          if (result == TermsEnum.SeekStatus.FOUND) {\n            docsEnum = termsEnum.docs(delDocs, docsEnum);\n            int doc;\n            while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n              vals[doc] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":["543e59b1fc2ac58a49da34c2e0df3351a111d9c8","543e59b1fc2ac58a49da34c2e0df3351a111d9c8","543e59b1fc2ac58a49da34c2e0df3351a111d9c8","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n\n    BytesRef lastVal=new BytesRef(\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\");\n    BytesRef internalKey = new BytesRef();\n    BytesRef prevKey=new BytesRef();\n    BytesRef tmp;\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n      BytesRef t = termsEnum.next();\n      if (t==null) t=lastVal;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        tmp = prevKey; prevKey=internalKey; internalKey=tmp;\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(t);\n              if (cmp == 0) {\n                docsEnum = termsEnum.docs(delDocs, docsEnum);\n                int doc;\n                while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n                  vals[doc] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termsEnum.seek(internalKey);\n                  t = termsEnum.term();\n                } else {\n                  t = termsEnum.next();\n                }\n\n                if (t==null) t = lastVal;\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          TermsEnum.SeekStatus result = termsEnum.seek(internalKey);\n          t = termsEnum.term();\n          if (result == TermsEnum.SeekStatus.FOUND) {\n            docsEnum = termsEnum.docs(delDocs, docsEnum);\n            int doc;\n            while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n              vals[doc] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    TermDocs termDocs = null;\n    Term protoTerm = new Term(idName, \"\");\n    TermEnum termEnum = null;\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n    String termVal;\n    boolean hasNext=true;\n    String prevKey=\"\";\n\n    String lastVal=\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\";\n\n    try {\n      termDocs = reader.termDocs();\n      termEnum = reader.terms(protoTerm);\n      Term t = termEnum.term();\n      if (t != null && t.field() == idName) { // intern'd comparison\n        termVal = t.text();\n      } else {\n        termVal = lastVal;\n      }\n\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        String internalKey = idType.toInternal(key);\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n          prevKey = internalKey;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(termVal);\n              if (cmp == 0) {\n                termDocs.seek(termEnum);\n                while (termDocs.next()) {\n                  vals[termDocs.doc()] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termEnum = reader.terms(protoTerm.createTerm(internalKey));\n                  t = termEnum.term();\n                } else {\n                  hasNext = termEnum.next();\n                  t = hasNext ? termEnum.term() : null;\n                }\n\n                if (t != null && t.field() == idName) { // intern'd comparison\n                  termVal = t.text();\n                } else {\n                  termVal = lastVal;\n                }\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          termEnum = reader.terms(protoTerm.createTerm(internalKey));\n          t = termEnum.term();\n          if (t != null && t.field() == idName  // intern'd comparison\n                  && internalKey.equals(t.text()))\n          {\n            termDocs.seek (termEnum);\n            while (termDocs.next()) {\n              vals[termDocs.doc()] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      if (termDocs!=null) try{termDocs.close();}catch(Exception e){}\n      if (termEnum!=null) try{termEnum.close();}catch(Exception e){}\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0408cdc9ecbf9f0679cbe5ace530dd40289bf849","date":1281476179,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n\n    BytesRef lastVal=new BytesRef(\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\");\n    BytesRef internalKey = new BytesRef();\n    BytesRef prevKey=new BytesRef();\n    BytesRef tmp;\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n      BytesRef t = termsEnum.next();\n      if (t==null) t=lastVal;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        tmp = prevKey; prevKey=internalKey; internalKey=tmp;\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(t);\n              if (cmp == 0) {\n                docsEnum = termsEnum.docs(delDocs, docsEnum);\n                int doc;\n                while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n                  vals[doc] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termsEnum.seek(internalKey);\n                  t = termsEnum.term();\n                } else {\n                  t = termsEnum.next();\n                }\n\n                if (t==null) t = lastVal;\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          TermsEnum.SeekStatus result = termsEnum.seek(internalKey);\n          t = termsEnum.term();\n          if (result == TermsEnum.SeekStatus.FOUND) {\n            docsEnum = termsEnum.docs(delDocs, docsEnum);\n            int doc;\n            while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n              vals[doc] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n    boolean sorted=true;   // assume sorted until we discover it's not\n\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    // Number of times to try termEnum.next() before resorting to skip\n    int numTimesNext = 10;\n\n    char delimiter='=';\n\n    BytesRef lastVal=new BytesRef(\"\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\\uFFFF\");\n    BytesRef internalKey = new BytesRef();\n    BytesRef prevKey=new BytesRef();\n    BytesRef tmp;\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n      BytesRef t = termsEnum.next();\n      if (t==null) t=lastVal;\n      final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        /* EOLs should already be removed for BufferedReader.readLine()\n        for(int endIndex = line.length();endIndex>delimIndex+1; endIndex--) {\n          char ch = line.charAt(endIndex-1);\n          if (ch!='\\n' && ch!='\\r') break;\n        }\n        */\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        tmp = prevKey; prevKey=internalKey; internalKey=tmp;\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")                    \n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (sorted) {\n          // make sure this key is greater than the previous key\n          sorted = internalKey.compareTo(prevKey) >= 0;\n\n          if (sorted) {\n            int countNext = 0;\n            for(;;) {\n              int cmp = internalKey.compareTo(t);\n              if (cmp == 0) {\n                docsEnum = termsEnum.docs(delDocs, docsEnum);\n                int doc;\n                while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n                  vals[doc] = fval;\n                }\n                break;\n              } else if (cmp < 0) {\n                // term enum has already advanced past current key... we didn't find it.\n                if (notFoundCount<10) {  // collect first 10 not found for logging\n                  notFound.add(key);\n                }\n                notFoundCount++;\n                break;\n              } else {\n                // termEnum is less than our current key, so skip ahead\n\n                // try next() a few times to see if we hit or pass the target.\n                // Lucene's termEnum.skipTo() is currently unoptimized (it just does next())\n                // so the best thing is to simply ask the reader for a new termEnum(target)\n                // if we really need to skip.\n                if (++countNext > numTimesNext) {\n                  termsEnum.seek(internalKey);\n                  t = termsEnum.term();\n                } else {\n                  t = termsEnum.next();\n                }\n\n                if (t==null) t = lastVal;\n              }\n            } // end for(;;)\n          }\n        }\n\n        if (!sorted) {\n          TermsEnum.SeekStatus result = termsEnum.seek(internalKey);\n          t = termsEnum.term();\n          if (result == TermsEnum.SeekStatus.FOUND) {\n            docsEnum = termsEnum.docs(delDocs, docsEnum);\n            int doc;\n            while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n              vals[doc] = fval;\n            }\n          } else {\n            if (notFoundCount<10) {  // collect first 10 not found for logging\n              notFound.add(key);\n            }\n            notFoundCount++;\n          }\n        }\n      }\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","date":1308670974,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd9cc9d77712aba3662f24632df7539ab75e3667","date":1309095238,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","date":1309960478,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = StringHelper.intern(ffs.keyField.getName());\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits delDocs = MultiFields.getDeletedDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (termsEnum.seek(internalKey, false) != TermsEnum.SeekStatus.FOUND) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","pathOld":"solr/src/java/org/apache/solr/search/function/FileFloatSource#getFloats(FileFloatSource,IndexReader).mjava","sourceNew":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","sourceOld":"  private static float[] getFloats(FileFloatSource ffs, IndexReader reader) {\n    float[] vals = new float[reader.maxDoc()];\n    if (ffs.defVal != 0) {\n      Arrays.fill(vals, ffs.defVal);\n    }\n    InputStream is;\n    String fname = \"external_\" + ffs.field.getName();\n    try {\n      is = VersionedFile.getLatestFile(ffs.dataDir, fname);\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error opening external value source file: \" +e);\n      return vals;\n    }\n\n    BufferedReader r = new BufferedReader(new InputStreamReader(is));\n\n    String idName = ffs.keyField.getName();\n    FieldType idType = ffs.keyField.getType();\n\n    // warning: lucene's termEnum.skipTo() is not optimized... it simply does a next()\n    // because of this, simply ask the reader for a new termEnum rather than\n    // trying to use skipTo()\n\n    List<String> notFound = new ArrayList<String>();\n    int notFoundCount=0;\n    int otherErrors=0;\n\n    char delimiter='=';\n\n    BytesRef internalKey = new BytesRef();\n\n    try {\n      TermsEnum termsEnum = MultiFields.getTerms(reader, idName).iterator();\n      DocsEnum docsEnum = null;\n\n      // removing deleted docs shouldn't matter\n      // final Bits liveDocs = MultiFields.getLiveDocs(reader);\n\n      for (String line; (line=r.readLine())!=null;) {\n        int delimIndex = line.indexOf(delimiter);\n        if (delimIndex < 0) continue;\n\n        int endIndex = line.length();\n        String key = line.substring(0, delimIndex);\n        String val = line.substring(delimIndex+1, endIndex);\n\n        idType.readableToIndexed(key, internalKey);\n\n        float fval;\n        try {\n          fval=Float.parseFloat(val);\n        } catch (Exception e) {\n          if (++otherErrors<=10) {\n            SolrCore.log.error( \"Error loading external value source + fileName + \" + e\n              + (otherErrors<10 ? \"\" : \"\\tSkipping future errors for this file.\")\n            );\n          }\n          continue;  // go to next line in file.. leave values as default.\n        }\n\n        if (!termsEnum.seekExact(internalKey, false)) {\n          if (notFoundCount<10) {  // collect first 10 not found for logging\n            notFound.add(key);\n          }\n          notFoundCount++;\n          continue;\n        }\n\n        docsEnum = termsEnum.docs(null, docsEnum);\n        int doc;\n        while ((doc = docsEnum.nextDoc()) != DocsEnum.NO_MORE_DOCS) {\n          vals[doc] = fval;\n        }\n      }\n\n    } catch (IOException e) {\n      // log, use defaults\n      SolrCore.log.error(\"Error loading external value source: \" +e);\n    } finally {\n      // swallow exceptions on close so we don't override any\n      // exceptions that happened in the loop\n      try{r.close();}catch(Exception e){}\n    }\n\n    SolrCore.log.info(\"Loaded external value source \" + fname\n      + (notFoundCount==0 ? \"\" : \" :\"+notFoundCount+\" missing keys \"+notFound)\n    );\n\n    return vals;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"0408cdc9ecbf9f0679cbe5ace530dd40289bf849":["28427ef110c4c5bf5b4057731b83110bd1e13724"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["0408cdc9ecbf9f0679cbe5ace530dd40289bf849"],"c26f00b574427b55127e869b935845554afde1fa":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"5f4e87790277826a2aea119328600dfb07761f32":["1da8d55113b689b06716246649de6f62430f15c0","28427ef110c4c5bf5b4057731b83110bd1e13724"],"2553b00f699380c64959ccb27991289aae87be2e":["0408cdc9ecbf9f0679cbe5ace530dd40289bf849","fd9cc9d77712aba3662f24632df7539ab75e3667"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","0408cdc9ecbf9f0679cbe5ace530dd40289bf849"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["0408cdc9ecbf9f0679cbe5ace530dd40289bf849","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["2553b00f699380c64959ccb27991289aae87be2e","e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"28427ef110c4c5bf5b4057731b83110bd1e13724":["1da8d55113b689b06716246649de6f62430f15c0"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"0408cdc9ecbf9f0679cbe5ace530dd40289bf849":["fafef7c83fe8e0b3ca9298d5d75d6b943dc28153","2553b00f699380c64959ccb27991289aae87be2e","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"fafef7c83fe8e0b3ca9298d5d75d6b943dc28153":["fd9cc9d77712aba3662f24632df7539ab75e3667"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e7bd246bb7bc35ac22edfee9157e034dfc4e65eb":["c26f00b574427b55127e869b935845554afde1fa","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","a258fbb26824fd104ed795e5d9033d2d040049ee"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2553b00f699380c64959ccb27991289aae87be2e":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":[],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"1da8d55113b689b06716246649de6f62430f15c0":["5f4e87790277826a2aea119328600dfb07761f32","28427ef110c4c5bf5b4057731b83110bd1e13724"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"28427ef110c4c5bf5b4057731b83110bd1e13724":["0408cdc9ecbf9f0679cbe5ace530dd40289bf849","5f4e87790277826a2aea119328600dfb07761f32"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"fd9cc9d77712aba3662f24632df7539ab75e3667":["e7bd246bb7bc35ac22edfee9157e034dfc4e65eb","2553b00f699380c64959ccb27991289aae87be2e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}