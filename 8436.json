{"path":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","commits":[{"id":"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753","date":1416999434,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","pathOld":"/dev/null","sourceNew":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n          @Override\n          public void warm(LeafReader reader) throws IOException {\n            // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n            // newly flushed segments:\n            if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n            // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n            // building the parallel index, if necessary\n            getParallelLeafReader(reader, false, getCurrentSchemaGen());\n          }\n        });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w, true)));\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6450c8e5ae2fc3df8d5de3bce074cb72847ae23","date":1417512615,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","sourceNew":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      if (DEBUG) {\n        System.out.println(\"TEST: use IWC:\\n\" + iwc);\n      }\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n          @Override\n          public void warm(LeafReader reader) throws IOException {\n            // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n            // newly flushed segments:\n            if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n            // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n            // building the parallel index, if necessary\n            getParallelLeafReader(reader, false, getCurrentSchemaGen());\n          }\n        });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w, true)));\n    }\n\n","sourceOld":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n          @Override\n          public void warm(LeafReader reader) throws IOException {\n            // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n            // newly flushed segments:\n            if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n            // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n            // building the parallel index, if necessary\n            getParallelLeafReader(reader, false, getCurrentSchemaGen());\n          }\n        });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w, true)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","sourceNew":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      if (DEBUG) {\n        System.out.println(\"TEST: use IWC:\\n\" + iwc);\n      }\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n          @Override\n          public void warm(LeafReader reader) throws IOException {\n            // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n            // newly flushed segments:\n            if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n            // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n            // building the parallel index, if necessary\n            getParallelLeafReader(reader, false, getCurrentSchemaGen());\n          }\n        });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w)));\n    }\n\n","sourceOld":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      if (DEBUG) {\n        System.out.println(\"TEST: use IWC:\\n\" + iwc);\n      }\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n          @Override\n          public void warm(LeafReader reader) throws IOException {\n            // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n            // newly flushed segments:\n            if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n            // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n            // building the parallel index, if necessary\n            getParallelLeafReader(reader, false, getCurrentSchemaGen());\n          }\n        });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w, true)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dcdf0501ecb64dde73646fe1f7533c1586deac1","date":1507107556,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestDemoParallelLeafReader.ReindexingReader#ReindexingReader(Path).mjava","sourceNew":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      if (DEBUG) {\n        System.out.println(\"TEST: use IWC:\\n\" + iwc);\n      }\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer((reader) -> {\n        // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n        // newly flushed segments:\n        if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n        // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n        // building the parallel index, if necessary\n        getParallelLeafReader(reader, false, getCurrentSchemaGen());\n      });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w)));\n    }\n\n","sourceOld":"    public ReindexingReader(Path root) throws IOException {\n      this.root = root;\n\n      // Normal index is stored under \"index\":\n      indexDir = openDirectory(root.resolve(\"index\"));\n\n      // Per-segment parallel indices are stored under subdirs \"segs\":\n      segsPath = root.resolve(\"segs\");\n      Files.createDirectories(segsPath);\n\n      IndexWriterConfig iwc = getIndexWriterConfig();\n      iwc.setMergePolicy(new ReindexingMergePolicy(iwc.getMergePolicy()));\n      if (DEBUG) {\n        System.out.println(\"TEST: use IWC:\\n\" + iwc);\n      }\n      w = new IndexWriter(indexDir, iwc);\n\n      w.getConfig().setMergedSegmentWarmer(new IndexWriter.IndexReaderWarmer() {\n          @Override\n          public void warm(LeafReader reader) throws IOException {\n            // This will build the parallel index for the merged segment before the merge becomes visible, so reopen delay is only due to\n            // newly flushed segments:\n            if (DEBUG) System.out.println(Thread.currentThread().getName() +\": TEST: now warm \" + reader);\n            // TODO: it's not great that we pass false here; it means we close the reader & reopen again for NRT reader; still we did \"warm\" by\n            // building the parallel index, if necessary\n            getParallelLeafReader(reader, false, getCurrentSchemaGen());\n          }\n        });\n\n      // start with empty commit:\n      w.commit();\n      mgr = new ReaderManager(new ParallelLeafDirectoryReader(DirectoryReader.open(w)));\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3dcdf0501ecb64dde73646fe1f7533c1586deac1":["2a1862266772deb28cdcb7d996b64d2177022687"],"2a1862266772deb28cdcb7d996b64d2177022687":["f6450c8e5ae2fc3df8d5de3bce074cb72847ae23"],"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f6450c8e5ae2fc3df8d5de3bce074cb72847ae23":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3dcdf0501ecb64dde73646fe1f7533c1586deac1"]},"commit2Childs":{"3dcdf0501ecb64dde73646fe1f7533c1586deac1":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2a1862266772deb28cdcb7d996b64d2177022687":["3dcdf0501ecb64dde73646fe1f7533c1586deac1"],"4d9aa91d3fdd25528bac3b2e6115d54fc2f28753":["f6450c8e5ae2fc3df8d5de3bce074cb72847ae23"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d9aa91d3fdd25528bac3b2e6115d54fc2f28753"],"f6450c8e5ae2fc3df8d5de3bce074cb72847ae23":["2a1862266772deb28cdcb7d996b64d2177022687"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}