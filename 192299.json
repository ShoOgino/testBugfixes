{"path":"lucene/test-framework/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","commits":[{"id":"b52491e71f0d5d0f0160d6ed0d39e0dd661be68a","date":1429550638,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","sourceNew":"    private void fillTokens() throws IOException {\n      final StringBuilder sb = new StringBuilder();\n      final char[] buffer = new char[256];\n      while (true) {\n        final int count = input.read(buffer);\n        if (count == -1) {\n          break;\n        }\n        sb.append(buffer, 0, count);\n        //System.out.println(\"got count=\" + count);\n      }\n      //System.out.println(\"fillTokens: \" + sb);\n\n      inputLength = sb.length();\n\n      final String[] parts = sb.toString().split(\" \");\n\n      tokens = new ArrayList<>();\n      int pos = 0;\n      int maxPos = -1;\n      int offset = 0;\n      //System.out.println(\"again\");\n      for(String part : parts) {\n        final String[] overlapped = part.split(\"/\");\n        boolean firstAtPos = true;\n        int minPosLength = Integer.MAX_VALUE;\n        for(String part2 : overlapped) {\n          final int colonIndex = part2.indexOf(':');\n          final String token;\n          final int posLength;\n          if (colonIndex != -1) {\n            token = part2.substring(0, colonIndex);\n            posLength = Integer.parseInt(part2.substring(1+colonIndex));\n          } else {\n            token = part2;\n            posLength = 1;\n          }\n          maxPos = Math.max(maxPos, pos + posLength);\n          minPosLength = Math.min(minPosLength, posLength);\n          final Token t = new Token(token, offset, offset + 2*posLength - 1);\n          t.setPositionLength(posLength);\n          t.setPositionIncrement(firstAtPos ? 1:0);\n          firstAtPos = false;\n          //System.out.println(\"  add token=\" + t + \" startOff=\" + t.startOffset() + \" endOff=\" + t.endOffset());\n          tokens.add(t);\n        }\n        pos += minPosLength;\n        offset = 2 * pos;\n      }\n      assert maxPos <= pos: \"input string mal-formed: posLength>1 tokens hang over the end\";\n    }\n\n","sourceOld":"    private void fillTokens() throws IOException {\n      final StringBuilder sb = new StringBuilder();\n      final char[] buffer = new char[256];\n      while (true) {\n        final int count = input.read(buffer);\n        if (count == -1) {\n          break;\n        }\n        sb.append(buffer, 0, count);\n        //System.out.println(\"got count=\" + count);\n      }\n      //System.out.println(\"fillTokens: \" + sb);\n\n      inputLength = sb.length();\n\n      final String[] parts = sb.toString().split(\" \");\n\n      tokens = new ArrayList<>();\n      int pos = 0;\n      int maxPos = -1;\n      int offset = 0;\n      //System.out.println(\"again\");\n      for(String part : parts) {\n        final String[] overlapped = part.split(\"/\");\n        boolean firstAtPos = true;\n        int minPosLength = Integer.MAX_VALUE;\n        for(String part2 : overlapped) {\n          final int colonIndex = part2.indexOf(':');\n          final String token;\n          final int posLength;\n          if (colonIndex != -1) {\n            token = part2.substring(0, colonIndex);\n            posLength = Integer.parseInt(part2.substring(1+colonIndex));\n          } else {\n            token = part2;\n            posLength = 1;\n          }\n          maxPos = Math.max(maxPos, pos + posLength);\n          minPosLength = Math.min(minPosLength, posLength);\n          final Token t = new Token(token, offset, offset + 2*posLength - 1);\n          t.setPositionLength(posLength);\n          t.setPositionIncrement(firstAtPos ? 1:0);\n          firstAtPos = false;\n          //System.out.println(\"  add token=\" + t + \" startOff=\" + t.startOffset() + \" endOff=\" + t.endOffset());\n          tokens.add(t);\n        }\n        pos += minPosLength;\n        offset = 2 * pos;\n      }\n      assert maxPos <= pos: \"input string mal-formed: posLength>1 tokens hang over the end\";\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"085e5eccb1e06e3bfb487813880adc54c888dd02","date":1483875517,"type":5,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","pathOld":"lucene/test-framework/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","sourceNew":"    private void fillTokens() throws IOException {\n      final StringBuilder sb = new StringBuilder();\n      final char[] buffer = new char[256];\n      while (true) {\n        final int count = input.read(buffer);\n        if (count == -1) {\n          break;\n        }\n        sb.append(buffer, 0, count);\n        //System.out.println(\"got count=\" + count);\n      }\n      //System.out.println(\"fillTokens: \" + sb);\n\n      inputLength = sb.length();\n\n      final String[] parts = sb.toString().split(\" \");\n\n      tokens = new ArrayList<>();\n      int pos = 0;\n      int maxPos = -1;\n      int offset = 0;\n      //System.out.println(\"again\");\n      for(String part : parts) {\n        final String[] overlapped = part.split(\"/\");\n        boolean firstAtPos = true;\n        int minPosLength = Integer.MAX_VALUE;\n        for(String part2 : overlapped) {\n          final int colonIndex = part2.indexOf(':');\n          final String token;\n          final int posLength;\n          if (colonIndex != -1) {\n            token = part2.substring(0, colonIndex);\n            posLength = Integer.parseInt(part2.substring(1+colonIndex));\n          } else {\n            token = part2;\n            posLength = 1;\n          }\n          maxPos = Math.max(maxPos, pos + posLength);\n          minPosLength = Math.min(minPosLength, posLength);\n          final Token t = new Token(token, offset, offset + 2*posLength - 1);\n          t.setPositionLength(posLength);\n          t.setPositionIncrement(firstAtPos ? 1:0);\n          firstAtPos = false;\n          //System.out.println(\"  add token=\" + t + \" startOff=\" + t.startOffset() + \" endOff=\" + t.endOffset());\n          tokens.add(t);\n        }\n        pos += minPosLength;\n        offset = 2 * pos;\n      }\n      assert maxPos <= pos: \"input string mal-formed: posLength>1 tokens hang over the end\";\n    }\n\n","sourceOld":"    private void fillTokens() throws IOException {\n      final StringBuilder sb = new StringBuilder();\n      final char[] buffer = new char[256];\n      while (true) {\n        final int count = input.read(buffer);\n        if (count == -1) {\n          break;\n        }\n        sb.append(buffer, 0, count);\n        //System.out.println(\"got count=\" + count);\n      }\n      //System.out.println(\"fillTokens: \" + sb);\n\n      inputLength = sb.length();\n\n      final String[] parts = sb.toString().split(\" \");\n\n      tokens = new ArrayList<>();\n      int pos = 0;\n      int maxPos = -1;\n      int offset = 0;\n      //System.out.println(\"again\");\n      for(String part : parts) {\n        final String[] overlapped = part.split(\"/\");\n        boolean firstAtPos = true;\n        int minPosLength = Integer.MAX_VALUE;\n        for(String part2 : overlapped) {\n          final int colonIndex = part2.indexOf(':');\n          final String token;\n          final int posLength;\n          if (colonIndex != -1) {\n            token = part2.substring(0, colonIndex);\n            posLength = Integer.parseInt(part2.substring(1+colonIndex));\n          } else {\n            token = part2;\n            posLength = 1;\n          }\n          maxPos = Math.max(maxPos, pos + posLength);\n          minPosLength = Math.min(minPosLength, posLength);\n          final Token t = new Token(token, offset, offset + 2*posLength - 1);\n          t.setPositionLength(posLength);\n          t.setPositionIncrement(firstAtPos ? 1:0);\n          firstAtPos = false;\n          //System.out.println(\"  add token=\" + t + \" startOff=\" + t.startOffset() + \" endOff=\" + t.endOffset());\n          tokens.add(t);\n        }\n        pos += minPosLength;\n        offset = 2 * pos;\n      }\n      assert maxPos <= pos: \"input string mal-formed: posLength>1 tokens hang over the end\";\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","date":1484239864,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","pathOld":"lucene/test-framework/src/test/org/apache/lucene/analysis/TestGraphTokenizers.GraphTokenizer#fillTokens().mjava","sourceNew":"    private void fillTokens() throws IOException {\n      final StringBuilder sb = new StringBuilder();\n      final char[] buffer = new char[256];\n      while (true) {\n        final int count = input.read(buffer);\n        if (count == -1) {\n          break;\n        }\n        sb.append(buffer, 0, count);\n        //System.out.println(\"got count=\" + count);\n      }\n      //System.out.println(\"fillTokens: \" + sb);\n\n      inputLength = sb.length();\n\n      final String[] parts = sb.toString().split(\" \");\n\n      tokens = new ArrayList<>();\n      int pos = 0;\n      int maxPos = -1;\n      int offset = 0;\n      //System.out.println(\"again\");\n      for(String part : parts) {\n        final String[] overlapped = part.split(\"/\");\n        boolean firstAtPos = true;\n        int minPosLength = Integer.MAX_VALUE;\n        for(String part2 : overlapped) {\n          final int colonIndex = part2.indexOf(':');\n          final String token;\n          final int posLength;\n          if (colonIndex != -1) {\n            token = part2.substring(0, colonIndex);\n            posLength = Integer.parseInt(part2.substring(1+colonIndex));\n          } else {\n            token = part2;\n            posLength = 1;\n          }\n          maxPos = Math.max(maxPos, pos + posLength);\n          minPosLength = Math.min(minPosLength, posLength);\n          final Token t = new Token(token, offset, offset + 2*posLength - 1);\n          t.setPositionLength(posLength);\n          t.setPositionIncrement(firstAtPos ? 1:0);\n          firstAtPos = false;\n          //System.out.println(\"  add token=\" + t + \" startOff=\" + t.startOffset() + \" endOff=\" + t.endOffset());\n          tokens.add(t);\n        }\n        pos += minPosLength;\n        offset = 2 * pos;\n      }\n      assert maxPos <= pos: \"input string mal-formed: posLength>1 tokens hang over the end\";\n    }\n\n","sourceOld":"    private void fillTokens() throws IOException {\n      final StringBuilder sb = new StringBuilder();\n      final char[] buffer = new char[256];\n      while (true) {\n        final int count = input.read(buffer);\n        if (count == -1) {\n          break;\n        }\n        sb.append(buffer, 0, count);\n        //System.out.println(\"got count=\" + count);\n      }\n      //System.out.println(\"fillTokens: \" + sb);\n\n      inputLength = sb.length();\n\n      final String[] parts = sb.toString().split(\" \");\n\n      tokens = new ArrayList<>();\n      int pos = 0;\n      int maxPos = -1;\n      int offset = 0;\n      //System.out.println(\"again\");\n      for(String part : parts) {\n        final String[] overlapped = part.split(\"/\");\n        boolean firstAtPos = true;\n        int minPosLength = Integer.MAX_VALUE;\n        for(String part2 : overlapped) {\n          final int colonIndex = part2.indexOf(':');\n          final String token;\n          final int posLength;\n          if (colonIndex != -1) {\n            token = part2.substring(0, colonIndex);\n            posLength = Integer.parseInt(part2.substring(1+colonIndex));\n          } else {\n            token = part2;\n            posLength = 1;\n          }\n          maxPos = Math.max(maxPos, pos + posLength);\n          minPosLength = Math.min(minPosLength, posLength);\n          final Token t = new Token(token, offset, offset + 2*posLength - 1);\n          t.setPositionLength(posLength);\n          t.setPositionIncrement(firstAtPos ? 1:0);\n          firstAtPos = false;\n          //System.out.println(\"  add token=\" + t + \" startOff=\" + t.startOffset() + \" endOff=\" + t.endOffset());\n          tokens.add(t);\n        }\n        pos += minPosLength;\n        offset = 2 * pos;\n      }\n      assert maxPos <= pos: \"input string mal-formed: posLength>1 tokens hang over the end\";\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":["b52491e71f0d5d0f0160d6ed0d39e0dd661be68a","085e5eccb1e06e3bfb487813880adc54c888dd02"],"b52491e71f0d5d0f0160d6ed0d39e0dd661be68a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"085e5eccb1e06e3bfb487813880adc54c888dd02":["b52491e71f0d5d0f0160d6ed0d39e0dd661be68a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["085e5eccb1e06e3bfb487813880adc54c888dd02"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b52491e71f0d5d0f0160d6ed0d39e0dd661be68a"],"09ab8ee44ca898536770d0106a7c0ee4be4f0eb7":[],"b52491e71f0d5d0f0160d6ed0d39e0dd661be68a":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","085e5eccb1e06e3bfb487813880adc54c888dd02"],"085e5eccb1e06e3bfb487813880adc54c888dd02":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["09ab8ee44ca898536770d0106a7c0ee4be4f0eb7","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}