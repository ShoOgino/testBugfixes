{"path":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","commits":[{"id":"99761ac3b0c4136140f9cd2d081b80934bba16fa","date":1456263279,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"/dev/null","sourceNew":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    // nocommit validate these:\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\", numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee299c4e4c019174aa433f564b5de03a7a40e00d","date":1456264115,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    // nocommit validate these:\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      // nocommit make sure a test tests this:\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\", numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    // nocommit validate these:\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\", numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e460f059c59ca6be827d6de9a0e26f526b9414c0","date":1456270863,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || bytesPerDim > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    // nocommit validate these:\n    this.bytesPerDim = bytesPerDim;\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      // nocommit make sure a test tests this:\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\", numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebfbe42b2dae57f9ac08706e76b0ab8bdf7011c8","date":1456349953,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      // nocommit detect out-of-order 1D case\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || bytesPerDim > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"375ee6573ef9849fb746b27e12fea91e8f7d77b9","date":1456351141,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** In the 1D case, the {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (numDims == 1 && cmp > 0) {\n          throw new IllegalArgumentException(\"numDims=1 and values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** {@code packedPoints} must already be sorted! */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      // nocommit detect out-of-order 1D case\n      } else if (previous.get().equals(current)) {\n        continue; // deduplicate\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9ccce763ea3c7e51eff749e584c061d8744b72d","date":1456395668,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** In the 1D case, the {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (numDims == 1 && cmp > 0) {\n          throw new IllegalArgumentException(\"numDims=1 and values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"868f63baffb79407d4b49f3c0be8dc4725ffc6e1","date":1456423715,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","pathOld":"/dev/null","sourceNew":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1800b996d8677670482a071dcb7a48b08c423ace","date":1456955558,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,Stream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c422e924212367b334b4938f1fd3e44438e88c40","date":1456962933,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,Stream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cf1a614098b46c9c22afebd7b898ae4d1d2fc273","date":1457088850,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,Stream).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/PointInSetQuery#PointInSetQuery(String,int,int,BytesRefIterator).mjava","sourceNew":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, Stream packedPoints) {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","sourceOld":"  /** The {@code packedPoints} iterator must be in sorted order. */\n  protected PointInSetQuery(String field, int numDims, int bytesPerDim, BytesRefIterator packedPoints) throws IOException {\n    this.field = field;\n    if (bytesPerDim < 1 || bytesPerDim > PointValues.MAX_NUM_BYTES) {\n      throw new IllegalArgumentException(\"bytesPerDim must be > 0 and <= \" + PointValues.MAX_NUM_BYTES + \"; got \" + bytesPerDim);\n    }\n    this.bytesPerDim = bytesPerDim;\n    if (numDims < 1 || numDims > PointValues.MAX_DIMENSIONS) {\n      throw new IllegalArgumentException(\"numDims must be > 0 and <= \" + PointValues.MAX_DIMENSIONS + \"; got \" + numDims);\n    }\n\n    this.numDims = numDims;\n\n    // In the 1D case this works well (the more points, the more common prefixes they share, typically), but in\n    // the > 1 D case, where we are only looking at the first dimension's prefix bytes, it can at worst not hurt:\n    PrefixCodedTerms.Builder builder = new PrefixCodedTerms.Builder();\n    BytesRefBuilder previous = null;\n    BytesRef current;\n    while ((current = packedPoints.next()) != null) {\n      if (current.length != numDims * bytesPerDim) {\n        throw new IllegalArgumentException(\"packed point length should be \" + (numDims * bytesPerDim) + \" but got \" + current.length + \"; field=\\\"\" + field + \"\\\" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim);\n      }\n      if (previous == null) {\n        previous = new BytesRefBuilder();\n      } else {\n        int cmp = previous.get().compareTo(current);\n        if (cmp == 0) {\n          continue; // deduplicate\n        } else if (cmp > 0) {\n          throw new IllegalArgumentException(\"values are out of order: saw \" + previous + \" before \" + current);\n        }\n      }\n      builder.add(field, current);\n      previous.copyBytes(current);\n    }\n    sortedPackedPoints = builder.finish();\n    sortedPackedPointsHashCode = sortedPackedPoints.hashCode();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"375ee6573ef9849fb746b27e12fea91e8f7d77b9":["ebfbe42b2dae57f9ac08706e76b0ab8bdf7011c8"],"ebfbe42b2dae57f9ac08706e76b0ab8bdf7011c8":["e460f059c59ca6be827d6de9a0e26f526b9414c0"],"e460f059c59ca6be827d6de9a0e26f526b9414c0":["ee299c4e4c019174aa433f564b5de03a7a40e00d"],"ee299c4e4c019174aa433f564b5de03a7a40e00d":["99761ac3b0c4136140f9cd2d081b80934bba16fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"868f63baffb79407d4b49f3c0be8dc4725ffc6e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b9ccce763ea3c7e51eff749e584c061d8744b72d"],"99761ac3b0c4136140f9cd2d081b80934bba16fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b9ccce763ea3c7e51eff749e584c061d8744b72d":["375ee6573ef9849fb746b27e12fea91e8f7d77b9"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1","c422e924212367b334b4938f1fd3e44438e88c40"],"c422e924212367b334b4938f1fd3e44438e88c40":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1","1800b996d8677670482a071dcb7a48b08c423ace"],"1800b996d8677670482a071dcb7a48b08c423ace":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"]},"commit2Childs":{"375ee6573ef9849fb746b27e12fea91e8f7d77b9":["b9ccce763ea3c7e51eff749e584c061d8744b72d"],"ebfbe42b2dae57f9ac08706e76b0ab8bdf7011c8":["375ee6573ef9849fb746b27e12fea91e8f7d77b9"],"e460f059c59ca6be827d6de9a0e26f526b9414c0":["ebfbe42b2dae57f9ac08706e76b0ab8bdf7011c8"],"ee299c4e4c019174aa433f564b5de03a7a40e00d":["e460f059c59ca6be827d6de9a0e26f526b9414c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1","99761ac3b0c4136140f9cd2d081b80934bba16fa"],"868f63baffb79407d4b49f3c0be8dc4725ffc6e1":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273","c422e924212367b334b4938f1fd3e44438e88c40","1800b996d8677670482a071dcb7a48b08c423ace"],"99761ac3b0c4136140f9cd2d081b80934bba16fa":["ee299c4e4c019174aa433f564b5de03a7a40e00d"],"b9ccce763ea3c7e51eff749e584c061d8744b72d":["868f63baffb79407d4b49f3c0be8dc4725ffc6e1"],"cf1a614098b46c9c22afebd7b898ae4d1d2fc273":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c422e924212367b334b4938f1fd3e44438e88c40":["cf1a614098b46c9c22afebd7b898ae4d1d2fc273"],"1800b996d8677670482a071dcb7a48b08c423ace":["c422e924212367b334b4938f1fd3e44438e88c40"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}