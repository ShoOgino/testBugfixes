{"path":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","commits":[{"id":"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","date":1462567286,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45bfb4d30b7e62ec7d645a5e0113362636ac4981","date":1462660573,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeLong(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ff25cb7bb787cbe9d05740c89a527ddd2617c16","date":1462702859,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeLong(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeLong(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          // nocommit the rest:\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ad56fe9e068c425e8ac38f2263714e167490c2","date":1462704115,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeLong(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e065cebbdee472a02bde38052717a8cd7ee8ab3b","date":1479244971,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1ef55e1fff7ff44354432770ad8bc19be1fcc75","date":1479266056,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output, \n                                   Lucene62SegmentInfoFormat.CODEC_NAME, \n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortField.getType()) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n      \n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31741cf1390044e38a2ec3127cf302ba841bfd75","date":1491292636,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo info, IOContext ioContext) throws IOException {\n    throw new UnsupportedOperationException(\"This format can only be used for reading\");\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"92212fd254551a0b1156aafc3a1a6ed1a43932ad","date":1491296431,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":"  @Override\n  public void write(Directory dir, SegmentInfo info, IOContext ioContext) throws IOException {\n    throw new UnsupportedOperationException(\"This format can only be used for reading\");\n  }\n\n","sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo si, IOContext ioContext) throws IOException {\n    final String fileName = IndexFileNames.segmentFileName(si.name, \"\", Lucene62SegmentInfoFormat.SI_EXTENSION);\n\n    try (IndexOutput output = dir.createOutput(fileName, ioContext)) {\n      // Only add the file once we've successfully created it, else IFD assert can trip:\n      si.addFile(fileName);\n      CodecUtil.writeIndexHeader(output,\n                                   Lucene62SegmentInfoFormat.CODEC_NAME,\n                                   Lucene62SegmentInfoFormat.VERSION_CURRENT,\n                                   si.getId(),\n                                   \"\");\n      Version version = si.getVersion();\n      if (version.major < 5) {\n        throw new IllegalArgumentException(\"invalid major version: should be >= 5 but got: \" + version.major + \" segment=\" + si);\n      }\n      // Write the Lucene version that created this segment, since 3.1\n      output.writeInt(version.major);\n      output.writeInt(version.minor);\n      output.writeInt(version.bugfix);\n      assert version.prerelease == 0;\n      output.writeInt(si.maxDoc());\n\n      output.writeByte((byte) (si.getUseCompoundFile() ? SegmentInfo.YES : SegmentInfo.NO));\n      output.writeMapOfStrings(si.getDiagnostics());\n      Set<String> files = si.files();\n      for (String file : files) {\n        if (!IndexFileNames.parseSegmentName(file).equals(si.name)) {\n          throw new IllegalArgumentException(\"invalid files: expected segment=\" + si.name + \", got=\" + files);\n        }\n      }\n      output.writeSetOfStrings(files);\n      output.writeMapOfStrings(si.getAttributes());\n\n      Sort indexSort = si.getIndexSort();\n      int numSortFields = indexSort == null ? 0 : indexSort.getSort().length;\n      output.writeVInt(numSortFields);\n      for (int i = 0; i < numSortFields; ++i) {\n        SortField sortField = indexSort.getSort()[i];\n        SortField.Type sortType = sortField.getType();\n        output.writeString(sortField.getField());\n        int sortTypeID;\n        switch (sortField.getType()) {\n          case STRING:\n            sortTypeID = 0;\n            break;\n          case LONG:\n            sortTypeID = 1;\n            break;\n          case INT:\n            sortTypeID = 2;\n            break;\n          case DOUBLE:\n            sortTypeID = 3;\n            break;\n          case FLOAT:\n            sortTypeID = 4;\n            break;\n          case CUSTOM:\n            if (sortField instanceof SortedSetSortField) {\n              sortTypeID = 5;\n              sortType = SortField.Type.STRING;\n            } else if (sortField instanceof SortedNumericSortField) {\n              sortTypeID = 6;\n              sortType = ((SortedNumericSortField) sortField).getNumericType();\n            } else {\n              throw new IllegalStateException(\"Unexpected SortedNumericSortField \" + sortField);\n            }\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n        }\n        output.writeVInt(sortTypeID);\n        if (sortTypeID == 5) {\n          SortedSetSortField ssf = (SortedSetSortField) sortField;\n          if (ssf.getSelector() == SortedSetSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MIN) {\n            output.writeByte((byte) 2);\n          } else if (ssf.getSelector() == SortedSetSelector.Type.MIDDLE_MAX) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedSetSelector type: \" + ssf.getSelector());\n          }\n        } else if (sortTypeID == 6) {\n          SortedNumericSortField snsf = (SortedNumericSortField) sortField;\n          if (snsf.getNumericType() == SortField.Type.LONG) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getNumericType() == SortField.Type.INT) {\n            output.writeByte((byte) 1);\n          } else if (snsf.getNumericType() == SortField.Type.DOUBLE) {\n            output.writeByte((byte) 2);\n          } else if (snsf.getNumericType() == SortField.Type.FLOAT) {\n            output.writeByte((byte) 3);\n          } else {\n            throw new IllegalStateException(\"Unexpected SortedNumericSelector type: \" + snsf.getNumericType());\n          }\n          if (snsf.getSelector() == SortedNumericSelector.Type.MIN) {\n            output.writeByte((byte) 0);\n          } else if (snsf.getSelector() == SortedNumericSelector.Type.MAX) {\n            output.writeByte((byte) 1);\n          } else {\n            throw new IllegalStateException(\"Unexpected sorted numeric selector type: \" + snsf.getSelector());\n          }\n        }\n        output.writeByte((byte) (sortField.getReverse() ? 0 : 1));\n\n        // write missing value \n        Object missingValue = sortField.getMissingValue();\n        if (missingValue == null) {\n          output.writeByte((byte) 0);\n        } else {\n          switch(sortType) {\n          case STRING:\n            if (missingValue == SortField.STRING_LAST) {\n              output.writeByte((byte) 1);\n            } else if (missingValue == SortField.STRING_FIRST) {\n              output.writeByte((byte) 2);\n            } else {\n              throw new AssertionError(\"unrecognized missing value for STRING field \\\"\" + sortField.getField() + \"\\\": \" + missingValue);\n            }\n            break;\n          case LONG:\n            output.writeByte((byte) 1);\n            output.writeLong(((Long) missingValue).longValue());\n            break;\n          case INT:\n            output.writeByte((byte) 1);\n            output.writeInt(((Integer) missingValue).intValue());\n            break;\n          case DOUBLE:\n            output.writeByte((byte) 1);\n            output.writeLong(Double.doubleToLongBits(((Double) missingValue).doubleValue()));\n            break;\n          case FLOAT:\n            output.writeByte((byte) 1);\n            output.writeInt(Float.floatToIntBits(((Float) missingValue).floatValue()));\n            break;\n          default:\n            throw new IllegalStateException(\"Unexpected sort type: \" + sortField.getType());\n          }\n        }\n      }\n\n      CodecUtil.writeFooter(output);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0e7448656541edc407546460641f47950451b16","date":1519150500,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/lucene62/Lucene62SegmentInfoFormat#write(Directory,SegmentInfo,IOContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void write(Directory dir, SegmentInfo info, IOContext ioContext) throws IOException {\n    throw new UnsupportedOperationException(\"This format can only be used for reading\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c0e7448656541edc407546460641f47950451b16":["31741cf1390044e38a2ec3127cf302ba841bfd75"],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"4ff25cb7bb787cbe9d05740c89a527ddd2617c16":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":["e065cebbdee472a02bde38052717a8cd7ee8ab3b"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a8ad56fe9e068c425e8ac38f2263714e167490c2"],"a8ad56fe9e068c425e8ac38f2263714e167490c2":["4ff25cb7bb787cbe9d05740c89a527ddd2617c16"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c0e7448656541edc407546460641f47950451b16"]},"commit2Childs":{"c0e7448656541edc407546460641f47950451b16":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["4ff25cb7bb787cbe9d05740c89a527ddd2617c16"],"e065cebbdee472a02bde38052717a8cd7ee8ab3b":["31741cf1390044e38a2ec3127cf302ba841bfd75","a1ef55e1fff7ff44354432770ad8bc19be1fcc75","92212fd254551a0b1156aafc3a1a6ed1a43932ad"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"4ff25cb7bb787cbe9d05740c89a527ddd2617c16":["a8ad56fe9e068c425e8ac38f2263714e167490c2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75"],"31741cf1390044e38a2ec3127cf302ba841bfd75":["c0e7448656541edc407546460641f47950451b16"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e065cebbdee472a02bde38052717a8cd7ee8ab3b","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","3d33e731a93d4b57e662ff094f64f94a745422d4","fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"a1ef55e1fff7ff44354432770ad8bc19be1fcc75":[],"92212fd254551a0b1156aafc3a1a6ed1a43932ad":[],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"a8ad56fe9e068c425e8ac38f2263714e167490c2":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a1ef55e1fff7ff44354432770ad8bc19be1fcc75","92212fd254551a0b1156aafc3a1a6ed1a43932ad","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}