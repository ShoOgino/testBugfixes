{"path":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","commits":[{"id":"ca70fffb953aae4d27efbfc28758033a317f39b1","date":1396371342,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         DateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c92ac83d1c2f8811300bb0df797465cca0aa8e92"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5eb2511ababf862ea11e10761c70ee560cd84510","date":1396607225,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"/dev/null","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         DateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2106271e380c198349e0f6eac0395bb462913fab","date":1397072894,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         TrieDateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         DateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331","date":1437383270,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         DateFormatUtil.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         TrieDateField.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3f6c7717a0f1decd1668144537943efcc70cd95","date":1459359762,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                         DateFormatUtil.formatExternal(SolrRequestInfo.getRequestInfo().getNOW())\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz Krasiński","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will supress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6","date":1487775028,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            proc.finish();\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"12a024bac1772e3d7a9fd342b27fbf4c037fa7ac","date":1495789801,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d1f5728f32a4a256b36cfabd7a2636452f599bb9","date":1496231774,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Begining periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ac7cf07a79b13a456220f6e712457c9cdafb91c","date":1555651346,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c92ac83d1c2f8811300bb0df797465cca0aa8e92","date":1579710745,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final LocalSolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        // HACK: to indicate to PKI that this is a server initiated request for the purposes\n        // of distributed requet/credential forwarding...\n        req.setUserPrincipalName(PKIAuthenticationPlugin.NODE_IS_USER);\n        \n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final SolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"740d649f013f07efbeb73ca854f106c60166e7c0","date":1587431295,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final LocalSolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        // HACK: to indicate to PKI that this is a server initiated request for the purposes\n        // of distributed requet/credential forwarding...\n        req.setUserPrincipalName(PKIAuthenticationPlugin.NODE_IS_USER);\n        \n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion of expired docs using chain: {}\"\n                     , deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: {}\",\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: {}\",\n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final LocalSolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        // HACK: to indicate to PKI that this is a server initiated request for the purposes\n        // of distributed requet/credential forwarding...\n        req.setUserPrincipalName(PKIAuthenticationPlugin.NODE_IS_USER);\n        \n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion \" + \n                     \"of expired docs using chain: {}\", deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \" +\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \" + \n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57c238f5fb83803b49b37b3a1a12224a64d47542","date":1593655679,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DocExpirationUpdateProcessorFactory.DeleteExpiredDocsRunnable#run().mjava","sourceNew":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final LocalSolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        // HACK: to indicate to PKI that this is a server initiated request for the purposes\n        // of distributed requet/credential forwarding...\n        req.setUserPrincipalName(PKIAuthenticationPlugin.NODE_IS_USER);\n        \n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion of expired docs using chain: {}\"\n                     , deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: \", ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: \", re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","sourceOld":"    public void run() {\n      // setup the request context early so the logging (including any from \n      // shouldWeDoPeriodicDelete() ) includes the core context info\n      final LocalSolrQueryRequest req = new LocalSolrQueryRequest\n        (factory.core, Collections.<String,String[]>emptyMap());\n      try {\n        // HACK: to indicate to PKI that this is a server initiated request for the purposes\n        // of distributed requet/credential forwarding...\n        req.setUserPrincipalName(PKIAuthenticationPlugin.NODE_IS_USER);\n        \n        final SolrQueryResponse rsp = new SolrQueryResponse();\n        rsp.addResponseHeader(new SimpleOrderedMap<>(1));\n        SolrRequestInfo.setRequestInfo(new SolrRequestInfo(req, rsp));\n        try {\n          \n          if (! factory.iAmInChargeOfPeriodicDeletes() ) {\n            // No-Op\n            return;\n          }\n          log.info(\"Beginning periodic deletion of expired docs\");\n\n          UpdateRequestProcessorChain chain = core.getUpdateProcessingChain(deleteChainName);\n          UpdateRequestProcessor proc = chain.createProcessor(req, rsp);\n          if (null == proc) {\n            log.warn(\"No active processors, skipping automatic deletion of expired docs using chain: {}\"\n                     , deleteChainName);\n            return;\n          }\n          try {\n            DeleteUpdateCommand del = new DeleteUpdateCommand(req);\n            del.setQuery(\"{!cache=false}\" + expireField + \":[* TO \" +\n                SolrRequestInfo.getRequestInfo().getNOW().toInstant()\n                         + \"]\");\n            proc.processDelete(del);\n            \n            // TODO: should this be more configurable? \n            // TODO: in particular: should hard commit be optional?\n            CommitUpdateCommand commit = new CommitUpdateCommand(req, false);\n            commit.softCommit = true;\n            commit.openSearcher = true;\n            proc.processCommit(commit);\n            \n          } finally {\n            try {\n              proc.finish();\n            } finally {\n              proc.close();\n            }\n          }\n\n          log.info(\"Finished periodic deletion of expired docs\");\n        } catch (IOException ioe) {\n          log.error(\"IOException in periodic deletion of expired docs: {}\",\n                    ioe.getMessage(), ioe);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } catch (RuntimeException re) {\n          log.error(\"Runtime error in periodic deletion of expired docs: {}\",\n                    re.getMessage(), re);\n          // DO NOT RETHROW: ScheduledExecutor will suppress subsequent executions\n        } finally {\n          SolrRequestInfo.clearRequestInfo();\n        }\n      } finally {\n        req.close();\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"5eb2511ababf862ea11e10761c70ee560cd84510":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ca70fffb953aae4d27efbfc28758033a317f39b1"],"2ac7cf07a79b13a456220f6e712457c9cdafb91c":["d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"740d649f013f07efbeb73ca854f106c60166e7c0":["c92ac83d1c2f8811300bb0df797465cca0aa8e92"],"c92ac83d1c2f8811300bb0df797465cca0aa8e92":["2ac7cf07a79b13a456220f6e712457c9cdafb91c"],"d3f6c7717a0f1decd1668144537943efcc70cd95":["0c38a05f7a7b43c2dabbd25f12f9941c64bb2331"],"12a024bac1772e3d7a9fd342b27fbf4c037fa7ac":["2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["740d649f013f07efbeb73ca854f106c60166e7c0"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["d3f6c7717a0f1decd1668144537943efcc70cd95","d470c8182e92b264680e34081b75e70a9f2b3c89"],"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331":["2106271e380c198349e0f6eac0395bb462913fab"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["d3f6c7717a0f1decd1668144537943efcc70cd95","0158ced21948b6626f733c1c42c1e18d94449789"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6","12a024bac1772e3d7a9fd342b27fbf4c037fa7ac"],"2106271e380c198349e0f6eac0395bb462913fab":["ca70fffb953aae4d27efbfc28758033a317f39b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ca70fffb953aae4d27efbfc28758033a317f39b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6","12a024bac1772e3d7a9fd342b27fbf4c037fa7ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"0158ced21948b6626f733c1c42c1e18d94449789":["d3f6c7717a0f1decd1668144537943efcc70cd95"]},"commit2Childs":{"5eb2511ababf862ea11e10761c70ee560cd84510":[],"2ac7cf07a79b13a456220f6e712457c9cdafb91c":["c92ac83d1c2f8811300bb0df797465cca0aa8e92"],"740d649f013f07efbeb73ca854f106c60166e7c0":["57c238f5fb83803b49b37b3a1a12224a64d47542"],"c92ac83d1c2f8811300bb0df797465cca0aa8e92":["740d649f013f07efbeb73ca854f106c60166e7c0"],"d3f6c7717a0f1decd1668144537943efcc70cd95":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"12a024bac1772e3d7a9fd342b27fbf4c037fa7ac":["e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"57c238f5fb83803b49b37b3a1a12224a64d47542":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"0c38a05f7a7b43c2dabbd25f12f9941c64bb2331":["d3f6c7717a0f1decd1668144537943efcc70cd95"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"2106271e380c198349e0f6eac0395bb462913fab":["0c38a05f7a7b43c2dabbd25f12f9941c64bb2331"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5eb2511ababf862ea11e10761c70ee560cd84510","ca70fffb953aae4d27efbfc28758033a317f39b1"],"ca70fffb953aae4d27efbfc28758033a317f39b1":["5eb2511ababf862ea11e10761c70ee560cd84510","2106271e380c198349e0f6eac0395bb462913fab"],"2d06ba55ef44382e5547ff01fff8eb1f0fa0faa6":["12a024bac1772e3d7a9fd342b27fbf4c037fa7ac","e9017cf144952056066919f1ebc7897ff9bd71b1","d1f5728f32a4a256b36cfabd7a2636452f599bb9"],"d1f5728f32a4a256b36cfabd7a2636452f599bb9":["2ac7cf07a79b13a456220f6e712457c9cdafb91c"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["5eb2511ababf862ea11e10761c70ee560cd84510","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}