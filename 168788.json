{"path":"lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy#testForceMergeFullyDeleted().mjava","commits":[{"id":"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72","date":1523453225,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy#testForceMergeFullyDeleted().mjava","pathOld":"/dev/null","sourceNew":"  public void testForceMergeFullyDeleted() throws IOException {\n    Directory dir = newDirectory();\n    AtomicBoolean letItGo = new AtomicBoolean(false);\n    MergePolicy policy = new SoftDeletesRetentionMergePolicy(\"soft_delete\",\n        () -> letItGo.get() ? new MatchNoDocsQuery() : new MatchAllDocsQuery(), new LogDocMergePolicy());\n    IndexWriterConfig indexWriterConfig = newIndexWriterConfig().setMergePolicy(policy)\n        .setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir, indexWriterConfig);\n\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    writer.commit();\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    DirectoryReader reader = writer.getReader();\n    {\n      assertEquals(2, reader.leaves().size());\n      final SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    {\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(1).reader();\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n      writer.forceMerge(1);\n      reader.close();\n    }\n    reader = writer.getReader();\n    {\n      assertEquals(1, reader.leaves().size());\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertEquals(2, reader.maxDoc());\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    writer.forceMerge(1); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n    letItGo.set(true);\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    DirectoryReader directoryReader = DirectoryReader.openIfChanged(reader);\n    assertNotNull(directoryReader);\n    assertEquals(0, directoryReader.numDeletedDocs());\n    assertEquals(0, directoryReader.maxDoc());\n    IOUtils.close(directoryReader, reader, writer, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"43345f1452f9510f8aaadae6156fe0c834e7d957","date":1523483670,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy#testForceMergeFullyDeleted().mjava","pathOld":"/dev/null","sourceNew":"  public void testForceMergeFullyDeleted() throws IOException {\n    Directory dir = newDirectory();\n    AtomicBoolean letItGo = new AtomicBoolean(false);\n    MergePolicy policy = new SoftDeletesRetentionMergePolicy(\"soft_delete\",\n        () -> letItGo.get() ? new MatchNoDocsQuery() : new MatchAllDocsQuery(), new LogDocMergePolicy());\n    IndexWriterConfig indexWriterConfig = newIndexWriterConfig().setMergePolicy(policy)\n        .setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir, indexWriterConfig);\n\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    writer.commit();\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    DirectoryReader reader = writer.getReader();\n    {\n      assertEquals(2, reader.leaves().size());\n      final SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    {\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(1).reader();\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n      writer.forceMerge(1);\n      reader.close();\n    }\n    reader = writer.getReader();\n    {\n      assertEquals(1, reader.leaves().size());\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertEquals(2, reader.maxDoc());\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    writer.forceMerge(1); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n    letItGo.set(true);\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    DirectoryReader directoryReader = DirectoryReader.openIfChanged(reader);\n    assertNotNull(directoryReader);\n    assertEquals(0, directoryReader.numDeletedDocs());\n    assertEquals(0, directoryReader.maxDoc());\n    IOUtils.close(directoryReader, reader, writer, dir);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15e716649e2bd79a98b5e68c464154ea4c44677a","date":1523975212,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy#testForceMergeFullyDeleted().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestSoftDeletesRetentionMergePolicy#testForceMergeFullyDeleted().mjava","sourceNew":"  public void testForceMergeFullyDeleted() throws IOException {\n    Directory dir = newDirectory();\n    AtomicBoolean letItGo = new AtomicBoolean(false);\n    MergePolicy policy = new SoftDeletesRetentionMergePolicy(\"soft_delete\",\n        () -> letItGo.get() ? new MatchNoDocsQuery() : new MatchAllDocsQuery(), new LogDocMergePolicy());\n    IndexWriterConfig indexWriterConfig = newIndexWriterConfig().setMergePolicy(policy)\n        .setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir, indexWriterConfig);\n\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    writer.commit();\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    DirectoryReader reader = writer.getReader();\n    {\n      assertEquals(2, reader.leaves().size());\n      final SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertTrue(policy.keepFullyDeletedSegment(() -> segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    {\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(1).reader();\n      assertTrue(policy.keepFullyDeletedSegment(() -> segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n      writer.forceMerge(1);\n      reader.close();\n    }\n    reader = writer.getReader();\n    {\n      assertEquals(1, reader.leaves().size());\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertEquals(2, reader.maxDoc());\n      assertTrue(policy.keepFullyDeletedSegment(() -> segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    writer.forceMerge(1); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n    letItGo.set(true);\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    DirectoryReader directoryReader = DirectoryReader.openIfChanged(reader);\n    assertNotNull(directoryReader);\n    assertEquals(0, directoryReader.numDeletedDocs());\n    assertEquals(0, directoryReader.maxDoc());\n    IOUtils.close(directoryReader, reader, writer, dir);\n  }\n\n","sourceOld":"  public void testForceMergeFullyDeleted() throws IOException {\n    Directory dir = newDirectory();\n    AtomicBoolean letItGo = new AtomicBoolean(false);\n    MergePolicy policy = new SoftDeletesRetentionMergePolicy(\"soft_delete\",\n        () -> letItGo.get() ? new MatchNoDocsQuery() : new MatchAllDocsQuery(), new LogDocMergePolicy());\n    IndexWriterConfig indexWriterConfig = newIndexWriterConfig().setMergePolicy(policy)\n        .setSoftDeletesField(\"soft_delete\");\n    IndexWriter writer = new IndexWriter(dir, indexWriterConfig);\n\n    Document doc = new Document();\n    doc.add(new StringField(\"id\", \"1\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    writer.commit();\n    doc = new Document();\n    doc.add(new StringField(\"id\", \"2\", Field.Store.YES));\n    doc.add(new NumericDocValuesField(\"soft_delete\", 1));\n    writer.addDocument(doc);\n    DirectoryReader reader = writer.getReader();\n    {\n      assertEquals(2, reader.leaves().size());\n      final SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    {\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(1).reader();\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n      writer.forceMerge(1);\n      reader.close();\n    }\n    reader = writer.getReader();\n    {\n      assertEquals(1, reader.leaves().size());\n      SegmentReader segmentReader = (SegmentReader) reader.leaves().get(0).reader();\n      assertEquals(2, reader.maxDoc());\n      assertTrue(policy.keepFullyDeletedSegment(segmentReader));\n      assertEquals(0, policy.numDeletesToMerge(segmentReader.getSegmentInfo(), 0, () -> segmentReader));\n    }\n    writer.forceMerge(1); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    assertNull(DirectoryReader.openIfChanged(reader));\n    letItGo.set(true);\n    writer.forceMergeDeletes(); // make sure we don't merge this\n    DirectoryReader directoryReader = DirectoryReader.openIfChanged(reader);\n    assertNotNull(directoryReader);\n    assertEquals(0, directoryReader.numDeletedDocs());\n    assertEquals(0, directoryReader.maxDoc());\n    IOUtils.close(directoryReader, reader, writer, dir);\n  }\n\n","bugFix":["9ae87c7be37e537f40fa3bb2c35fa4a368d12a72"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"15e716649e2bd79a98b5e68c464154ea4c44677a":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9ae87c7be37e537f40fa3bb2c35fa4a368d12a72"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["15e716649e2bd79a98b5e68c464154ea4c44677a"]},"commit2Childs":{"9ae87c7be37e537f40fa3bb2c35fa4a368d12a72":["43345f1452f9510f8aaadae6156fe0c834e7d957"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ae87c7be37e537f40fa3bb2c35fa4a368d12a72","43345f1452f9510f8aaadae6156fe0c834e7d957"],"15e716649e2bd79a98b5e68c464154ea4c44677a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"43345f1452f9510f8aaadae6156fe0c834e7d957":["15e716649e2bd79a98b5e68c464154ea4c44677a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}