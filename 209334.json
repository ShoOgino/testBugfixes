{"path":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField],ParsedParams,List[FacetComponent.FacetBase],List[RangeFacetRequest]).mjava","commits":[{"id":"22d0a81a05eba47d5e18976f17d88306b218cc22","date":1436341569,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField],ParsedParams,List[FacetComponent.FacetBase],List[RangeFacetRequest]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/component/PivotFacetProcessor#processSingle(List[String],String,List[StatsField],ParsedParams).mjava","sourceNew":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   * @param facetQueries the list of facet queries hung under this pivot\n   * @param facetRanges the list of facet ranges hung under this pivot\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n  (List<String> pivotFields,\n   String refinements,\n   List<StatsField> statsFields,\n   final ParsedParams parsed,\n   List<FacetComponent.FacetBase> facetQueries,\n   List<RangeFacetRequest> facetRanges) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(parsed.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, parsed);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(parsed.key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, parsed, statsFields, facetQueries, facetRanges));\n    } else {\n      pivotResponse.add(parsed.key, doPivots(facetCounts, field, null, fnames, vnames, parsed, statsFields, facetQueries, facetRanges));\n    }\n    return pivotResponse;\n  }\n\n","sourceOld":"  /**\n   * Process a single branch of refinement values for a specific pivot\n   * @param pivotFields the ordered list of fields in this pivot\n   * @param refinements the comma separate list of refinement values corresponding to each field in the pivot, or null if there are no refinements\n   * @param statsFields List of {@link StatsField} instances to compute for each pivot value\n   */\n  private SimpleOrderedMap<List<NamedList<Object>>> processSingle\n    (List<String> pivotFields,\n     String refinements,\n     List<StatsField> statsFields,\n     final ParsedParams parsed) throws IOException {\n\n    SolrIndexSearcher searcher = rb.req.getSearcher();\n    SimpleOrderedMap<List<NamedList<Object>>> pivotResponse = new SimpleOrderedMap<>();\n\n    String field = pivotFields.get(0);\n    SchemaField sfield = searcher.getSchema().getField(field);\n      \n    Deque<String> fnames = new LinkedList<>();\n    for( int i = pivotFields.size()-1; i>1; i-- ) {\n      fnames.push( pivotFields.get(i) );\n    }\n    \n    NamedList<Integer> facetCounts;\n    Deque<String> vnames = new LinkedList<>();\n\n    if (null != refinements) {\n      // All values, split by the field they should go to\n      List<String> refinementValuesByField\n        = PivotFacetHelper.decodeRefinementValuePath(refinements);\n\n      for( int i=refinementValuesByField.size()-1; i>0; i-- ) {\n        vnames.push(refinementValuesByField.get(i));//Only for [1] and on\n      }\n\n      String firstFieldsValues = refinementValuesByField.get(0);\n\n      facetCounts = new NamedList<>();\n      facetCounts.add(firstFieldsValues,\n                      getSubsetSize(parsed.docs, sfield, firstFieldsValues));\n    } else {\n      // no refinements needed\n      facetCounts = this.getTermCountsForPivots(field, parsed);\n    }\n    \n    if(pivotFields.size() > 1) {\n      String subField = pivotFields.get(1);\n      pivotResponse.add(parsed.key,\n                        doPivots(facetCounts, field, subField, fnames, vnames, parsed, statsFields));\n    } else {\n      pivotResponse.add(parsed.key, doPivots(facetCounts, field, null, fnames, vnames, parsed, statsFields));\n    }\n    return pivotResponse;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22d0a81a05eba47d5e18976f17d88306b218cc22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["22d0a81a05eba47d5e18976f17d88306b218cc22"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22d0a81a05eba47d5e18976f17d88306b218cc22"],"22d0a81a05eba47d5e18976f17d88306b218cc22":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}