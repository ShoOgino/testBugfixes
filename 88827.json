{"path":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","commits":[{"id":"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","date":1522388336,"type":1,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager) {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"acfe8d3b837b6b66eaddf114bb99cf9e2257764d","date":1522406637,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager) {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception  {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\",\"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0)  return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName()))  {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n          + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames,8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames,6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","date":1522763990,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      AutoScaling.Trigger t = new TriggerBase(TriggerEventType.NODELOST, \"x\") {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      };\n      t.configure(runner.getCoreContainer().getResourceLoader(), runner.getCoreContainer().getZkController().getSolrCloudManager(), Collections.emptyMap());\n      scheduledTriggers.add(t);\n\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST, \"x\" + i)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        };\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        scheduledTriggers.add(trigger);\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      scheduledTriggers.add(new TriggerBase(TriggerEventType.NODELOST, \"x\", Collections.emptyMap(), resourceLoader, solrCloudManager) {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      });\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        triggerList.add(new MockTrigger(TriggerEventType.NODELOST, \"x\" + i, Collections.emptyMap(), resourceLoader, solrCloudManager) {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        });\n        scheduledTriggers.add(triggerList.get(i));\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"614e18596e0534d68f5eed09fa8e8f36a2d6e292","date":1544549940,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(timeSource.getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      AutoScaling.Trigger t = new TriggerBase(TriggerEventType.NODELOST, \"x\") {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      };\n      t.configure(runner.getCoreContainer().getResourceLoader(), runner.getCoreContainer().getZkController().getSolrCloudManager(), Collections.emptyMap());\n      scheduledTriggers.add(t);\n\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST, \"x\" + i)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        };\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        scheduledTriggers.add(trigger);\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e0abaca9e5481b5c3660805111683e8ce53bef3","date":1544554124,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(timeSource.getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","sourceOld":"  public void testSetProperties() throws Exception {\n    JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    AtomicLong diff = new AtomicLong(0);\n    triggerFiredLatch = new CountDownLatch(2); // have the trigger run twice to capture time difference\n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n      AutoScaling.Trigger t = new TriggerBase(TriggerEventType.NODELOST, \"x\") {\n        @Override\n        protected Map<String, Object> getState() {\n          return Collections.singletonMap(\"x\", \"y\");\n        }\n\n        @Override\n        protected void setState(Map<String, Object> state) {\n\n        }\n\n        @Override\n        public void restoreState(AutoScaling.Trigger old) {\n\n        }\n\n        @Override\n        public void run() {\n          if (getTriggerFiredLatch().getCount() == 0) return;\n          long l = diff.get();\n          diff.set(timeSource.getTimeNs() - l);\n          getTriggerFiredLatch().countDown();\n        }\n      };\n      t.configure(runner.getCoreContainer().getResourceLoader(), runner.getCoreContainer().getZkController().getSolrCloudManager(), Collections.emptyMap());\n      scheduledTriggers.add(t);\n\n      assertTrue(getTriggerFiredLatch().await(4, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS) >= 0);\n\n      // change schedule delay\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(2);\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(10, TimeUnit.SECONDS));\n      assertTrue(diff.get() - TimeUnit.SECONDS.toNanos(4) >= 0);\n\n      // reset with default properties\n      scheduledTriggers.remove(\"x\"); // remove the old trigger\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // test core thread count\n      List<AutoScaling.Trigger> triggerList = new ArrayList<>();\n      final Set<String> threadNames = Collections.synchronizedSet(new HashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new HashSet<>());\n      triggerFiredLatch = new CountDownLatch(8);\n      for (int i = 0; i < 8; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST, \"x\" + i)  {\n          @Override\n          public void run() {\n            try {\n              // If core pool size is increased then new threads won't be started if existing threads\n              // aren't busy with tasks. So we make this thread wait longer than necessary\n              // so that the pool is forced to start threads for other triggers\n              Thread.sleep(5000);\n            } catch (InterruptedException e) {\n            }\n            if (triggerNames.add(getName())) {\n              getTriggerFiredLatch().countDown();\n              threadNames.add(Thread.currentThread().getName());\n            }\n          }\n        };\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        scheduledTriggers.add(trigger);\n      }\n      assertTrue(\"Timed out waiting for latch to fire\", getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected \" + ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE\n              + \" threads but found: \" + threadNames,\n          ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE, threadNames.size());\n\n      // change core pool size\n      config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE, 6));\n      scheduledTriggers.setAutoScalingConfig(config);\n      triggerFiredLatch = new CountDownLatch(8);\n      threadNames.clear();\n      triggerNames.clear();\n      assertTrue(getTriggerFiredLatch().await(20, TimeUnit.SECONDS));\n      assertEquals(\"Expected 8 triggers but found: \" + triggerNames, 8, triggerNames.size());\n      assertEquals(\"Expected 6 threads but found: \" + threadNames, 6, threadNames.size());\n\n      // reset\n      for (int i = 0; i < 8; i++) {\n        scheduledTriggers.remove(triggerList.get(i).getName());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc201e01d035a7370848d9d2451e0e27ee77df2e","date":1544724144,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(timeSource.getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5c929d2716fa79d443b93a82adb1da5b578ebd8","date":1550428858,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4","date":1588172214,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          if (log.isInfoEnabled()) {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          }\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      }\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      }\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Removing trigger: {}\", t1.getName());\n      }\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            if (log.isInfoEnabled()) {\n              log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            }\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                }\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              if (log.isInfoEnabled()) {\n                log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              }\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(\"{} : failure waiting on cyclic barrier: {}\", this.getName(), e, e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        if (log.isInfoEnabled()) {\n          log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        }\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","sourceOld":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n      \n      log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n      \n      log.info(\"Removing trigger: {}\", t1.getName());\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(this.getName() + \": failure waiting on cyclic barrier: \" + e.toString(), e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/TriggerSetPropertiesIntegrationTest#testSetProperties().mjava","sourceNew":null,"sourceOld":"  /** \n   * Test that we can add/remove triggers to a scheduler, and change the config on the fly, and still get\n   * expected behavior \n   */\n  // commented out on: 17-Feb-2019   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // annotated on: 24-Dec-2018\n  public void testSetProperties() throws Exception {\n    final JettySolrRunner runner = cluster.getJettySolrRunner(0);\n    final SolrResourceLoader resourceLoader = runner.getCoreContainer().getResourceLoader();\n    final SolrCloudManager solrCloudManager = runner.getCoreContainer().getZkController().getSolrCloudManager();\n    \n    try (ScheduledTriggers scheduledTriggers = new ScheduledTriggers(resourceLoader, solrCloudManager)) {\n      AutoScalingConfig config = new AutoScalingConfig(Collections.emptyMap());\n      scheduledTriggers.setAutoScalingConfig(config);\n\n      // Setup a trigger that records the timestamp of each time it was run\n      // we only need 2 timestamps for the test, so limit the queue and make the trigger a No-Op if full\n      final BlockingQueue<Long> timestamps = new ArrayBlockingQueue<Long>(2);\n      final AutoScaling.Trigger t1 = new MockTrigger(TriggerEventType.NODELOST, \"mock-timestamper\") {\n        @Override\n        public void run() {\n          if (log.isInfoEnabled()) {\n            log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n          }\n          timestamps.offer(solrCloudManager.getTimeSource().getTimeNs());\n        }\n      };\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Configuring simple scheduler and adding trigger: {}\", t1.getName());\n      }\n      t1.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n      scheduledTriggers.add(t1);\n\n      waitForAndDiffTimestamps(\"conf(default delay)\",\n                               ScheduledTriggers.DEFAULT_SCHEDULED_TRIGGER_DELAY_SECONDS, TimeUnit.SECONDS,\n                               timestamps);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Reconfiguing scheduler to use 4s delay and clearing queue for trigger: {}\", t1.getName());\n      }\n      config = config.withProperties(Collections.singletonMap\n                                     (AutoScalingParams.TRIGGER_SCHEDULE_DELAY_SECONDS, 4));\n      scheduledTriggers.setAutoScalingConfig(config);\n      timestamps.clear();\n\n      waitForAndDiffTimestamps(\"conf(four sec delay)\", \n                               4, TimeUnit.SECONDS, \n                               timestamps);\n\n      if (log.isInfoEnabled()) {\n        log.info(\"Removing trigger: {}\", t1.getName());\n      }\n      scheduledTriggers.remove(t1.getName());\n      \n      log.info(\"Reconfiguing scheduler to use default props\");\n      config = config.withProperties(ScheduledTriggers.DEFAULT_PROPERTIES);\n      scheduledTriggers.setAutoScalingConfig(config);\n\n                 \n      assertTrue(\"Test sanity check, need default thread pool to be at least 3 so we can\" +\n                 \"test lowering it by 2\", ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE >= 3);\n      final int numTriggers = ScheduledTriggers.DEFAULT_TRIGGER_CORE_POOL_SIZE;\n      final int reducedThreadPoolSize = numTriggers - 2;\n      \n      // Setup X instances of a trigger that:\n      //  - records it's name as being run\n      //    - skipping all remaining execution if it's name has already been recorded\n      //  - records the name of the thread that ran it\n      //  - blocks on a cyclic barrier untill at Y instances have run (to hog a thread)\n      // ...to test that the scheduler will add new threads as needed, up to the configured limit\n      //\n      // NOTE: the reason we need X unique instances is because the scheduler won't \"re-run\" a single\n      // trigger while a previouss \"run\" is still in process\n      final List<AutoScaling.Trigger> triggerList = new ArrayList<>(numTriggers);\n      \n      // Use a cyclic barrier gated by an atomic ref so we can swap it out later\n      final AtomicReference<CyclicBarrier> latch = new AtomicReference<>(new CyclicBarrier(numTriggers));\n      \n      // variables for tracking state as we go\n      // NOTE: all read/write must be gated by synchronizing on the barrier (ref),\n      //       so we we can ensure we are reading a consistent view\n      final Set<String> threadNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final Set<String> triggerNames = Collections.synchronizedSet(new LinkedHashSet<>());\n      final AtomicLong fails = new AtomicLong(0);\n\n      // Use a semaphore to track when each trigger *finishes* so our test thread\n      // can know when to check & clear the tracking state\n      final Semaphore completionSemaphore = new Semaphore(numTriggers);\n      \n      for (int i = 0; i < numTriggers; i++) {\n        AutoScaling.Trigger trigger = new MockTrigger(TriggerEventType.NODELOST,\n                                                      \"mock-blocking-trigger-\" + i)  {\n          @Override\n          public void run() {\n            if (log.isInfoEnabled()) {\n              log.info(\"Running {} in {}\", this.getName(), Thread.currentThread().getName());\n            }\n            CyclicBarrier barrier = null;\n            synchronized (latch) {\n              if (triggerNames.add(this.getName())) {\n                if (log.isInfoEnabled()) {\n                  log.info(\"{}: No-Op since we've already recorded a run\", this.getName());\n                }\n                return;\n              }\n              threadNames.add(Thread.currentThread().getName());\n              barrier = latch.get();\n            }\n            \n            try {\n              if (log.isInfoEnabled()) {\n                log.info(\"{}: waiting on barrier to hog a thread\", this.getName());\n              }\n              barrier.await(30, TimeUnit.SECONDS);\n              completionSemaphore.release();\n            } catch (Exception e) {\n              fails.incrementAndGet();\n              log.error(\"{} : failure waiting on cyclic barrier: {}\", this.getName(), e, e);\n            }\n          }\n        };\n\n        trigger.configure(resourceLoader, solrCloudManager, Collections.emptyMap());\n        triggerList.add(trigger);\n        completionSemaphore.acquire();\n        if (log.isInfoEnabled()) {\n          log.info(\"Adding trigger {} to scheduler\", trigger.getName());\n        }\n        scheduledTriggers.add(trigger);\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n                                                \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread ames found: \" + threadNames.toString(),\n                     numTriggers, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n\n        // before releasing the latch, clear the state and update our config to use a lower number of threads\n        log.info(\"Updating scheduler config to use {} threads\", reducedThreadPoolSize);\n        config = config.withProperties(Collections.singletonMap(AutoScalingParams.TRIGGER_CORE_POOL_SIZE,\n                                                                reducedThreadPoolSize));\n        scheduledTriggers.setAutoScalingConfig(config);\n\n        log.info(\"Updating cyclic barrier and clearing test state so triggers will 'run' again\");\n        latch.set(new CyclicBarrier(reducedThreadPoolSize));\n        threadNames.clear();\n        triggerNames.clear();\n      }\n      \n      log.info(\"Waiting on semaphore for all triggers to signal completion...\");\n      assertTrue(\"Timed out waiting for semaphore count to be released\",\n                 completionSemaphore.tryAcquire(numTriggers, 60, TimeUnit.SECONDS));\n      \n      synchronized (latch) {\n        assertEquals(\"Unexpected number of trigger names found: \" + triggerNames.toString(),\n                     numTriggers, triggerNames.size());\n        assertEquals(\"Unexpected number of thread names found: \" + threadNames.toString(),\n                    reducedThreadPoolSize, threadNames.size());\n        assertEquals(\"Unexpected number of trigger fails recorded, check logs?\",\n                     0, fails.get());\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"614e18596e0534d68f5eed09fa8e8f36a2d6e292":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["7e0abaca9e5481b5c3660805111683e8ce53bef3"],"7e0abaca9e5481b5c3660805111683e8ce53bef3":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d","614e18596e0534d68f5eed09fa8e8f36a2d6e292"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["bc201e01d035a7370848d9d2451e0e27ee77df2e"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4":["acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["deb2c2675f0afd2a8c2722ff302e4b4b5eb872b4","acfe8d3b837b6b66eaddf114bb99cf9e2257764d"],"b5c929d2716fa79d443b93a82adb1da5b578ebd8":["fe9f2c4a0d7ac164e4bdd4eee7f87131aec83fd4"],"614e18596e0534d68f5eed09fa8e8f36a2d6e292":["7e0abaca9e5481b5c3660805111683e8ce53bef3"],"cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d":["614e18596e0534d68f5eed09fa8e8f36a2d6e292","7e0abaca9e5481b5c3660805111683e8ce53bef3"],"acfe8d3b837b6b66eaddf114bb99cf9e2257764d":["cd44b11f5d211a0b76c6bc536f38d1eb1fe00c8d"],"bc201e01d035a7370848d9d2451e0e27ee77df2e":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"7e0abaca9e5481b5c3660805111683e8ce53bef3":["bc201e01d035a7370848d9d2451e0e27ee77df2e"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["b5c929d2716fa79d443b93a82adb1da5b578ebd8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}