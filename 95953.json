{"path":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","commits":[{"id":"824ab25acd22f2eca198755bafab3cb8b7878493","date":1341276186,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","pathOld":"/dev/null","sourceNew":"  public static int compress(final int[] data, int size, IntBuffer intBuffer) {\n    int numBits=getNumBits(data,size);\n  \n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1;\n    int excLastNonForcePos = -1; \n    int excNumBase = 0;       // num of exception until the last non-force exception\n    int excBytes = 1;         // bytes per exception\n    int excByteOffset = 0;    // bytes of preceeding codes like header and normal area\n    long maxChain = (1<<8) - 2;  // header bits limits this to 254\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    // estimate exceptions\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    // encode normal area, record exception positions\n    i=0;\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = -1;\n      for (; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          if (excLastPos >= 0) {\n            encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          }\n          excNum++;\n          excLastPos = i;\n        }\n      }\n      if (excLastPos >= 0) { \n        encodeNormalValue(intBuffer, excLastPos, (i-excLastPos-1)&MASK[numBits], numBits); // mask out suppressed force exception\n      }\n    }\n  \n    // encode exception area\n    i=0;\n    for (; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = HEADER_INT_SIZE*4 + (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    // encode header\n    encodeHeader(intBuffer, size, numBits, excNum, excFirstPos, excBytes);\n\n    return (excByteOffset + excBytes*excNum + 3)/4*4;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5373bc7574123da55ae25e216b6d768ccb1dcd91","date":1342013351,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","sourceNew":"  /** Compress given int[] into Integer buffer, with PFor format\n   *\n   * @param data        uncompressed data\n   * @param size        num of ints to compress\n   * @param intBuffer   integer buffer to hold compressed data\n   */\n  public static int compress(final int[] data, int size, IntBuffer intBuffer) {\n    /** estimate minimum compress size to determine numFrameBits */\n    int numBits=getNumBits(data,size);\n  \n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1, excLastNonForcePos = -1; \n\n    // num of exception until the last non-forced exception\n    int excNumBase = 0;          \n\n    // bytes per exception\n    int excBytes = 1;\n\n    // bytes before exception area, e.g. header and normal area\n    int excByteOffset = 0;\n\n    // the max value possible for current exception pointer, \n    // value of the first pointer is limited by header as 254\n    long maxChain = (1<<8) - 2;  \n\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    /** estimate exceptions */\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    /** encode normal area, record exception positions */\n    i=0;\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = -1;\n      for (; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          if (excLastPos >= 0) {\n            encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          }\n          excNum++;\n          excLastPos = i;\n        }\n      }\n      if (excLastPos >= 0) { \n        encodeNormalValue(intBuffer, excLastPos, (i-excLastPos-1)&MASK[numBits], numBits); // mask out suppressed force exception\n      }\n    }\n  \n    /** encode exception area */\n    i=0;\n    for (; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = HEADER_INT_SIZE*4 + (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    /** encode header */\n    encodeHeader(intBuffer, size, numBits, excNum, excFirstPos, excBytes);\n\n    return (excByteOffset + excBytes*excNum + 3)/4*4;\n  }\n\n","sourceOld":"  public static int compress(final int[] data, int size, IntBuffer intBuffer) {\n    int numBits=getNumBits(data,size);\n  \n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1;\n    int excLastNonForcePos = -1; \n    int excNumBase = 0;       // num of exception until the last non-force exception\n    int excBytes = 1;         // bytes per exception\n    int excByteOffset = 0;    // bytes of preceeding codes like header and normal area\n    long maxChain = (1<<8) - 2;  // header bits limits this to 254\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    // estimate exceptions\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    // encode normal area, record exception positions\n    i=0;\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = -1;\n      for (; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          if (excLastPos >= 0) {\n            encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          }\n          excNum++;\n          excLastPos = i;\n        }\n      }\n      if (excLastPos >= 0) { \n        encodeNormalValue(intBuffer, excLastPos, (i-excLastPos-1)&MASK[numBits], numBits); // mask out suppressed force exception\n      }\n    }\n  \n    // encode exception area\n    i=0;\n    for (; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = HEADER_INT_SIZE*4 + (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    // encode header\n    encodeHeader(intBuffer, size, numBits, excNum, excFirstPos, excBytes);\n\n    return (excByteOffset + excBytes*excNum + 3)/4*4;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b","date":1342134079,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","sourceNew":"  /** Compress given int[] into Integer buffer, with PFor format\n   *\n   * @param data        uncompressed data\n   * @param size        num of ints to compress\n   * @param intBuffer   integer buffer to hold compressed data\n   */\n  public static int compress(final int[] data, int size, IntBuffer intBuffer) {\n    /** estimate minimum compress size to determine numFrameBits */\n    int numBits=getNumBits(data,size);\n  \n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1, excLastNonForcePos = -1; \n\n    // num of exception until the last non-forced exception\n    int excNumBase = 0;          \n\n    // bytes per exception\n    int excBytes = 1;\n\n    // bytes before exception area, e.g. header and normal area\n    int excByteOffset = 0;\n\n    // the max value possible for current exception pointer, \n    // value of the first pointer is limited by header as 254\n    // (first exception ranges from -1 ~ 254)\n    long maxChainFirst = 254;\n    long maxChain = maxChainFirst + 1;  \n\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    /** estimate exceptions */\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    /** encode normal area, record exception positions */\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (i=0; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (i=0; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = excFirstPos;\n      excNum = i<size? 1:0;\n      for (i=excFirstPos+1; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          excNum++;\n          excLastPos = i;\n        }\n      }\n    }\n  \n    /** encode exception area */\n    for (i=0; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = HEADER_INT_SIZE*4 + (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    /** encode header */\n    encodeHeader(intBuffer, size, numBits, excNum, excFirstPos, excBytes);\n\n    return (excByteOffset + excBytes*excNum + 3)/4*4;\n  }\n\n","sourceOld":"  /** Compress given int[] into Integer buffer, with PFor format\n   *\n   * @param data        uncompressed data\n   * @param size        num of ints to compress\n   * @param intBuffer   integer buffer to hold compressed data\n   */\n  public static int compress(final int[] data, int size, IntBuffer intBuffer) {\n    /** estimate minimum compress size to determine numFrameBits */\n    int numBits=getNumBits(data,size);\n  \n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1, excLastNonForcePos = -1; \n\n    // num of exception until the last non-forced exception\n    int excNumBase = 0;          \n\n    // bytes per exception\n    int excBytes = 1;\n\n    // bytes before exception area, e.g. header and normal area\n    int excByteOffset = 0;\n\n    // the max value possible for current exception pointer, \n    // value of the first pointer is limited by header as 254\n    long maxChain = (1<<8) - 2;  \n\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    /** estimate exceptions */\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    /** encode normal area, record exception positions */\n    i=0;\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = -1;\n      for (; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          if (excLastPos >= 0) {\n            encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          }\n          excNum++;\n          excLastPos = i;\n        }\n      }\n      if (excLastPos >= 0) { \n        encodeNormalValue(intBuffer, excLastPos, (i-excLastPos-1)&MASK[numBits], numBits); // mask out suppressed force exception\n      }\n    }\n  \n    /** encode exception area */\n    i=0;\n    for (; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = HEADER_INT_SIZE*4 + (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    /** encode header */\n    encodeHeader(intBuffer, size, numBits, excNum, excFirstPos, excBytes);\n\n    return (excByteOffset + excBytes*excNum + 3)/4*4;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5","date":1342443326,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],IntBuffer).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/pfor/PForUtil#compress(int[],int,IntBuffer).mjava","sourceNew":"  /** Compress given int[] into Integer buffer, with PFor format\n   *\n   * @param data        uncompressed data\n   * @param intBuffer   integer buffer to hold compressed data\n   * @return block header\n   */\n  public static int compress(final int[] data, IntBuffer intBuffer) {\n    /** estimate minimum compress size to determine numFrameBits */\n    int numBits=getNumBits(data);\n    if (numBits == 0) {\n      return compressDuplicateBlock(data,intBuffer);\n    }\n \n    int size = data.length;\n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1, excLastNonForcePos = -1; \n\n    // num of exception until the last non-forced exception\n    int excNumBase = 0;          \n\n    // bytes per exception\n    int excBytes = 1;\n\n    // bytes before exception area, e.g. header and normal area\n    int excByteOffset = 0;\n\n    // the max value possible for current exception pointer, \n    // value of the first pointer is limited by header as 254\n    // (first exception ranges from -1 ~ 254)\n    long maxChainFirst = 254;\n    long maxChain = maxChainFirst + 1;  \n\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    /** estimate exceptions */\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    /** encode normal area, record exception positions */\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (i=0; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (i=0; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = excFirstPos;\n      excNum = i<size? 1:0;\n      for (i=excFirstPos+1; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          excNum++;\n          excLastPos = i;\n        }\n      }\n    }\n  \n    /** encode exception area */\n    for (i=0; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    /** encode header */\n    int encodedSize = (excByteOffset + excBytes*excNum + 3)/4;\n\n    return getHeader(encodedSize, numBits, excNum, excFirstPos, excBytes);\n  }\n\n","sourceOld":"  /** Compress given int[] into Integer buffer, with PFor format\n   *\n   * @param data        uncompressed data\n   * @param size        num of ints to compress\n   * @param intBuffer   integer buffer to hold compressed data\n   */\n  public static int compress(final int[] data, int size, IntBuffer intBuffer) {\n    /** estimate minimum compress size to determine numFrameBits */\n    int numBits=getNumBits(data,size);\n  \n    int[] excValues = new int[size];\n    int excNum = 0, excLastPos = -1, excFirstPos = -1, excLastNonForcePos = -1; \n\n    // num of exception until the last non-forced exception\n    int excNumBase = 0;          \n\n    // bytes per exception\n    int excBytes = 1;\n\n    // bytes before exception area, e.g. header and normal area\n    int excByteOffset = 0;\n\n    // the max value possible for current exception pointer, \n    // value of the first pointer is limited by header as 254\n    // (first exception ranges from -1 ~ 254)\n    long maxChainFirst = 254;\n    long maxChain = maxChainFirst + 1;  \n\n    boolean conValue, conForce, conEnd;\n    int i=0;\n\n    /** estimate exceptions */\n    for (i=0; i<size; ++i) {\n      conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n      conForce = (i >= maxChain + excLastPos);           // force exception\n      if (conValue || conForce) {\n        excValues[excNum++] = data[i];\n        if (excLastPos == -1) {\n          maxChain = 1L<<numBits; \n          excFirstPos = i;\n        }\n        if (conValue) {\n          excLastNonForcePos = i;\n          excNumBase = excNum;\n        }\n        excLastPos = i;\n      }\n    }\n\n    /** encode normal area, record exception positions */\n    excNum = 0;\n    if (excFirstPos < 0) { // no exception \n      for (i=0; i<size; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      excLastPos = -1;\n    } else {\n      for (i=0; i<excFirstPos; ++i) {\n        encodeNormalValue(intBuffer,i,data[i], numBits);\n      }\n      maxChain = 1L<<numBits;\n      excLastPos = excFirstPos;\n      excNum = i<size? 1:0;\n      for (i=excFirstPos+1; i<size; ++i) {\n        conValue = ((data[i] & MASK[numBits]) != data[i]); // value exception\n        conForce = (i >= maxChain + excLastPos);           // force exception\n        conEnd = (excNum == excNumBase);                   // following forced ignored\n        if ((!conValue && !conForce) || conEnd) {\n          encodeNormalValue(intBuffer,i,data[i], numBits);\n        } else {\n          encodeNormalValue(intBuffer, excLastPos, i-excLastPos-1, numBits); \n          excNum++;\n          excLastPos = i;\n        }\n      }\n    }\n  \n    /** encode exception area */\n    for (i=0; i<excNum; ++i) {\n      if (excBytes < 2 && (excValues[i] & ~MASK[8]) != 0) {\n        excBytes=2;\n      }\n      if (excBytes < 4 && (excValues[i] & ~MASK[16]) != 0) {\n        excBytes=4;\n      }\n    }\n    excByteOffset = HEADER_INT_SIZE*4 + (size*numBits + 7)/8;\n    encodeExcValues(intBuffer, excValues, excNum, excBytes, excByteOffset);\n\n    /** encode header */\n    encodeHeader(intBuffer, size, numBits, excNum, excFirstPos, excBytes);\n\n    return (excByteOffset + excBytes*excNum + 3)/4*4;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"824ab25acd22f2eca198755bafab3cb8b7878493":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5373bc7574123da55ae25e216b6d768ccb1dcd91":["824ab25acd22f2eca198755bafab3cb8b7878493"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["5373bc7574123da55ae25e216b6d768ccb1dcd91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"824ab25acd22f2eca198755bafab3cb8b7878493":["5373bc7574123da55ae25e216b6d768ccb1dcd91"],"5373bc7574123da55ae25e216b6d768ccb1dcd91":["48d40647dc87c7b55ffe4d9dca73f63a3cebc58b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["824ab25acd22f2eca198755bafab3cb8b7878493","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5":[],"48d40647dc87c7b55ffe4d9dca73f63a3cebc58b":["a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a91a0a325d8dbf4d5759c5b368c5eae7ec8483b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}