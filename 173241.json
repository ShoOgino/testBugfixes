{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        OverseerCollectionMessageHandler.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        NUM_SLICES, 1,\n        COLL_CONF, configName,\n        CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"/dev/null","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        OverseerCollectionMessageHandler.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82b686ab2904b3e81184ecea0d238b4ab0885376","date":1529576124,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        OverseerCollectionMessageHandler.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        OverseerCollectionMessageHandler.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        OverseerCollectionMessageHandler.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":["6f26f74e4969851a019d28f10315cb1c77786f22","19498030e0adab22f604f935cae3c03dcf0952a6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69e6520a21709190413a63084ed135271aab1a7c","date":1556607462,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n    // For tracking async calls.\n    Map<String, String> requestMap = new HashMap<>();\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\", asyncId, requestMap);\n\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    // we don't want this to happen asynchronously\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()), shardHandler, null, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection leader\" +\n        \" or timed out waiting for it to come up\", asyncId, requestMap);\n\n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    ocmh.sendShardRequest(tempNodeName, params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\", asyncId, requestMap);\n\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\", asyncId, requestMap);\n\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    ocmh.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\", asyncId, requestMap);\n\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    ocmh.processResponses(results, shardHandler, true, msg, asyncId, requestMap);\n\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    ocmh.sendShardRequest(targetLeader.getNodeName(), params, shardHandler, asyncId, requestMap);\n    ocmh.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\",\n        asyncId, requestMap);\n\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":["1dca57049fb75fd60d90723d142769094a0402be","da888af1ab894358122a22229051215f58cf4d54","058f5a3debcfa0ea477da3eabb4cbe2ec0fac211","3bbb741690cdafda7f1f7549c26351c912917a69","ee31282189f924712ed9ad83e3073e0c207a1a53","66e0b82bd39567aa2bf534e5282d05fb4a4a2c76"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4abf821a41a2fdca2a1dea148999931d22e20529","date":1587749643,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: \" + tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      return;\n    }\n    log.info(\"Common hash range between source shard: {} and target shard: {} = \" + splitRange, sourceSlice.getName(), targetSlice.getName());\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    log.info(\"Asking target leader node: \" + targetLeader.getNodeName() + \" core: \"\n        + targetLeader.getStr(\"core\") + \" to buffer updates\");\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: \" + m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: \" + props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking source leader to wait for: \" + tempCollectionReplica1 + \" to be alive on: \" + sourceLeader.getNodeName());\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n        tempSourceCollectionName, targetLeader.getNodeName());\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    log.info(\"Asking temp source leader to wait for: \" + tempCollectionReplica2 + \" to be alive on: \" + targetLeader.getNodeName());\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: \" + tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: \" + tempSourceCollectionName\n          + \". Please remove it manually\", e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","sourceOld":"  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1964c059f45ae1de1877f9f0fe3ca327ea4218e8","date":1594088246,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = ((HttpShardHandlerFactory)shardHandlerFactory).getShardHandler(ocmh.overseer.getCoreContainer().getUpdateShardHandler().getDefaultHttpClient());\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,CloudConfig,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, CloudConfig cloudConfig, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), cloudConfig, new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, cloudConfig, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, cloudConfig, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), cloudConfig, new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/MigrateCmd#migrateKey(ClusterState,CloudConfig,DocCollection,Slice,DocCollection,Slice,String,int,NamedList,String,ZkNodeProps).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  private void migrateKey(ClusterState clusterState, CloudConfig cloudConfig, DocCollection sourceCollection, Slice sourceSlice,\n                          DocCollection targetCollection, Slice targetSlice,\n                          String splitKey, int timeout,\n                          @SuppressWarnings({\"rawtypes\"})NamedList results, String asyncId, ZkNodeProps message) throws Exception {\n    String tempSourceCollectionName = \"split_\" + sourceSlice.getName() + \"_temp_\" + targetSlice.getName();\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (clusterState.hasCollection(tempSourceCollectionName)) {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      Map<String, Object> props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n\n      try {\n        ocmh.commandMap.get(DELETE).call(zkStateReader.getClusterState(), cloudConfig, new ZkNodeProps(props), results);\n        clusterState = zkStateReader.getClusterState();\n      } catch (Exception e) {\n        log.warn(\"Unable to clean up existing temporary collection: {}\", tempSourceCollectionName, e);\n      }\n    }\n\n    CompositeIdRouter sourceRouter = (CompositeIdRouter) sourceCollection.getRouter();\n    DocRouter.Range keyHashRange = sourceRouter.keyHashRange(splitKey);\n\n    ShardHandlerFactory shardHandlerFactory = ocmh.shardHandlerFactory;\n    ShardHandler shardHandler = shardHandlerFactory.getShardHandler();\n\n    log.info(\"Hash range for split.key: {} is: {}\", splitKey, keyHashRange);\n    // intersect source range, keyHashRange and target range\n    // this is the range that has to be split from source and transferred to target\n    DocRouter.Range splitRange = ocmh.intersect(targetSlice.getRange(), ocmh.intersect(sourceSlice.getRange(), keyHashRange));\n    if (splitRange == null) {\n      if (log.isInfoEnabled()) {\n        log.info(\"No common hashes between source shard: {} and target shard: {}\", sourceSlice.getName(), targetSlice.getName());\n      }\n      return;\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Common hash range between source shard: {} and target shard: {} = {}\", sourceSlice.getName(), targetSlice.getName(), splitRange);\n    }\n\n    Replica targetLeader = zkStateReader.getLeaderRetry(targetCollection.getName(), targetSlice.getName(), 10000);\n\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking target leader node: {} core: {} to buffer updates\"\n          , targetLeader.getNodeName(), targetLeader.getStr(\"core\"));\n    }\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTBUFFERUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to buffer updates\");\n    }\n    ZkNodeProps m = new ZkNodeProps(\n        Overseer.QUEUE_OPERATION, OverseerAction.ADDROUTINGRULE.toLower(),\n        COLLECTION_PROP, sourceCollection.getName(),\n        SHARD_ID_PROP, sourceSlice.getName(),\n        \"routeKey\", SolrIndexSplitter.getRouteKey(splitKey) + \"!\",\n        \"range\", splitRange.toString(),\n        \"targetCollection\", targetCollection.getName(),\n        \"expireAt\", RoutingRule.makeExpiryAt(timeout));\n    log.info(\"Adding routing rule: {}\", m);\n    ocmh.overseer.offerStateUpdate(Utils.toJSON(m));\n\n    // wait for a while until we see the new rule\n    log.info(\"Waiting to see routing rule updated in clusterstate\");\n    TimeOut waitUntil = new TimeOut(60, TimeUnit.SECONDS, timeSource);\n    boolean added = false;\n    while (!waitUntil.hasTimedOut()) {\n      waitUntil.sleep(100);\n      sourceCollection = zkStateReader.getClusterState().getCollection(sourceCollection.getName());\n      sourceSlice = sourceCollection.getSlice(sourceSlice.getName());\n      Map<String, RoutingRule> rules = sourceSlice.getRoutingRules();\n      if (rules != null) {\n        RoutingRule rule = rules.get(SolrIndexSplitter.getRouteKey(splitKey) + \"!\");\n        if (rule != null && rule.getRouteRanges().contains(splitRange)) {\n          added = true;\n          break;\n        }\n      }\n    }\n    if (!added) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Could not add routing rule: \" + m);\n    }\n\n    log.info(\"Routing rule added successfully\");\n\n    // Create temp core on source shard\n    Replica sourceLeader = zkStateReader.getLeaderRetry(sourceCollection.getName(), sourceSlice.getName(), 10000);\n\n    // create a temporary collection with just one node on the shard leader\n    String configName = zkStateReader.readConfigName(sourceCollection.getName());\n    Map<String, Object> props = makeMap(\n        Overseer.QUEUE_OPERATION, CREATE.toLower(),\n        NAME, tempSourceCollectionName,\n        NRT_REPLICAS, 1,\n        OverseerCollectionMessageHandler.NUM_SLICES, 1,\n        CollectionAdminParams.COLL_CONF, configName,\n        OverseerCollectionMessageHandler.CREATE_NODE_SET, sourceLeader.getNodeName());\n    if (asyncId != null) {\n      String internalAsyncId = asyncId + Math.abs(System.nanoTime());\n      props.put(ASYNC, internalAsyncId);\n    }\n\n    log.info(\"Creating temporary collection: {}\", props);\n    ocmh.commandMap.get(CREATE).call(clusterState, cloudConfig, new ZkNodeProps(props), results);\n    // refresh cluster state\n    clusterState = zkStateReader.getClusterState();\n    Slice tempSourceSlice = clusterState.getCollection(tempSourceCollectionName).getSlices().iterator().next();\n    Replica tempSourceLeader = zkStateReader.getLeaderRetry(tempSourceCollectionName, tempSourceSlice.getName(), 120000);\n\n    String tempCollectionReplica1 = tempSourceLeader.getCoreName();\n    String coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        sourceLeader.getNodeName(), tempCollectionReplica1);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking source leader to wait for: {} to be alive on: {}\", tempCollectionReplica1, sourceLeader.getNodeName());\n    }\n    CoreAdminRequest.WaitForState cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempCollectionReplica1);\n    cmd.setNodeName(sourceLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      // we don't want this to happen asynchronously\n      syncRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), new ModifiableSolrParams(cmd.getParams()),\n          shardHandler);\n\n      syncRequestTracker.processResponses(results, shardHandler, true,\n          \"MIGRATE failed to create temp collection leader\" +\n              \" or timed out waiting for it to come up\");\n    }\n    \n    log.info(\"Asking source leader to split index\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.SPLIT.toString());\n    params.set(CoreAdminParams.CORE, sourceLeader.getStr(\"core\"));\n    params.add(CoreAdminParams.TARGET_CORE, tempSourceLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.RANGES, splitRange.toString());\n    params.set(\"split.key\", splitKey);\n\n    String tempNodeName = sourceLeader.getNodeName();\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempNodeName, params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to invoke SPLIT core admin command\");\n    }\n    if (log.isInfoEnabled()) {\n      log.info(\"Creating a replica of temporary collection: {} on the target leader node: {}\",\n          tempSourceCollectionName, targetLeader.getNodeName());\n    }\n    String tempCollectionReplica2 = Assign.buildSolrCoreName(ocmh.overseer.getSolrCloudManager().getDistribStateManager(),\n        zkStateReader.getClusterState().getCollection(tempSourceCollectionName), tempSourceSlice.getName(), Replica.Type.NRT);\n    props = new HashMap<>();\n    props.put(Overseer.QUEUE_OPERATION, ADDREPLICA.toLower());\n    props.put(COLLECTION_PROP, tempSourceCollectionName);\n    props.put(SHARD_ID_PROP, tempSourceSlice.getName());\n    props.put(\"node\", targetLeader.getNodeName());\n    props.put(CoreAdminParams.NAME, tempCollectionReplica2);\n    // copy over property params:\n    for (String key : message.keySet()) {\n      if (key.startsWith(OverseerCollectionMessageHandler.COLL_PROP_PREFIX)) {\n        props.put(key, message.getStr(key));\n      }\n    }\n    // add async param\n    if (asyncId != null) {\n      props.put(ASYNC, asyncId);\n    }\n    ((AddReplicaCmd)ocmh.commandMap.get(ADDREPLICA)).addReplica(clusterState, cloudConfig, new ZkNodeProps(props), results, null);\n\n    {\n      final ShardRequestTracker syncRequestTracker = ocmh.syncRequestTracker();\n      syncRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create replica of \" +\n        \"temporary collection in target leader node.\");\n    }\n    coreNodeName = ocmh.waitForCoreNodeName(tempSourceCollectionName,\n        targetLeader.getNodeName(), tempCollectionReplica2);\n    // wait for the replicas to be seen as active on temp source leader\n    if (log.isInfoEnabled()) {\n      log.info(\"Asking temp source leader to wait for: {} to be alive on: {}\", tempCollectionReplica2, targetLeader.getNodeName());\n    }\n    cmd = new CoreAdminRequest.WaitForState();\n    cmd.setCoreName(tempSourceLeader.getStr(\"core\"));\n    cmd.setNodeName(targetLeader.getNodeName());\n    cmd.setCoreNodeName(coreNodeName);\n    cmd.setState(Replica.State.ACTIVE);\n    cmd.setCheckLive(true);\n    cmd.setOnlyIfLeader(true);\n    params = new ModifiableSolrParams(cmd.getParams());\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(tempSourceLeader.getNodeName(), params, shardHandler);\n\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to create temp collection\" +\n        \" replica or timed out waiting for them to come up\");\n    }\n    log.info(\"Successfully created replica of temp source collection on target leader node\");\n\n    log.info(\"Requesting merge of temp source collection replica to target leader\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.MERGEINDEXES.toString());\n    params.set(CoreAdminParams.CORE, targetLeader.getStr(\"core\"));\n    params.set(CoreAdminParams.SRC_CORE, tempCollectionReplica2);\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n    \n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n    String msg = \"MIGRATE failed to merge \" + tempCollectionReplica2 + \" to \"\n        + targetLeader.getStr(\"core\") + \" on node: \" + targetLeader.getNodeName();\n    shardRequestTracker.processResponses(results, shardHandler, true, msg);\n    }\n    log.info(\"Asking target leader to apply buffered updates\");\n    params = new ModifiableSolrParams();\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.REQUESTAPPLYUPDATES.toString());\n    params.set(CoreAdminParams.NAME, targetLeader.getStr(\"core\"));\n\n    {\n      final ShardRequestTracker shardRequestTracker = ocmh.asyncRequestTracker(asyncId);\n      shardRequestTracker.sendShardRequest(targetLeader.getNodeName(), params, shardHandler);\n      shardRequestTracker.processResponses(results, shardHandler, true, \"MIGRATE failed to request node to apply buffered updates\");\n    }\n    try {\n      log.info(\"Deleting temporary collection: {}\", tempSourceCollectionName);\n      props = makeMap(\n          Overseer.QUEUE_OPERATION, DELETE.toLower(),\n          NAME, tempSourceCollectionName);\n      ocmh.commandMap.get(DELETE). call(zkStateReader.getClusterState(), cloudConfig, new ZkNodeProps(props), results);\n    } catch (Exception e) {\n      log.error(\"Unable to delete temporary collection: {}. Please remove it manually\", tempSourceCollectionName, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"c526352db87264a72a7a9ad68c1b769b81e54305":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["82b686ab2904b3e81184ecea0d238b4ab0885376"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"82b686ab2904b3e81184ecea0d238b4ab0885376":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4abf821a41a2fdca2a1dea148999931d22e20529":["69e6520a21709190413a63084ed135271aab1a7c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["b94236357aaa22b76c10629851fe4e376e0cea82","82b686ab2904b3e81184ecea0d238b4ab0885376"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"69e6520a21709190413a63084ed135271aab1a7c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["b94236357aaa22b76c10629851fe4e376e0cea82","82b686ab2904b3e81184ecea0d238b4ab0885376"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b94236357aaa22b76c10629851fe4e376e0cea82":["82b686ab2904b3e81184ecea0d238b4ab0885376","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"1964c059f45ae1de1877f9f0fe3ca327ea4218e8":["c526352db87264a72a7a9ad68c1b769b81e54305"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["69e6520a21709190413a63084ed135271aab1a7c"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"82b686ab2904b3e81184ecea0d238b4ab0885376":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4abf821a41a2fdca2a1dea148999931d22e20529":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["1964c059f45ae1de1877f9f0fe3ca327ea4218e8"],"69e6520a21709190413a63084ed135271aab1a7c":["4abf821a41a2fdca2a1dea148999931d22e20529"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}