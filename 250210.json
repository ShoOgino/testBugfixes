{"path":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","commits":[{"id":"172cf08877d0e6738a51edd238c4dc5ffc088345","date":1342794823,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","pathOld":"/dev/null","sourceNew":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","sourceNew":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) {\n        if (!hasPos) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","sourceOld":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"322360ac5185a8446d3e0b530b2068bef67cd3d5","date":1343669494,"type":6,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","sourceNew":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, int flags) {\n        if (!hasPos) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","sourceOld":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","sourceNew":null,"sourceOld":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":4,"author":"Uwe Schindler","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/memory/DirectPostingsFormat.DirectField.DirectIntersectTermsEnum#docsAndPositions(Bits,DocsAndPositionsEnum,boolean).mjava","sourceNew":null,"sourceOld":"      @Override\n      public DocsAndPositionsEnum docsAndPositions(Bits liveDocs, DocsAndPositionsEnum reuse, boolean needsOffsets) {\n        if (!hasPos) {\n          return null;\n        }\n        if (needsOffsets && !hasOffsets) {\n          return null;\n        }\n\n        // TODO: implement reuse, something like Pulsing:\n        // it's hairy!\n\n        if (terms[termOrd] instanceof LowFreqTerm) {\n          final LowFreqTerm term = ((LowFreqTerm) terms[termOrd]);\n          final int[] postings = term.postings;\n          final byte[] payloads = term.payloads;\n          return new LowFreqDocsAndPositionsEnum(liveDocs, hasOffsets, hasPayloads).reset(postings, payloads);\n        } else {\n          final HighFreqTerm term = (HighFreqTerm) terms[termOrd];\n          return new HighFreqDocsAndPositionsEnum(liveDocs, hasOffsets).reset(term.docIDs, term.freqs, term.positions, term.payloads);\n        }\n      }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","172cf08877d0e6738a51edd238c4dc5ffc088345"],"172cf08877d0e6738a51edd238c4dc5ffc088345":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","172cf08877d0e6738a51edd238c4dc5ffc088345"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["172cf08877d0e6738a51edd238c4dc5ffc088345"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["322360ac5185a8446d3e0b530b2068bef67cd3d5"]},"commit2Childs":{"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["aba371508186796cc6151d8223a5b4e16d02e26e","172cf08877d0e6738a51edd238c4dc5ffc088345","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"172cf08877d0e6738a51edd238c4dc5ffc088345":["aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","322360ac5185a8446d3e0b530b2068bef67cd3d5"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"322360ac5185a8446d3e0b530b2068bef67cd3d5":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}