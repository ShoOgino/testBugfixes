{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","commits":[{"id":"e50f0da93c6dcee20d8792637b1786e2c34975e9","date":1400182475,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"/dev/null","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.sizeInBytes();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term);\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.length = 0;\n\n    return stats;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["8405d98acebb7e287bf7ac40e937ba05b8661285","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"/dev/null","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.sizeInBytes();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term);\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.length = 0;\n\n    return stats;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8405d98acebb7e287bf7ac40e937ba05b8661285","date":1401433291,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term);\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.length = 0;\n\n    return stats;\n  }\n\n","sourceOld":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.sizeInBytes();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term);\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.length = 0;\n\n    return stats;\n  }\n\n","bugFix":["e50f0da93c6dcee20d8792637b1786e2c34975e9"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","sourceOld":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length);\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term);\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.length = 0;\n\n    return stats;\n  }\n\n","bugFix":["e50f0da93c6dcee20d8792637b1786e2c34975e9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    // TODO: add total auto-prefix term count\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          // Advance to next floor block\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n          break;\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","sourceOld":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    // TODO: add total auto-prefix term count\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          // Advance to next floor block\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n          break;\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","sourceOld":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.isFloor = false;\n          //currentFrame.hasTerms = true;\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1abb939fb41b2fe4f89fd518f3da288c0213341d","date":1435657417,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    // TODO: add total auto-prefix term count\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          // Advance to next floor block\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n          break;\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","sourceOld":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    // TODO: add total auto-prefix term count\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNodeCount = fr.index.getNodeCount();\n      stats.indexArcCount = fr.index.getArcCount();\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          // Advance to next floor block\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n          break;\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dd96a930cc08d72beee719cc11ce465b9d9861c3","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnum#computeBlockStats().mjava","sourceNew":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          // Advance to next floor block\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n          break;\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","sourceOld":"  /** Runs next() through the entire terms dict,\n   *  computing aggregate statistics. */\n  public Stats computeBlockStats() throws IOException {\n\n    // TODO: add total auto-prefix term count\n\n    Stats stats = new Stats(fr.parent.segment, fr.fieldInfo.name);\n    if (fr.index != null) {\n      stats.indexNumBytes = fr.index.ramBytesUsed();\n    }\n        \n    currentFrame = staticFrame;\n    FST.Arc<BytesRef> arc;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n\n    // Empty string prefix must have an output in the\n    // index!\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.fpOrig = currentFrame.fp;\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n\n    stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n\n    allTerms:\n    while (true) {\n\n      // Pop finished blocks\n      while (currentFrame.nextEnt == currentFrame.entCount) {\n        stats.endBlock(currentFrame);\n        if (!currentFrame.isLastInFloor) {\n          // Advance to next floor block\n          currentFrame.loadNextFloorBlock();\n          stats.startBlock(currentFrame, true);\n          break;\n        } else {\n          if (currentFrame.ord == 0) {\n            break allTerms;\n          }\n          final long lastFP = currentFrame.fpOrig;\n          currentFrame = stack[currentFrame.ord-1];\n          assert lastFP == currentFrame.lastSubFP;\n          // if (DEBUG) {\n          //   System.out.println(\"  reset validIndexPrefix=\" + validIndexPrefix);\n          // }\n        }\n      }\n\n      while(true) {\n        if (currentFrame.next()) {\n          // Push to new block:\n          currentFrame = pushFrame(null, currentFrame.lastSubFP, term.length());\n          currentFrame.fpOrig = currentFrame.fp;\n          // This is a \"next\" frame -- even if it's\n          // floor'd we must pretend it isn't so we don't\n          // try to scan to the right floor frame:\n          currentFrame.loadBlock();\n          stats.startBlock(currentFrame, !currentFrame.isLastInFloor);\n        } else {\n          stats.term(term.get());\n          break;\n        }\n      }\n    }\n\n    stats.finish();\n\n    // Put root frame back:\n    currentFrame = staticFrame;\n    if (fr.index != null) {\n      arc = fr.index.getFirstArc(arcs[0]);\n      // Empty string prefix must have an output in the index!\n      assert arc.isFinal();\n    } else {\n      arc = null;\n    }\n    currentFrame = pushFrame(arc, fr.rootCode, 0);\n    currentFrame.rewind();\n    currentFrame.loadBlock();\n    validIndexPrefix = 0;\n    term.clear();\n\n    return stats;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["3e8715d826e588419327562287d5d6a8040d63d6"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e50f0da93c6dcee20d8792637b1786e2c34975e9"],"e50f0da93c6dcee20d8792637b1786e2c34975e9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["1abb939fb41b2fe4f89fd518f3da288c0213341d"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","3e8715d826e588419327562287d5d6a8040d63d6"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"3e8715d826e588419327562287d5d6a8040d63d6":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["dd96a930cc08d72beee719cc11ce465b9d9861c3"]},"commit2Childs":{"1abb939fb41b2fe4f89fd518f3da288c0213341d":["dd96a930cc08d72beee719cc11ce465b9d9861c3"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["8405d98acebb7e287bf7ac40e937ba05b8661285"],"e50f0da93c6dcee20d8792637b1786e2c34975e9":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"dd96a930cc08d72beee719cc11ce465b9d9861c3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"8405d98acebb7e287bf7ac40e937ba05b8661285":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4d637064d608752565d4f9f41b2497dfdfdde50e","e50f0da93c6dcee20d8792637b1786e2c34975e9"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"3e8715d826e588419327562287d5d6a8040d63d6":["1abb939fb41b2fe4f89fd518f3da288c0213341d","d2638f781be724518ff6c2263d14a48cf6e68017"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}