{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","commits":[{"id":"1f6b20dc453cee198956989b90aa24bef0232bcf","date":1498221066,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext actionContext) {\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"467b33453dfbb7b9a5e2388723dc92cc4d7f830a","date":1499159523,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = operation.process(cloudSolrClient);\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(response.getResponse());\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext actionContext) {\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac","date":1503580177,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    ClusterDataProvider clusterDataProvider = context.getClusterDataProvider();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = clusterDataProvider.request(operation);\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(response.getResponse());\n            return responses;\n          });\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = operation.process(cloudSolrClient);\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(response.getResponse());\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b869898f50ca80263bac2e3ae0949f7700e5c977","date":1503580229,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = operation.process(cloudSolrClient);\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(response.getResponse());\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    ClusterDataProvider clusterDataProvider = context.getClusterDataProvider();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = clusterDataProvider.request(operation);\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(response.getResponse());\n            return responses;\n          });\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8cffee0b9c10b78bd087c71485b482217fe84f","date":1505950827,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    SolrZkClient zkClient = container.getZkController().getZkClient();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(event, context, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            asyncId = req.processAsync(asyncId, cloudSolrClient);\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudSolrClient, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  zkClient.delete(znode, -1, true);\n                } catch (KeeperException e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = operation.process(cloudSolrClient);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (KeeperException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n        }\n\n        counter++;\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = operation.process(cloudSolrClient);\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(response.getResponse());\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["39561034e67ea008831f095a2f7be7fcdbd37f53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c304e97e7c1d472bc70e801b35ee78583916c6cd","date":1507105431,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    SolrZkClient zkClient = container.getZkController().getZkClient();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(event, context, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            asyncId = req.processAsync(asyncId, cloudSolrClient);\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudSolrClient, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  zkClient.delete(znode, -1, true);\n                } catch (KeeperException e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = operation.process(cloudSolrClient);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (KeeperException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n        }\n\n        counter++;\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"560c18d71dad43d675158783c3840f8c80d6d39c","date":1507105532,"type":0,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    SolrZkClient zkClient = container.getZkController().getZkClient();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(event, context, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            asyncId = req.processAsync(asyncId, cloudSolrClient);\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudSolrClient, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  zkClient.delete(znode, -1, true);\n                } catch (KeeperException e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = operation.process(cloudSolrClient);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (KeeperException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n        }\n\n        counter++;\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85212dad4ed576c7f7e6c165ee19e597b7b4efc8","date":1507997740,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager dataProvider = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(dataProvider.getDistribStateManager(), event, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = dataProvider.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(dataProvider, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  dataProvider.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = dataProvider.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n//        } catch (InterruptedException e) {\n//          Thread.currentThread().interrupt();\n//          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n\n//        counter++;\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    CoreContainer container = context.getCoreContainer();\n    SolrZkClient zkClient = container.getZkController().getZkClient();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try (CloudSolrClient cloudSolrClient = new CloudSolrClient.Builder()\n        .withZkHost(container.getZkController().getZkServerAddress())\n        .withHttpClient(container.getUpdateShardHandler().getHttpClient())\n        .build()) {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(event, context, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            asyncId = req.processAsync(asyncId, cloudSolrClient);\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudSolrClient, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  zkClient.delete(znode, -1, true);\n                } catch (KeeperException e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = operation.process(cloudSolrClient);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (SolrServerException | HttpSolrClient.RemoteSolrException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (KeeperException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n        }\n\n        counter++;\n      }\n    } catch (IOException e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["39561034e67ea008831f095a2f7be7fcdbd37f53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"67e503ef0f418bc92404ff5d55694087c23d48eb","date":1509025368,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager dataProvider = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(dataProvider.getDistribStateManager(), event, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = dataProvider.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(dataProvider, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  dataProvider.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = dataProvider.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n//        } catch (InterruptedException e) {\n//          Thread.currentThread().interrupt();\n//          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n\n//        counter++;\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager dataProvider = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(dataProvider.getDistribStateManager(), event, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = dataProvider.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(dataProvider, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  dataProvider.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = dataProvider.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n//        } catch (InterruptedException e) {\n//          Thread.currentThread().interrupt();\n//          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n\n//        counter++;\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected IOException while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1","date":1513252583,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = cloudManager.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager dataProvider = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.info(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(dataProvider.getDistribStateManager(), event, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = dataProvider.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(dataProvider, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  dataProvider.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = dataProvider.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Unable to talk to ZooKeeper\", e);\n//        } catch (InterruptedException e) {\n//          Thread.currentThread().interrupt();\n//          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n\n//        counter++;\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":["39561034e67ea008831f095a2f7be7fcdbd37f53"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a4422b331d00607258b0ed3e43934306e67764aa","date":1513943901,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = cloudManager.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.debug(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = cloudManager.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"39561034e67ea008831f095a2f7be7fcdbd37f53","date":1570744746,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = cloudManager.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8","5b8cffee0b9c10b78bd087c71485b482217fe84f","1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          int counter = 0;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            SolrResponse asyncResponse = cloudManager.request(req);\n            if (asyncResponse.getResponse().get(\"error\") != null) {\n              throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n            }\n            asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n            CollectionAdminRequest.RequestStatusResponse statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                DEFAULT_TASK_TIMEOUT_SECONDS, TimeUnit.SECONDS);\n            if (statusResponse != null) {\n              RequestStatusState state = statusResponse.getRequestStatus();\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n          } else {\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    if (log.isDebugEnabled()) {\n      log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    }\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Executing operation: {}\", operation.getParams());\n        }\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        log.debug(\"Executing operation: {}\", operation.getParams());\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: \" + znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    if (log.isDebugEnabled()) {\n      log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    }\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Executing operation: {}\", operation.getParams());\n        }\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            @SuppressWarnings({\"unchecked\"})\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    if (log.isDebugEnabled()) {\n      log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    }\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Executing operation: {}\", operation.getParams());\n        }\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/ExecutePlanAction#process(TriggerEvent,ActionContext).mjava","sourceNew":null,"sourceOld":"  @Override\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public void process(TriggerEvent event, ActionContext context) throws Exception {\n    if (log.isDebugEnabled()) {\n      log.debug(\"-- processing event: {} with context properties: {}\", event, context.getProperties());\n    }\n    SolrCloudManager cloudManager = context.getCloudManager();\n    List<SolrRequest> operations = (List<SolrRequest>) context.getProperty(\"operations\");\n    if (operations == null || operations.isEmpty()) {\n      log.info(\"No operations to execute for event: {}\", event);\n      return;\n    }\n    try {\n      int counter = 0;\n      for (SolrRequest operation : operations) {\n        if (log.isDebugEnabled()) {\n          log.debug(\"Executing operation: {}\", operation.getParams());\n        }\n        try {\n          SolrResponse response = null;\n          if (operation instanceof CollectionAdminRequest.AsyncCollectionAdminRequest) {\n            CollectionAdminRequest.AsyncCollectionAdminRequest req = (CollectionAdminRequest.AsyncCollectionAdminRequest) operation;\n            // waitForFinalState so that the end effects of operations are visible\n            req.setWaitForFinalState(true);\n            String asyncId = event.getSource() + '/' + event.getId() + '/' + counter;\n            String znode = saveAsyncId(cloudManager.getDistribStateManager(), event, asyncId);\n            log.trace(\"Saved requestId: {} in znode: {}\", asyncId, znode);\n            // TODO: find a better way of using async calls using dataProvider API !!!\n            req.setAsyncId(asyncId);\n            if (TestInjection.delayInExecutePlanAction != null) {\n              cloudManager.getTimeSource().sleep(TestInjection.delayInExecutePlanAction);\n            }\n            CollectionAdminRequest.RequestStatusResponse statusResponse = null;\n            RequestStatusState state = RequestStatusState.FAILED;\n            if (!TestInjection.failInExecutePlanAction) {\n              SolrResponse asyncResponse = cloudManager.request(req);\n              if (asyncResponse.getResponse().get(\"error\") != null) {\n                throw new IOException(\"\" + asyncResponse.getResponse().get(\"error\"));\n              }\n              asyncId = (String)asyncResponse.getResponse().get(\"requestid\");\n              statusResponse = waitForTaskToFinish(cloudManager, asyncId,\n                  taskTimeoutSeconds, TimeUnit.SECONDS);\n            }\n            if (statusResponse != null) {\n              state = statusResponse.getRequestStatus();\n              // overwrite to test a long-running task\n              if (TestInjection.delayInExecutePlanAction != null &&\n                  TestInjection.delayInExecutePlanAction > TimeUnit.MILLISECONDS.convert(taskTimeoutSeconds, TimeUnit.SECONDS)) {\n                state = RequestStatusState.RUNNING;\n              }\n              if (TestInjection.failInExecutePlanAction) {\n                state = RequestStatusState.FAILED;\n              }\n              // should we accept partial success here? i.e. some operations won't be completed\n              // successfully but the event processing will still be declared a success\n              if (state == RequestStatusState.COMPLETED || state == RequestStatusState.FAILED || state == RequestStatusState.NOT_FOUND) {\n                // remove pending task marker for this request\n                try {\n                  cloudManager.getDistribStateManager().removeData(znode, -1);\n                } catch (Exception e) {\n                  log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n                }\n              }\n              response = statusResponse;\n            }\n            if (state == RequestStatusState.RUNNING || state == RequestStatusState.SUBMITTED) {\n              String msg = String.format(Locale.ROOT, \"Task %s is still running after \" + taskTimeoutSeconds + \" seconds. Consider increasing \" +\n                      TASK_TIMEOUT_SECONDS + \" action property or `waitFor` of the trigger %s. Operation: %s\",\n                  asyncId, event.source, req);\n              if (taskTimeoutFail) {\n                throw new IOException(msg);\n              } else {\n                log.warn(msg);\n              }\n            } else if (state == RequestStatusState.FAILED) {\n              // remove it as a pending task\n              try {\n                cloudManager.getDistribStateManager().removeData(znode, -1);\n              } catch (Exception e) {\n                log.warn(\"Unexpected exception while trying to delete znode: {}\", znode, e);\n              }\n              throw new IOException(\"Task \" + asyncId + \" failed: \" + (statusResponse != null ? statusResponse : \" timed out. Operation: \" + req));\n            }\n          } else {\n            // generic response - can't easily determine success or failure\n            response = cloudManager.request(operation);\n          }\n          NamedList<Object> result = response.getResponse();\n          context.getProperties().compute(\"responses\", (s, o) -> {\n            @SuppressWarnings({\"unchecked\"})\n            List<NamedList<Object>> responses = (List<NamedList<Object>>) o;\n            if (responses == null)  responses = new ArrayList<>(operations.size());\n            responses.add(result);\n            return responses;\n          });\n          counter++;\n        } catch (IOException e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        } catch (InterruptedException e) {\n          Thread.currentThread().interrupt();\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"ExecutePlanAction was interrupted\", e);\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n              \"Unexpected exception executing operation: \" + operation.getParams(), e);\n        }\n      }\n    } catch (Exception e) {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unexpected exception while processing event: \" + event, e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5b8cffee0b9c10b78bd087c71485b482217fe84f"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["467b33453dfbb7b9a5e2388723dc92cc4d7f830a"],"3f504512a03d978990cbff30db0522b354e846db":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["560c18d71dad43d675158783c3840f8c80d6d39c"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"467b33453dfbb7b9a5e2388723dc92cc4d7f830a":["1f6b20dc453cee198956989b90aa24bef0232bcf"],"39561034e67ea008831f095a2f7be7fcdbd37f53":["a4422b331d00607258b0ed3e43934306e67764aa"],"67e503ef0f418bc92404ff5d55694087c23d48eb":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["e35f2dde06b35aa9904949a3a93fabd090371077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"a4422b331d00607258b0ed3e43934306e67764aa":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"e35f2dde06b35aa9904949a3a93fabd090371077":["39561034e67ea008831f095a2f7be7fcdbd37f53"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"560c18d71dad43d675158783c3840f8c80d6d39c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c304e97e7c1d472bc70e801b35ee78583916c6cd"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"b0b597c65628ca9e73913a07e81691f8229bae35":["a4422b331d00607258b0ed3e43934306e67764aa","39561034e67ea008831f095a2f7be7fcdbd37f53"]},"commit2Childs":{"c304e97e7c1d472bc70e801b35ee78583916c6cd":["560c18d71dad43d675158783c3840f8c80d6d39c"],"c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac":["b869898f50ca80263bac2e3ae0949f7700e5c977"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"85212dad4ed576c7f7e6c165ee19e597b7b4efc8":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"b869898f50ca80263bac2e3ae0949f7700e5c977":["5b8cffee0b9c10b78bd087c71485b482217fe84f"],"467b33453dfbb7b9a5e2388723dc92cc4d7f830a":["c7ff8a6fbdc9c2d84bc6e9e71e1c738e49c441ac"],"39561034e67ea008831f095a2f7be7fcdbd37f53":["e35f2dde06b35aa9904949a3a93fabd090371077","b0b597c65628ca9e73913a07e81691f8229bae35"],"67e503ef0f418bc92404ff5d55694087c23d48eb":["1d4bf9d5308dfef350829c28f2b3b2648df1e9b1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c304e97e7c1d472bc70e801b35ee78583916c6cd","560c18d71dad43d675158783c3840f8c80d6d39c","1f6b20dc453cee198956989b90aa24bef0232bcf"],"5b8cffee0b9c10b78bd087c71485b482217fe84f":["c304e97e7c1d472bc70e801b35ee78583916c6cd"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["3f504512a03d978990cbff30db0522b354e846db"],"a4422b331d00607258b0ed3e43934306e67764aa":["39561034e67ea008831f095a2f7be7fcdbd37f53","b0b597c65628ca9e73913a07e81691f8229bae35"],"e35f2dde06b35aa9904949a3a93fabd090371077":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"1d4bf9d5308dfef350829c28f2b3b2648df1e9b1":["a4422b331d00607258b0ed3e43934306e67764aa"],"560c18d71dad43d675158783c3840f8c80d6d39c":["85212dad4ed576c7f7e6c165ee19e597b7b4efc8"],"1f6b20dc453cee198956989b90aa24bef0232bcf":["467b33453dfbb7b9a5e2388723dc92cc4d7f830a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}