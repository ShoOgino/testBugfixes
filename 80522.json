{"path":"solr/core/src/java/org/apache/solr/cloud/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"424ac616f0aeeb2a3c8b6b94084255a0bcab9628","date":1477057622,"type":0,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = this.ocmh.overseer.getZkController().getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["69e6520a21709190413a63084ed135271aab1a7c","69e6520a21709190413a63084ed135271aab1a7c","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = this.ocmh.overseer.getZkController().getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = ocmh.zkStateReader.getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = this.ocmh.overseer.getZkController().getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":4,"author":"Karl Wright","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/CreateSnapshotCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    String collectionName =  message.getStr(COLLECTION_PROP);\n    String commitName =  message.getStr(CoreAdminParams.COMMIT_NAME);\n    String asyncId = message.getStr(ASYNC);\n    SolrZkClient zkClient = this.ocmh.overseer.getZkController().getZkClient();\n    Date creationDate = new Date();\n\n    if(SolrSnapshotManager.snapshotExists(zkClient, collectionName, commitName)) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"Snapshot with name \" + commitName\n          + \" already exists for collection \" + collectionName);\n    }\n\n    log.info(\"Creating a snapshot for collection={} with commitName={}\", collectionName, commitName);\n\n    // Create a node in ZK to store the collection level snapshot meta-data.\n    SolrSnapshotManager.createCollectionLevelSnapshot(zkClient, collectionName, new CollectionSnapshotMetaData(commitName));\n    log.info(\"Created a ZK path to store snapshot information for collection={} with commitName={}\", collectionName, commitName);\n\n    Map<String, String> requestMap = new HashMap<>();\n    NamedList shardRequestResults = new NamedList();\n    Map<String, Slice> shardByCoreName = new HashMap<>();\n    ShardHandler shardHandler = ocmh.shardHandlerFactory.getShardHandler();\n\n    for (Slice slice : ocmh.zkStateReader.getClusterState().getCollection(collectionName).getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        if (replica.getState() != State.ACTIVE) {\n          log.info(\"Replica {} is not active. Hence not sending the createsnapshot request\", replica.getCoreName());\n          continue; // Since replica is not active - no point sending a request.\n        }\n\n        String coreName = replica.getStr(CORE_NAME_PROP);\n\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.set(CoreAdminParams.ACTION, CoreAdminAction.CREATESNAPSHOT.toString());\n        params.set(NAME, slice.getName());\n        params.set(CORE_NAME_PROP, coreName);\n        params.set(CoreAdminParams.COMMIT_NAME, commitName);\n\n        ocmh.sendShardRequest(replica.getNodeName(), params, shardHandler, asyncId, requestMap);\n        log.debug(\"Sent createsnapshot request to core={} with commitName={}\", coreName, commitName);\n\n        shardByCoreName.put(coreName, slice);\n      }\n    }\n\n    // At this point we want to make sure that at-least one replica for every shard\n    // is able to create the snapshot. If that is not the case, then we fail the request.\n    // This is to take care of the situation where e.g. entire shard is unavailable.\n    Set<String> failedShards = new HashSet<>();\n\n    ocmh.processResponses(shardRequestResults, shardHandler, false, null, asyncId, requestMap);\n    NamedList success = (NamedList) shardRequestResults.get(\"success\");\n    List<CoreSnapshotMetaData> replicas = new ArrayList<>();\n    if (success != null) {\n      for ( int i = 0 ; i < success.size() ; i++) {\n        NamedList resp = (NamedList)success.getVal(i);\n\n        // Check if this core is the leader for the shard. The idea here is that during the backup\n        // operation we preferably use the snapshot of the \"leader\" replica since it is most likely\n        // to have latest state.\n        String coreName = (String)resp.get(CoreAdminParams.CORE);\n        Slice slice = shardByCoreName.remove(coreName);\n        boolean leader = (slice.getLeader() != null && slice.getLeader().getCoreName().equals(coreName));\n        resp.add(SolrSnapshotManager.SHARD_ID, slice.getName());\n        resp.add(SolrSnapshotManager.LEADER, leader);\n\n        CoreSnapshotMetaData c = new CoreSnapshotMetaData(resp);\n        replicas.add(c);\n        log.info(\"Snapshot with commitName {} is created successfully for core {}\", commitName, c.getCoreName());\n      }\n    }\n\n    if (!shardByCoreName.isEmpty()) { // One or more failures.\n      log.warn(\"Unable to create a snapshot with name {} for following cores {}\", commitName, shardByCoreName.keySet());\n\n      // Count number of failures per shard.\n      Map<String, Integer> failuresByShardId = new HashMap<>();\n      for (Map.Entry<String,Slice> entry : shardByCoreName.entrySet()) {\n        int f = 0;\n        if (failuresByShardId.get(entry.getValue().getName()) != null) {\n          f = failuresByShardId.get(entry.getValue().getName());\n        }\n        failuresByShardId.put(entry.getValue().getName(), f + 1);\n      }\n\n      // Now that we know number of failures per shard, we can figure out\n      // if at-least one replica per shard was able to create a snapshot or not.\n      DocCollection collectionStatus = ocmh.zkStateReader.getClusterState().getCollection(collectionName);\n      for (Map.Entry<String,Integer> entry : failuresByShardId.entrySet()) {\n        int replicaCount = collectionStatus.getSlice(entry.getKey()).getReplicas().size();\n        if (replicaCount <= entry.getValue()) {\n          failedShards.add(entry.getKey());\n        }\n      }\n    }\n\n    if (failedShards.isEmpty()) { // No failures.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Successful, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n    } else {\n      log.warn(\"Failed to create a snapshot for collection {} with commitName = {}. Snapshot could not be captured for following shards {}\",\n          collectionName, commitName, failedShards);\n      // Update the ZK meta-data to include only cores with the snapshot. This will enable users to figure out\n      // which cores have the named snapshot.\n      CollectionSnapshotMetaData meta = new CollectionSnapshotMetaData(commitName, SnapshotStatus.Failed, creationDate, replicas);\n      SolrSnapshotManager.updateCollectionLevelSnapshot(zkClient, collectionName, meta);\n      log.info(\"Saved following snapshot information for collection={} with commitName={} in Zookeeper : {}\", collectionName,\n          commitName, meta.toNamedList());\n      throw new SolrException(ErrorCode.SERVER_ERROR, \"Failed to create snapshot on shards \" + failedShards);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"424ac616f0aeeb2a3c8b6b94084255a0bcab9628":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","424ac616f0aeeb2a3c8b6b94084255a0bcab9628"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"424ac616f0aeeb2a3c8b6b94084255a0bcab9628":["b94236357aaa22b76c10629851fe4e376e0cea82","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}