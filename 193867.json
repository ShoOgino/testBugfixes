{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","commits":[{"id":"278394e71c5c3727ff5225bafdde73d7454d0012","date":1458392644,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[]).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads = TestUtil.nextInt(random(), 2, 5);\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            startingGun.await();\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      thread.start();\n      threads.add(thread);\n    }\n    startingGun.countDown();\n    for(Thread thread : threads) {\n      thread.join();\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ec60431d008a694828dacb4bc3cda775b6c44a9f","date":1458570843,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = GeoDistanceUtils.haversin(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":["2331aada47d7da50e6835b59445dadc1bd456c39"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3","date":1458680048,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoProjectionUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected Boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47cd77df4a4e999a5b794f635e086eb42b8a37ce","date":1458728469,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    if (useThreads) {\n      // We must disable query cache otherwise test seed may not reproduce since different\n      // threads may or may not get a cache hit or miss depending on order the JVM\n      // schedules the threads:\n      s.setQueryCache(null);\n    }\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                          + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLon=\" + centerLon + \" centerLat=\" + centerLat\n                          + \" pointLon=\" + pointLon + \" pointLat=\" + pointLat + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6c59bc551f4e523ce6a321280cc6733424fb824","date":1458837690,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","sourceNew":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    if (useThreads) {\n      // We must disable query cache otherwise test seed may not reproduce since different\n      // threads may or may not get a cache hit or miss depending on order the JVM\n      // schedules the threads:\n      s.setQueryCache(null);\n    }\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                          + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    if (useThreads) {\n      // We must disable query cache otherwise test seed may not reproduce since different\n      // threads may or may not get a cache hit or miss depending on order the JVM\n      // schedules the threads:\n      s.setQueryCache(null);\n    }\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                          + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d102f8823b515dca7758d04ef1039875f73324e","date":1458843204,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/util/BaseGeoPointTestCase#verify(boolean,double[],double[],boolean).mjava","sourceNew":null,"sourceOld":"  protected void verify(boolean small, double[] lats, double[] lons, boolean useThreads) throws Exception {\n    IndexWriterConfig iwc = newIndexWriterConfig();\n    // Else we can get O(N^2) merging:\n    int mbd = iwc.getMaxBufferedDocs();\n    if (mbd != -1 && mbd < lats.length/100) {\n      iwc.setMaxBufferedDocs(lats.length/100);\n    }\n    Directory dir;\n    if (lats.length > 100000) {\n      dir = newFSDirectory(createTempDir(getClass().getSimpleName()));\n    } else {\n      dir = newDirectory();\n    }\n\n    Set<Integer> deleted = new HashSet<>();\n    // RandomIndexWriter is too slow here:\n    IndexWriter w = new IndexWriter(dir, iwc);\n    for(int id=0;id<lats.length;id++) {\n      Document doc = new Document();\n      doc.add(newStringField(\"id\", \"\"+id, Field.Store.NO));\n      doc.add(new NumericDocValuesField(\"id\", id));\n      if (Double.isNaN(lats[id]) == false) {\n        addPointToDoc(FIELD_NAME, doc, lats[id], lons[id]);\n      }\n      w.addDocument(doc);\n      if (id > 0 && random().nextInt(100) == 42) {\n        int idToDelete = random().nextInt(id);\n        w.deleteDocuments(new Term(\"id\", \"\"+idToDelete));\n        deleted.add(idToDelete);\n        if (VERBOSE) {\n          System.out.println(\"  delete id=\" + idToDelete);\n        }\n      }\n    }\n\n    if (random().nextBoolean()) {\n      w.forceMerge(1);\n    }\n    final IndexReader r = DirectoryReader.open(w);\n    w.close();\n\n    // We can't wrap with \"exotic\" readers because the BKD query must see the BKDDVFormat:\n    IndexSearcher s = newSearcher(r, false);\n\n    if (useThreads) {\n      // We must disable query cache otherwise test seed may not reproduce since different\n      // threads may or may not get a cache hit or miss depending on order the JVM\n      // schedules the threads:\n      s.setQueryCache(null);\n    }\n\n    // Make sure queries are thread safe:\n    int numThreads;\n    if (useThreads) {\n      numThreads = TestUtil.nextInt(random(), 2, 5);\n    } else {\n      numThreads = 1;\n    }\n\n    List<Thread> threads = new ArrayList<>();\n    final int iters = atLeast(75);\n\n    final CountDownLatch startingGun = new CountDownLatch(1);\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    for(int i=0;i<numThreads;i++) {\n      Thread thread = new Thread() {\n          @Override\n          public void run() {\n            try {\n              _run();\n            } catch (Exception e) {\n              failed.set(true);\n              throw new RuntimeException(e);\n            }\n          }\n\n          private void _run() throws Exception {\n            if (useThreads) {\n              startingGun.await();\n            }\n\n            NumericDocValues docIDToID = MultiDocValues.getNumericValues(r, \"id\");\n\n            for (int iter=0;iter<iters && failed.get() == false;iter++) {\n\n              if (VERBOSE) {\n                System.out.println(\"\\n\" + Thread.currentThread().getName() + \": TEST: iter=\" + iter + \" s=\" + s);\n              }\n              Query query;\n              VerifyHits verifyHits;\n\n              if (random().nextBoolean()) {\n                // Rect: don't allow dateline crossing when testing small:\n                final GeoRect rect = randomRect(small, small == false);\n\n                query = newRectQuery(FIELD_NAME, rect.minLat, rect.maxLat, rect.minLon, rect.maxLon);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return rectContainsPoint(rect, pointLat, pointLon);\n                    }\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n\n              } else if (random().nextBoolean()) {\n                // Distance\n                final boolean rangeQuery = random().nextBoolean();\n                final double centerLat = randomLat(small);\n                final double centerLon = randomLon(small);\n\n                double radiusMeters;\n                double minRadiusMeters;\n\n                if (small) {\n                  // Approx 3 degrees lon at the equator:\n                  radiusMeters = random().nextDouble() * 333000 + 1.0;\n                } else {\n                  // So the query can cover at most 50% of the earth's surface:\n                  radiusMeters = random().nextDouble() * GeoUtils.SEMIMAJOR_AXIS * Math.PI / 2.0 + 1.0;\n                }\n\n                // generate a random minimum radius between 1% and 95% the max radius\n                minRadiusMeters = (0.01 + 0.94 * random().nextDouble()) * radiusMeters;\n\n                if (VERBOSE) {\n                  final DecimalFormat df = new DecimalFormat(\"#,###.00\", DecimalFormatSymbols.getInstance(Locale.ENGLISH));\n                  System.out.println(\"  radiusMeters = \" + df.format(radiusMeters)\n                      + ((rangeQuery == true) ? \" minRadiusMeters = \" + df.format(minRadiusMeters) : \"\"));\n                }\n\n                try {\n                  if (rangeQuery == true) {\n                    query = newDistanceRangeQuery(FIELD_NAME, centerLat, centerLon, minRadiusMeters, radiusMeters);\n                  } else {\n                    query = newDistanceQuery(FIELD_NAME, centerLat, centerLon, radiusMeters);\n                  }\n                } catch (IllegalArgumentException e) {\n                  if (e.getMessage().contains(\"exceeds maxRadius\")) {\n                    continue;\n                  }\n                  throw e;\n                }\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      if (rangeQuery == false) {\n                        return circleContainsPoint(centerLat, centerLon, radiusMeters, pointLat, pointLon);\n                      } else {\n                        return distanceRangeContainsPoint(centerLat, centerLon, minRadiusMeters, radiusMeters, pointLat, pointLon);\n                      }\n                    }\n\n                    @Override\n                    protected void describe(int docID, double pointLat, double pointLon) {\n                      double distanceMeters = SloppyMath.haversinMeters(centerLat, centerLon, pointLat, pointLon);\n                      System.out.println(\"  docID=\" + docID + \" centerLat=\" + centerLat + \" centerLon=\" + centerLon\n                          + \" pointLat=\" + pointLat + \" pointLon=\" + pointLon + \" distanceMeters=\" + distanceMeters\n                          + \" vs\" + ((rangeQuery == true) ? \" minRadiusMeters=\" + minRadiusMeters : \"\") + \" radiusMeters=\" + radiusMeters);\n                    }\n                   };\n\n              // TODO: get poly query working with dateline crossing too (how?)!\n              } else {\n\n                // TODO: poly query can't handle dateline crossing yet:\n                final GeoRect bbox = randomRect(small, false);\n\n                // Polygon\n                double[] lats = new double[5];\n                double[] lons = new double[5];\n                lats[0] = bbox.minLat;\n                lons[0] = bbox.minLon;\n                lats[1] = bbox.maxLat;\n                lons[1] = bbox.minLon;\n                lats[2] = bbox.maxLat;\n                lons[2] = bbox.maxLon;\n                lats[3] = bbox.minLat;\n                lons[3] = bbox.maxLon;\n                lats[4] = bbox.minLat;\n                lons[4] = bbox.minLon;\n                query = newPolygonQuery(FIELD_NAME, lats, lons);\n\n                verifyHits = new VerifyHits() {\n                    @Override\n                    protected boolean shouldMatch(double pointLat, double pointLon) {\n                      return polyRectContainsPoint(bbox, pointLat, pointLon);\n                    }\n\n                    @Override\n                    protected void describe(int docID, double lat, double lon) {\n                    }\n                  };\n              }\n\n              if (query != null) {\n\n                if (VERBOSE) {\n                  System.out.println(\"  query=\" + query);\n                }\n\n                verifyHits.test(failed, small, s, docIDToID, deleted, query, lats, lons);\n              }\n            }\n          }\n      };\n      thread.setName(\"T\" + i);\n      if (useThreads) {\n        thread.start();\n      } else {\n        // Just run with main thread:\n        thread.run();\n      }\n      threads.add(thread);\n    }\n    if (useThreads) {\n      startingGun.countDown();\n      for(Thread thread : threads) {\n        thread.join();\n      }\n    }\n    IOUtils.close(r, dir);\n    assertFalse(failed.get());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["278394e71c5c3727ff5225bafdde73d7454d0012"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"278394e71c5c3727ff5225bafdde73d7454d0012":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"47cd77df4a4e999a5b794f635e086eb42b8a37ce":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1d102f8823b515dca7758d04ef1039875f73324e"],"1d102f8823b515dca7758d04ef1039875f73324e":["d6c59bc551f4e523ce6a321280cc6733424fb824"],"d6c59bc551f4e523ce6a321280cc6733424fb824":["47cd77df4a4e999a5b794f635e086eb42b8a37ce"]},"commit2Childs":{"ec60431d008a694828dacb4bc3cda775b6c44a9f":["cb4875e9db9b77346c36b7fe0d4b8759a1e095d3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["278394e71c5c3727ff5225bafdde73d7454d0012"],"278394e71c5c3727ff5225bafdde73d7454d0012":["ec60431d008a694828dacb4bc3cda775b6c44a9f"],"47cd77df4a4e999a5b794f635e086eb42b8a37ce":["d6c59bc551f4e523ce6a321280cc6733424fb824"],"cb4875e9db9b77346c36b7fe0d4b8759a1e095d3":["47cd77df4a4e999a5b794f635e086eb42b8a37ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"1d102f8823b515dca7758d04ef1039875f73324e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d6c59bc551f4e523ce6a321280cc6733424fb824":["1d102f8823b515dca7758d04ef1039875f73324e"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}