{"path":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createTempOutput(String,String,IOContext).mjava","commits":[{"id":"e3ce1ef883d26aa73919aa2d53991726e96caa13","date":1445421402,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createTempOutput(String,String,IOContext).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public synchronized IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(\"temp: prefix=\" + prefix + \" suffix=\" + suffix);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createTempOutput after crash\");\n    }\n    init();\n    \n    IndexOutput delegateOutput = in.createTempOutput(prefix, suffix, LuceneTestCase.newIOContext(randomState, context));\n    String name = delegateOutput.getName();\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57deae53907a4ece55c7e78d3aab19592ad083a5","date":1446894468,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createTempOutput(String,String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createTempOutput(String,String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(\"temp: prefix=\" + prefix + \" suffix=\" + suffix);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createTempOutput after crash\");\n    }\n    init();\n    \n    IndexOutput delegateOutput = in.createTempOutput(prefix, suffix, LuceneTestCase.newIOContext(randomState, context));\n    String name = delegateOutput.getName();\n    if (name.toLowerCase(Locale.ROOT).endsWith(\".tmp\") == false) {\n      throw new IllegalStateException(\"wrapped directory failed to use .tmp extension: got: \" + name);\n    }\n\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(\"temp: prefix=\" + prefix + \" suffix=\" + suffix);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createTempOutput after crash\");\n    }\n    init();\n    \n    IndexOutput delegateOutput = in.createTempOutput(prefix, suffix, LuceneTestCase.newIOContext(randomState, context));\n    String name = delegateOutput.getName();\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3adea0022cffaaa592081efed775a7b8bf86b51","date":1532414870,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createTempOutput(String,String,IOContext).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/store/MockDirectoryWrapper#createTempOutput(String,String,IOContext).mjava","sourceNew":"  @Override\n  public synchronized IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(\"temp: prefix=\" + prefix + \" suffix=\" + suffix);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createTempOutput after crash\");\n    }\n    init();\n    \n    IndexOutput delegateOutput = in.createTempOutput(prefix, suffix, LuceneTestCase.newIOContext(randomState, context));\n    String name = delegateOutput.getName();\n    if (name.toLowerCase(Locale.ROOT).endsWith(\".tmp\") == false) {\n      throw new IllegalStateException(\"wrapped directory failed to use .tmp extension: got: \" + name);\n    }\n\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    return maybeThrottle(name, io);\n  }\n\n","sourceOld":"  @Override\n  public synchronized IndexOutput createTempOutput(String prefix, String suffix, IOContext context) throws IOException {\n    maybeThrowDeterministicException();\n    maybeThrowIOExceptionOnOpen(\"temp: prefix=\" + prefix + \" suffix=\" + suffix);\n    maybeYield();\n    if (failOnCreateOutput) {\n      maybeThrowDeterministicException();\n    }\n    if (crashed) {\n      throw new IOException(\"cannot createTempOutput after crash\");\n    }\n    init();\n    \n    IndexOutput delegateOutput = in.createTempOutput(prefix, suffix, LuceneTestCase.newIOContext(randomState, context));\n    String name = delegateOutput.getName();\n    if (name.toLowerCase(Locale.ROOT).endsWith(\".tmp\") == false) {\n      throw new IllegalStateException(\"wrapped directory failed to use .tmp extension: got: \" + name);\n    }\n\n    unSyncedFiles.add(name);\n    createdFiles.add(name);\n    final IndexOutput io = new MockIndexOutputWrapper(this, delegateOutput, name);\n    addFileHandle(io, name, Handle.Output);\n    openFilesForWrite.add(name);\n    \n    // throttling REALLY slows down tests, so don't do it very often for SOMETIMES.\n    if (throttling == Throttling.ALWAYS || \n        (throttling == Throttling.SOMETIMES && randomState.nextInt(200) == 0)) {\n      if (LuceneTestCase.VERBOSE) {\n        System.out.println(\"MockDirectoryWrapper: throttling indexOutput (\" + name + \")\");\n      }\n      return throttledOutput.newFromDelegate(io);\n    } else {\n      return io;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57deae53907a4ece55c7e78d3aab19592ad083a5":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["57deae53907a4ece55c7e78d3aab19592ad083a5"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f3adea0022cffaaa592081efed775a7b8bf86b51"]},"commit2Childs":{"57deae53907a4ece55c7e78d3aab19592ad083a5":["f3adea0022cffaaa592081efed775a7b8bf86b51"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e3ce1ef883d26aa73919aa2d53991726e96caa13"],"e3ce1ef883d26aa73919aa2d53991726e96caa13":["57deae53907a4ece55c7e78d3aab19592ad083a5"],"f3adea0022cffaaa592081efed775a7b8bf86b51":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}