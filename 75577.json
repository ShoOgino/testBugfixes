{"path":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(List[InputStream],CharsetDecoder,Builder[Long]).mjava","commits":[{"id":"dc3f094cafa4a87b4066e1d6710fa4e6afe6260e","date":1393532367,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(List[InputStream],CharsetDecoder,Builder[Long]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell2/Dictionary#readDictionaryFile(InputStream,CharsetDecoder,Builder[Long]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(List<InputStream> dictionaries, CharsetDecoder decoder, Builder<Long> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    IntsRef scratchInts = new IntsRef();\n    \n    File unsorted = File.createTempFile(\"unsorted\", \"dat\", tempDir);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          if (ignoreCase) {\n            int flagSep = line.lastIndexOf('/');\n            if (flagSep == -1) {\n              writer.write(line.toLowerCase(Locale.ROOT).getBytes(IOUtils.CHARSET_UTF_8));\n            } else {\n              StringBuilder sb = new StringBuilder();\n              sb.append(line.substring(0, flagSep).toLowerCase(Locale.ROOT));\n              if (flagSep < line.length()) {\n                sb.append(line.substring(flagSep, line.length()));\n              }\n              writer.write(sb.toString().getBytes(IOUtils.CHARSET_UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));\n          }\n        }\n      }\n    }\n    File sorted = File.createTempFile(\"sorted\", \"dat\", tempDir);\n    \n    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == '/') {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == '/') {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        return scratch1.compareTo(scratch2);\n      }\n    });\n    sorter.sort(unsorted, sorted);\n    unsorted.delete();\n    \n    ByteSequencesReader reader = new ByteSequencesReader(sorted);\n    BytesRef scratchLine = new BytesRef();\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    \n    BytesRef currentEntry = new BytesRef();\n    char currentFlags[] = new char[0];\n    \n    String line;\n    while (reader.read(scratchLine)) {\n      line = scratchLine.utf8ToString();\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      int cmp = scratch.compareTo(currentEntry);\n      if (cmp < 0) {\n        throw new IllegalArgumentException(\"out of order: \" + scratch.utf8ToString() + \" < \" + currentEntry.utf8ToString());\n      } else if (cmp == 0) {\n        currentFlags = merge(currentFlags, wordForm);\n      } else {\n        final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n        int ord = flagLookup.add(flagsScratch, hashCode);\n        if (ord < 0) {\n          // already exists in our hash\n          ord = (-ord)-1;\n        }\n        UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n        words.add(scratchInts, (long)ord);\n        currentEntry = scratch;\n        currentFlags = wordForm;\n      }\n    }\n    \n    final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n    int ord = flagLookup.add(flagsScratch, hashCode);\n    if (ord < 0) {\n      // already exists in our hash\n      ord = (-ord)-1;\n    }\n    UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n    words.add(scratchInts, (long)ord);\n    \n    reader.close();\n    sorted.delete();\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStream, building up the words map\n   *\n   * @param dictionary InputStream to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFile(InputStream dictionary, CharsetDecoder decoder, Builder<Long> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    IntsRef scratchInts = new IntsRef();\n    \n    BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n    String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n    \n    File unsorted = File.createTempFile(\"unsorted\", \"dat\", tempDir);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      while ((line = lines.readLine()) != null) {\n        writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));\n      }\n    }\n    File sorted = File.createTempFile(\"sorted\", \"dat\", tempDir);\n    \n    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == '/') {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == '/') {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        return scratch1.compareTo(scratch2);\n      }\n    });\n    sorter.sort(unsorted, sorted);\n    unsorted.delete();\n    \n    ByteSequencesReader reader = new ByteSequencesReader(sorted);\n    BytesRef scratchLine = new BytesRef();\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    \n    BytesRef currentEntry = new BytesRef();\n    char currentFlags[] = new char[0];\n    \n    while (reader.read(scratchLine)) {\n      line = scratchLine.utf8ToString();\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      int cmp = scratch.compareTo(currentEntry);\n      if (cmp < 0) {\n        throw new IllegalArgumentException(\"out of order: \" + scratch.utf8ToString() + \" < \" + currentEntry.utf8ToString());\n      } else if (cmp == 0) {\n        currentFlags = merge(currentFlags, wordForm);\n      } else {\n        final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n        int ord = flagLookup.add(flagsScratch, hashCode);\n        if (ord < 0) {\n          // already exists in our hash\n          ord = (-ord)-1;\n        }\n        UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n        words.add(scratchInts, (long)ord);\n        currentEntry = scratch;\n        currentFlags = wordForm;\n      }\n    }\n    \n    final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n    int ord = flagLookup.add(flagsScratch, hashCode);\n    if (ord < 0) {\n      // already exists in our hash\n      ord = (-ord)-1;\n    }\n    UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n    words.add(scratchInts, (long)ord);\n    \n    reader.close();\n    sorted.delete();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba791bce8103c79e38f957e9c5a53a75871bd918","date":1393539206,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(List[InputStream],CharsetDecoder,Builder[Long]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(List<InputStream> dictionaries, CharsetDecoder decoder, Builder<Long> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    IntsRef scratchInts = new IntsRef();\n    \n    File unsorted = File.createTempFile(\"unsorted\", \"dat\", tempDir);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          if (ignoreCase) {\n            int flagSep = line.lastIndexOf('/');\n            if (flagSep == -1) {\n              writer.write(line.toLowerCase(Locale.ROOT).getBytes(IOUtils.CHARSET_UTF_8));\n            } else {\n              StringBuilder sb = new StringBuilder();\n              sb.append(line.substring(0, flagSep).toLowerCase(Locale.ROOT));\n              if (flagSep < line.length()) {\n                sb.append(line.substring(flagSep, line.length()));\n              }\n              writer.write(sb.toString().getBytes(IOUtils.CHARSET_UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));\n          }\n        }\n      }\n    }\n    File sorted = File.createTempFile(\"sorted\", \"dat\", tempDir);\n    \n    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == '/') {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == '/') {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        return scratch1.compareTo(scratch2);\n      }\n    });\n    sorter.sort(unsorted, sorted);\n    unsorted.delete();\n    \n    ByteSequencesReader reader = new ByteSequencesReader(sorted);\n    BytesRef scratchLine = new BytesRef();\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    \n    BytesRef currentEntry = new BytesRef();\n    char currentFlags[] = new char[0];\n    \n    String line;\n    while (reader.read(scratchLine)) {\n      line = scratchLine.utf8ToString();\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      int cmp = scratch.compareTo(currentEntry);\n      if (cmp < 0) {\n        throw new IllegalArgumentException(\"out of order: \" + scratch.utf8ToString() + \" < \" + currentEntry.utf8ToString());\n      } else if (cmp == 0) {\n        currentFlags = merge(currentFlags, wordForm);\n      } else {\n        final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n        int ord = flagLookup.add(flagsScratch, hashCode);\n        if (ord < 0) {\n          // already exists in our hash\n          ord = (-ord)-1;\n        }\n        UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n        words.add(scratchInts, (long)ord);\n        currentEntry = scratch;\n        currentFlags = wordForm;\n      }\n    }\n    \n    final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n    int ord = flagLookup.add(flagsScratch, hashCode);\n    if (ord < 0) {\n      // already exists in our hash\n      ord = (-ord)-1;\n    }\n    UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n    words.add(scratchInts, (long)ord);\n    \n    reader.close();\n    sorted.delete();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b58bd8dd457a9b46b007c641d5b6e747afb8904a","date":1393616676,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(List[InputStream],CharsetDecoder,Builder[IntsRef]).mjava","pathOld":"lucene/analysis/common/src/java/org/apache/lucene/analysis/hunspell/Dictionary#readDictionaryFiles(List[InputStream],CharsetDecoder,Builder[Long]).mjava","sourceNew":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(List<InputStream> dictionaries, CharsetDecoder decoder, Builder<IntsRef> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    IntsRef scratchInts = new IntsRef();\n    \n    File unsorted = File.createTempFile(\"unsorted\", \"dat\", tempDir);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          if (ignoreCase) {\n            int flagSep = line.lastIndexOf('/');\n            if (flagSep == -1) {\n              writer.write(line.toLowerCase(Locale.ROOT).getBytes(IOUtils.CHARSET_UTF_8));\n            } else {\n              StringBuilder sb = new StringBuilder();\n              sb.append(line.substring(0, flagSep).toLowerCase(Locale.ROOT));\n              if (flagSep < line.length()) {\n                sb.append(line.substring(flagSep, line.length()));\n              }\n              writer.write(sb.toString().getBytes(IOUtils.CHARSET_UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));\n          }\n        }\n      }\n    }\n    File sorted = File.createTempFile(\"sorted\", \"dat\", tempDir);\n    \n    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == '/') {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == '/') {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        int cmp = scratch1.compareTo(scratch2);\n        if (cmp == 0) {\n          // tie break on whole row\n          return o1.compareTo(o2);\n        } else {\n          return cmp;\n        }\n      }\n    });\n    sorter.sort(unsorted, sorted);\n    unsorted.delete();\n    \n    ByteSequencesReader reader = new ByteSequencesReader(sorted);\n    BytesRef scratchLine = new BytesRef();\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    \n    String currentEntry = null;\n    IntsRef currentOrds = new IntsRef();\n    \n    String line;\n    while (reader.read(scratchLine)) {\n      line = scratchLine.utf8ToString();\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace: currently just tab and space\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        int end2 = line.indexOf(' ', flagSep);\n        if (end2 == -1)\n          end2 = line.length();\n        end = Math.min(end, end2);\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      int cmp = currentEntry == null ? 1 : entry.compareTo(currentEntry);\n      if (cmp < 0) {\n        throw new IllegalArgumentException(\"out of order: \" + entry + \" < \" + currentEntry);\n      } else {\n        final int hashCode = encodeFlagsWithHash(flagsScratch, wordForm);\n        int ord = flagLookup.add(flagsScratch, hashCode);\n        if (ord < 0) {\n          // already exists in our hash\n          ord = (-ord)-1;\n        }\n        // finalize current entry, and switch \"current\" if necessary\n        if (cmp > 0 && currentEntry != null) {\n          Util.toUTF32(currentEntry, scratchInts);\n          words.add(scratchInts, currentOrds);\n        }\n        // swap current\n        if (cmp > 0 || currentEntry == null) {\n          currentEntry = entry;\n          currentOrds = new IntsRef(); // must be this way\n        }\n        currentOrds.grow(currentOrds.length+1);\n        currentOrds.ints[currentOrds.length++] = ord;\n      }\n    }\n    \n    // finalize last entry\n    Util.toUTF32(currentEntry, scratchInts);\n    words.add(scratchInts, currentOrds);\n    \n    reader.close();\n    sorted.delete();\n  }\n\n","sourceOld":"  /**\n   * Reads the dictionary file through the provided InputStreams, building up the words map\n   *\n   * @param dictionaries InputStreams to read the dictionary file through\n   * @param decoder CharsetDecoder used to decode the contents of the file\n   * @throws IOException Can be thrown while reading from the file\n   */\n  private void readDictionaryFiles(List<InputStream> dictionaries, CharsetDecoder decoder, Builder<Long> words) throws IOException {\n    BytesRef flagsScratch = new BytesRef();\n    IntsRef scratchInts = new IntsRef();\n    \n    File unsorted = File.createTempFile(\"unsorted\", \"dat\", tempDir);\n    try (ByteSequencesWriter writer = new ByteSequencesWriter(unsorted)) {\n      for (InputStream dictionary : dictionaries) {\n        BufferedReader lines = new BufferedReader(new InputStreamReader(dictionary, decoder));\n        String line = lines.readLine(); // first line is number of entries (approximately, sometimes)\n        \n        while ((line = lines.readLine()) != null) {\n          if (ignoreCase) {\n            int flagSep = line.lastIndexOf('/');\n            if (flagSep == -1) {\n              writer.write(line.toLowerCase(Locale.ROOT).getBytes(IOUtils.CHARSET_UTF_8));\n            } else {\n              StringBuilder sb = new StringBuilder();\n              sb.append(line.substring(0, flagSep).toLowerCase(Locale.ROOT));\n              if (flagSep < line.length()) {\n                sb.append(line.substring(flagSep, line.length()));\n              }\n              writer.write(sb.toString().getBytes(IOUtils.CHARSET_UTF_8));\n            }\n          } else {\n            writer.write(line.getBytes(IOUtils.CHARSET_UTF_8));\n          }\n        }\n      }\n    }\n    File sorted = File.createTempFile(\"sorted\", \"dat\", tempDir);\n    \n    OfflineSorter sorter = new OfflineSorter(new Comparator<BytesRef>() {\n      BytesRef scratch1 = new BytesRef();\n      BytesRef scratch2 = new BytesRef();\n      \n      @Override\n      public int compare(BytesRef o1, BytesRef o2) {\n        scratch1.bytes = o1.bytes;\n        scratch1.offset = o1.offset;\n        scratch1.length = o1.length;\n        \n        for (int i = scratch1.length - 1; i >= 0; i--) {\n          if (scratch1.bytes[scratch1.offset + i] == '/') {\n            scratch1.length = i;\n            break;\n          }\n        }\n        \n        scratch2.bytes = o2.bytes;\n        scratch2.offset = o2.offset;\n        scratch2.length = o2.length;\n        \n        for (int i = scratch2.length - 1; i >= 0; i--) {\n          if (scratch2.bytes[scratch2.offset + i] == '/') {\n            scratch2.length = i;\n            break;\n          }\n        }\n        \n        return scratch1.compareTo(scratch2);\n      }\n    });\n    sorter.sort(unsorted, sorted);\n    unsorted.delete();\n    \n    ByteSequencesReader reader = new ByteSequencesReader(sorted);\n    BytesRef scratchLine = new BytesRef();\n    \n    // TODO: the flags themselves can be double-chars (long) or also numeric\n    // either way the trick is to encode them as char... but they must be parsed differently\n    \n    BytesRef currentEntry = new BytesRef();\n    char currentFlags[] = new char[0];\n    \n    String line;\n    while (reader.read(scratchLine)) {\n      line = scratchLine.utf8ToString();\n      String entry;\n      char wordForm[];\n      \n      int flagSep = line.lastIndexOf('/');\n      if (flagSep == -1) {\n        wordForm = NOFLAGS;\n        entry = line;\n      } else {\n        // note, there can be comments (morph description) after a flag.\n        // we should really look for any whitespace\n        int end = line.indexOf('\\t', flagSep);\n        if (end == -1)\n          end = line.length();\n        \n        String flagPart = line.substring(flagSep + 1, end);\n        if (aliasCount > 0) {\n          flagPart = getAliasValue(Integer.parseInt(flagPart));\n        } \n        \n        wordForm = flagParsingStrategy.parseFlags(flagPart);\n        Arrays.sort(wordForm);\n        entry = line.substring(0, flagSep);\n      }\n\n      BytesRef scratch = new BytesRef(entry);\n      int cmp = scratch.compareTo(currentEntry);\n      if (cmp < 0) {\n        throw new IllegalArgumentException(\"out of order: \" + scratch.utf8ToString() + \" < \" + currentEntry.utf8ToString());\n      } else if (cmp == 0) {\n        currentFlags = merge(currentFlags, wordForm);\n      } else {\n        final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n        int ord = flagLookup.add(flagsScratch, hashCode);\n        if (ord < 0) {\n          // already exists in our hash\n          ord = (-ord)-1;\n        }\n        UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n        words.add(scratchInts, (long)ord);\n        currentEntry = scratch;\n        currentFlags = wordForm;\n      }\n    }\n    \n    final int hashCode = encodeFlagsWithHash(flagsScratch, currentFlags);\n    int ord = flagLookup.add(flagsScratch, hashCode);\n    if (ord < 0) {\n      // already exists in our hash\n      ord = (-ord)-1;\n    }\n    UnicodeUtil.UTF8toUTF32(currentEntry, scratchInts);\n    words.add(scratchInts, (long)ord);\n    \n    reader.close();\n    sorted.delete();\n  }\n\n","bugFix":null,"bugIntro":["cbc3688252d4a8045d69a164236b2cf87b721f17","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"ba791bce8103c79e38f957e9c5a53a75871bd918":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","dc3f094cafa4a87b4066e1d6710fa4e6afe6260e"],"dc3f094cafa4a87b4066e1d6710fa4e6afe6260e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b58bd8dd457a9b46b007c641d5b6e747afb8904a":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b58bd8dd457a9b46b007c641d5b6e747afb8904a"]},"commit2Childs":{"ba791bce8103c79e38f957e9c5a53a75871bd918":["b58bd8dd457a9b46b007c641d5b6e747afb8904a"],"dc3f094cafa4a87b4066e1d6710fa4e6afe6260e":["ba791bce8103c79e38f957e9c5a53a75871bd918"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["ba791bce8103c79e38f957e9c5a53a75871bd918","dc3f094cafa4a87b4066e1d6710fa4e6afe6260e"],"b58bd8dd457a9b46b007c641d5b6e747afb8904a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}