{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","7875fce026a0a335830cfc75abc3eb009eff9a73","1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"/dev/null","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6aa13594d60227932a46e09d7219144b9c5115cd","date":1340889829,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c824b5854f7ad30cd53f0634fc7cb533df74590b","date":1344024196,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":["1525b4dfbc0d413b8d7247da232009778e624836"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(liveNodesSet,\n                      ZkStateReader.this.clusterState.getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da94fd5fcff99442877e118f00fb42094b59f497","date":1344115365,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(liveNodesSet,\n                      ZkStateReader.this.clusterState.getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(liveNodesSet,\n                      ZkStateReader.this.clusterState.getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateCloudState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              CloudState clusterState = CloudState.load(data,\n                  ZkStateReader.this.cloudState.getLiveNodes());\n              // update volatile\n              cloudState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateCloudState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  CloudState clusterState = new CloudState(liveNodesSet,\n                      ZkStateReader.this.cloudState.getCollectionStates());\n                  ZkStateReader.this.cloudState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      CloudState clusterState = CloudState.load(zkClient, liveNodeSet);\n      this.cloudState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, null,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(liveNodesSet,\n                      ZkStateReader.this.clusterState.getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1525b4dfbc0d413b8d7247da232009778e624836","date":1351101135,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","c824b5854f7ad30cd53f0634fc7cb533df74590b"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9405f486872f1e416304dfe389741f4ee2f8a4d","date":1351276739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":["8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating...\");\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              \n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data,\n                  ZkStateReader.this.clusterState.getLiveNodes());\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              log.info(\"Updating live nodes\");\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0fc5446c5624aa38009cf373a69bd551b7415352","date":1353455439,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"66bcdf5bd26ae0a881d408a4ccfee95153bb4866","date":1354905884,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... ({})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"252e8087adc8ce3ff58a765302418a2c216a6e99","date":1354905894,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... ({})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change has occurred - updating... ({})\", ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1cfa38e36fa296bb93d77df7d5556257dffa4535","date":1362635543,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n    }\n  }\n\n","bugFix":null,"bugIntro":["7875fce026a0a335830cfc75abc3eb009eff9a73"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b200b1e98a34247f0d84267e31d49d1c7304673","date":1364997490,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d","date":1380971306,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              List<String> liveNodes = zkClient.getChildren(\n                  LIVE_NODES_ZKNODE, this, true);\n     \n              Set<String> liveNodesSet = new HashSet<String>();\n              liveNodesSet.addAll(liveNodes);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70","date":1386334715,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<String>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<String>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0622fbd990643ae4cacb693db6a0c82cf8916ae2","date":1397637446,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n              updateCollectionNames();\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      updateCollectionNames();\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this){\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.info(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n                  ClusterState clusterState = new ClusterState(\n                      ZkStateReader.this.clusterState.getZkClusterStateVersion(),\n                      liveNodesSet, ZkStateReader.this.clusterState\n                          .getCollectionStates());\n                  ZkStateReader.this.clusterState = clusterState;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a5a233896b7f16ac9b4ed601ef8207d98f1f0500","date":1398857046,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n              updateCollectionNames();\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      updateCollectionNames();\n      \n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this){\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6f693ed86f289b2e42b46684409b3997f2c264a","date":1404319832,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this, null);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n              updateCollectionNames();\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      updateCollectionNames();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4c07fa58a256dccf8b95364855fd5e9ad4d1401","date":1404386015,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln,ZkStateReader.this, null);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n              updateCollectionNames();\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n      updateCollectionNames();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9279b175e5e66258442d2123a50f052219a9cc1b","date":1410531077,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Stat stat = new Stat();\n              byte[] data = zkClient.getData(CLUSTER_STATE, thisWatch, stat ,\n                  true);\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              ClusterState clusterState = ClusterState.load(stat.getVersion(), data, ln);\n              // update volatile\n              ZkStateReader.this.clusterState = clusterState;\n\n//              HashSet<String> all = new HashSet<>(colls);;\n//              all.addAll(clusterState.getAllInternalCollections());\n//              all.remove(null);\n\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      ClusterState clusterState = ClusterState.load(zkClient, liveNodeSet, ZkStateReader.this);\n      this.clusterState = clusterState;\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7875fce026a0a335830cfc75abc3eb009eff9a73","date":1425897108,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","1cfa38e36fa296bb93d77df7d5556257dffa4535"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n      cmdExecutor.ensureExists(CLUSTER_STATE, zkClient);\n      cmdExecutor.ensureExists(ALIASES, zkClient);\n      \n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba88c12c59ad335ca2ba493153932ba8ccd582ef","date":1432819428,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n            log.info(\"Updated cluster state version to \" + ZkStateReader.this.clusterState.getZkClusterStateVersion());\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bdcb86c29922edae9a14852e636303bc52df094","date":1438887454,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n            log.info(\"Updated cluster state version to \" + ZkStateReader.this.clusterState.getZkClusterStateVersion());\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH,new Callable<Pair<byte[], Stat>>(){\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey() .length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n\n        }\n      });\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n            log.info(\"Updated cluster state version to \" + ZkStateReader.this.clusterState.getZkClusterStateVersion());\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1072b8e47b50f1c4fb039e1f54a736f381d6f809","date":1438956441,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshLazyFormat2Collections(true);\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH, new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n    \n    synchronized (getUpdateLock()) {\n\n      log.info(\"Updating cluster state from ZooKeeper... \");\n      \n      Stat stat = zkClient.exists(CLUSTER_STATE, new Watcher() {\n        \n        @Override\n        public void process(WatchedEvent event) {\n          // session events are not change events,\n          // and do not remove the watcher\n          if (EventType.None.equals(event.getType())) {\n            return;\n          }\n          log.info(\"A cluster state change: {}, has occurred - updating... (live nodes size: {})\", (event) , ZkStateReader.this.clusterState == null ? 0 : ZkStateReader.this.clusterState.getLiveNodes().size());\n          try {\n            \n            // delayed approach\n            // ZkStateReader.this.updateClusterState(false, false);\n            synchronized (ZkStateReader.this.getUpdateLock()) {\n              // remake watch\n              final Watcher thisWatch = this;\n              Set<String> ln = ZkStateReader.this.clusterState.getLiveNodes();\n              // update volatile\n              ZkStateReader.this.clusterState = constructState(ln, thisWatch);\n            }\n            log.info(\"Updated cluster state version to \" + ZkStateReader.this.clusterState.getZkClusterStateVersion());\n          } catch (KeeperException e) {\n            if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n              log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n              return;\n            }\n            log.error(\"\", e);\n            throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR,\n                \"\", e);\n          } catch (InterruptedException e) {\n            // Restore the interrupted status\n            Thread.currentThread().interrupt();\n            log.warn(\"\", e);\n            return;\n          }\n        }\n        \n      }, true);\n\n      if (stat == null)\n        throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n            \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n   \n    \n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      List<String> liveNodes = zkClient.getChildren(LIVE_NODES_ZKNODE,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                // delayed approach\n                // ZkStateReader.this.updateClusterState(false, true);\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  List<String> liveNodes = zkClient.getChildren(\n                      LIVE_NODES_ZKNODE, this, true);\n                  log.debug(\"Updating live nodes... ({})\", liveNodes.size());\n                  Set<String> liveNodesSet = new HashSet<>();\n                  liveNodesSet.addAll(liveNodes);\n\n                  ClusterState clusterState =  ZkStateReader.this.clusterState;\n\n                  clusterState.setLiveNodes(liveNodesSet);\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    \n      Set<String> liveNodeSet = new HashSet<>();\n      liveNodeSet.addAll(liveNodes);\n      this.clusterState = constructState(liveNodeSet, null);\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n    //on reconnect of SolrZkClient re-add watchers for the watched external collections\n    synchronized (this) {\n      for (String watchedCollection : watchedCollections) {\n        addZkWatch(watchedCollection);\n      }\n    }\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH,new Callable<Pair<byte[], Stat>>(){\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey() .length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n\n        }\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf","date":1440482195,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH, new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshLazyFormat2Collections(true);\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH, new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c0372f459e6b4348374eb3fbdbde69ee47840b71","date":1441188918,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH, new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH, new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7477015ee104ad8144fba06b9b0a8ea93aea50f8","date":1450790907,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  log.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  Stat stat = new Stat();\n                  byte[] data = zkClient.getData(ALIASES, thisWatch, stat ,\n                      true);\n\n                  Aliases aliases = ClusterState.load(data);\n\n                  ZkStateReader.this.aliases = aliases;\n                }\n              } catch (KeeperException e) {\n                if (e.code() == KeeperException.Code.SESSIONEXPIRED\n                    || e.code() == KeeperException.Code.CONNECTIONLOSS) {\n                  log.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK\");\n                  return;\n                }\n                log.error(\"\", e);\n                throw new ZooKeeperException(\n                    SolrException.ErrorCode.SERVER_ERROR, \"\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                log.warn(\"\", e);\n                return;\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(SOLR_SECURITY_CONF_PATH, new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f616abd7d3345b373ca3f5a49a3351a7a18eb741","date":1455910613,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events,\n              // and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a0c04b71951333291abc7f317109a6a5957bd28","date":1457097827,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n        cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(new Callable<Pair<byte[], Stat>>() {\n        @Override\n        public void call(Pair<byte[], Stat> pair) {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n          cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        }\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da7373b6df772f51a66550c8080379e9ddf2e7db","date":1462690671,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n        cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e66a459d38c1c4a2f97128433dab546f683a9fed","date":1462873476,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n        cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b4df85b7268ca40452d6c01343d8eb00ed1f70a","date":1463171656,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"115923bc88e5b1dc4bef049b1ded8486723052ed","date":1463216796,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f","date":1467384467,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptyMap());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2d3b6601ba8ff78129364caf7b3a2f8d01d81e43","date":1467767036,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptyMap());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.info(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptyMap());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f54f0eff6955cf57610f6b93dbbba3a2bf540619","date":1467968491,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.info(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptyMap());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.info(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"962cd4f5e313777f35da8f521265323e84184929","date":1474533758,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.info(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aac63b614f11eae7300a15a1ec9d8bee1e057e3b","date":1474972984,"type":3,"author":"Jan Hydahl","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.debug(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.debug(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.info(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.debug(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.info(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshLiveNodes(new LiveNodeWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState();\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.info(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.getKey() == null || pair.getKey().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.getKey()), 4, false);\n        cd.version = pair.getValue() == null ? -1 : pair.getValue().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b824daa61db3f30b91a22213d6c04e1fa2e2b06","date":1508385744,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.debug(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = Aliases.fromJSON(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.debug(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = ClusterState.load(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"215e40821821b2df2e69355e208532c05ef095a5","date":1510858642,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesHolder);\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n\n    synchronized (ZkStateReader.this.getUpdateLock()) {\n      constructState(Collections.emptySet());\n\n      zkClient.exists(ALIASES,\n          new Watcher() {\n            \n            @Override\n            public void process(WatchedEvent event) {\n              // session events are not change events, and do not remove the watcher\n              if (EventType.None.equals(event.getType())) {\n                return;\n              }\n              try {\n                synchronized (ZkStateReader.this.getUpdateLock()) {\n                  LOG.debug(\"Updating aliases... \");\n\n                  // remake watch\n                  final Watcher thisWatch = this;\n                  final Stat stat = new Stat();\n                  final byte[] data = zkClient.getData(ALIASES, thisWatch, stat, true);\n                  ZkStateReader.this.aliases = Aliases.fromJSON(data);\n                  LOG.debug(\"New alias definition is: \" + ZkStateReader.this.aliases.toString());\n                }\n              } catch (KeeperException.ConnectionLossException | KeeperException.SessionExpiredException e) {\n                LOG.warn(\"ZooKeeper watch triggered, but Solr cannot talk to ZK: [{}]\", e.getMessage());\n              } catch (KeeperException e) {\n                LOG.error(\"A ZK error has occurred\", e);\n                throw new ZooKeeperException(SolrException.ErrorCode.SERVER_ERROR, \"A ZK error has occurred\", e);\n              } catch (InterruptedException e) {\n                // Restore the interrupted status\n                Thread.currentThread().interrupt();\n                LOG.warn(\"Interrupted\", e);\n              }\n            }\n            \n          }, true);\n    }\n    updateAliases();\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3cbd743a4843f513f793670e3ab0e272bf824faf","date":1518149529,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesHolder);\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc64dbaabfd45a3fe2533c0b7daace3bbe45772e","date":1519728399,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecuritynodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"425608fe319a24666a13392bde3c85ba233d05d8","date":1521141680,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsWatches.forEach((k,v) -> {\n      new PropsWatcher(k).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"518199996073b2a0fc5dcb97ddea3717400b74c5","date":1521211448,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsWatches.forEach((k,v) -> {\n      new PropsWatcher(k).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsWatches.forEach((k,v) -> {\n      new PropsWatcher(k).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    LOG.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsWatches.forEach((k,v) -> {\n      new PropsWatcher(k).refreshAndWatch(true);\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad04daa4b07fab11f19bb17a8b556b0dde898d7f","date":1560262372,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsWatches.forEach((k,v) -> {\n      new PropsWatcher(k).refreshAndWatch(true);\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n              \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8dc9df63ec3bc509a28d29b0ddcf6f14756b3e76","date":1591450217,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException, InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshCollections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException,\n      InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // Sanity check ZK structure.\n    if (!zkClient.exists(CLUSTER_STATE, true)) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshLegacyClusterState(new LegacyClusterStateWatcher());\n    refreshStateFormat2Collections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","1072b8e47b50f1c4fb039e1f54a736f381d6f809","2668c99990e4c94a78bac005aa682b7c5986d23a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"463917d1b14d6e950fa80db37a0e798f5326f105","date":1591890616,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#createClusterStateWatchersAndUpdate().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException, InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    try {\n      // on reconnect of SolrZkClient force refresh and re-add watches.\n      loadClusterProperties();\n      refreshLiveNodes(new LiveNodeWatcher());\n      refreshCollections();\n      refreshCollectionList(new CollectionsChildWatcher());\n      refreshAliases(aliasesManager);\n\n      if (securityNodeListener != null) {\n        addSecurityNodeWatcher(pair -> {\n          ConfigData cd = new ConfigData();\n          cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n          cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n          securityData = cd;\n          securityNodeListener.run();\n        });\n        securityData = getSecurityProps(true);\n      }\n\n      collectionPropsObservers.forEach((k, v) -> {\n        collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n      });\n    } catch (KeeperException.NoNodeException nne) {\n      throw new SolrException(ErrorCode.SERVICE_UNAVAILABLE,\n          \"Cannot connect to cluster at \" + zkClient.getZkServerAddress() + \": cluster not found/not ready\");\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings({\"unchecked\"})\n  public synchronized void createClusterStateWatchersAndUpdate() throws KeeperException, InterruptedException {\n    // We need to fetch the current cluster state and the set of live nodes\n\n    log.debug(\"Updating cluster state from ZooKeeper... \");\n\n    // on reconnect of SolrZkClient force refresh and re-add watches.\n    loadClusterProperties();\n    refreshLiveNodes(new LiveNodeWatcher());\n    refreshCollections();\n    refreshCollectionList(new CollectionsChildWatcher());\n    refreshAliases(aliasesManager);\n\n    if (securityNodeListener != null) {\n      addSecurityNodeWatcher(pair -> {\n        ConfigData cd = new ConfigData();\n        cd.data = pair.first() == null || pair.first().length == 0 ? EMPTY_MAP : Utils.getDeepCopy((Map) fromJSON(pair.first()), 4, false);\n        cd.version = pair.second() == null ? -1 : pair.second().getVersion();\n        securityData = cd;\n        securityNodeListener.run();\n      });\n      securityData = getSecurityProps(true);\n    }\n\n    collectionPropsObservers.forEach((k, v) -> {\n      collectionPropsWatchers.computeIfAbsent(k, PropsWatcher::new).refreshAndWatch(true);\n    });\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f616abd7d3345b373ca3f5a49a3351a7a18eb741":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"f54f0eff6955cf57610f6b93dbbba3a2bf540619":["2d3b6601ba8ff78129364caf7b3a2f8d01d81e43"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["252e8087adc8ce3ff58a765302418a2c216a6e99"],"518199996073b2a0fc5dcb97ddea3717400b74c5":["bc64dbaabfd45a3fe2533c0b7daace3bbe45772e","425608fe319a24666a13392bde3c85ba233d05d8"],"8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d":["1b200b1e98a34247f0d84267e31d49d1c7304673"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["1525b4dfbc0d413b8d7247da232009778e624836"],"c824b5854f7ad30cd53f0634fc7cb533df74590b":["6aa13594d60227932a46e09d7219144b9c5115cd"],"1b200b1e98a34247f0d84267e31d49d1c7304673":["1cfa38e36fa296bb93d77df7d5556257dffa4535"],"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"e66a459d38c1c4a2f97128433dab546f683a9fed":["3a0c04b71951333291abc7f317109a6a5957bd28","da7373b6df772f51a66550c8080379e9ddf2e7db"],"f2126b84bd093fa3d921582a109a0ee578c28126":["da94fd5fcff99442877e118f00fb42094b59f497","d9405f486872f1e416304dfe389741f4ee2f8a4d"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["518199996073b2a0fc5dcb97ddea3717400b74c5"],"8dc9df63ec3bc509a28d29b0ddcf6f14756b3e76":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3a0c04b71951333291abc7f317109a6a5957bd28":["f616abd7d3345b373ca3f5a49a3351a7a18eb741"],"425608fe319a24666a13392bde3c85ba233d05d8":["bc64dbaabfd45a3fe2533c0b7daace3bbe45772e"],"463917d1b14d6e950fa80db37a0e798f5326f105":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"ba88c12c59ad335ca2ba493153932ba8ccd582ef":["7875fce026a0a335830cfc75abc3eb009eff9a73"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","6aa13594d60227932a46e09d7219144b9c5115cd"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["6aa13594d60227932a46e09d7219144b9c5115cd","da94fd5fcff99442877e118f00fb42094b59f497"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d","ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"66bcdf5bd26ae0a881d408a4ccfee95153bb4866":["0fc5446c5624aa38009cf373a69bd551b7415352"],"c0372f459e6b4348374eb3fbdbde69ee47840b71":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["c0372f459e6b4348374eb3fbdbde69ee47840b71"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"5b4df85b7268ca40452d6c01343d8eb00ed1f70a":["da7373b6df772f51a66550c8080379e9ddf2e7db"],"6bdcb86c29922edae9a14852e636303bc52df094":["ba88c12c59ad335ca2ba493153932ba8ccd582ef"],"2d3b6601ba8ff78129364caf7b3a2f8d01d81e43":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70":["8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"0ad30c6a479e764150a3316e57263319775f1df2":["da7373b6df772f51a66550c8080379e9ddf2e7db","115923bc88e5b1dc4bef049b1ded8486723052ed"],"da7373b6df772f51a66550c8080379e9ddf2e7db":["3a0c04b71951333291abc7f317109a6a5957bd28"],"1072b8e47b50f1c4fb039e1f54a736f381d6f809":["6bdcb86c29922edae9a14852e636303bc52df094"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["da7373b6df772f51a66550c8080379e9ddf2e7db","0ad30c6a479e764150a3316e57263319775f1df2"],"0fc5446c5624aa38009cf373a69bd551b7415352":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["9279b175e5e66258442d2123a50f052219a9cc1b","7875fce026a0a335830cfc75abc3eb009eff9a73"],"215e40821821b2df2e69355e208532c05ef095a5":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["8fd5be977c105554c6a7b68afcdbc511439723ab","da94fd5fcff99442877e118f00fb42094b59f497"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["f54f0eff6955cf57610f6b93dbbba3a2bf540619","aac63b614f11eae7300a15a1ec9d8bee1e057e3b"],"252e8087adc8ce3ff58a765302418a2c216a6e99":["66bcdf5bd26ae0a881d408a4ccfee95153bb4866"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"962cd4f5e313777f35da8f521265323e84184929":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["8dc9df63ec3bc509a28d29b0ddcf6f14756b3e76"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"407687e67faf6e1f02a211ca078d8e3eed631027":["d9405f486872f1e416304dfe389741f4ee2f8a4d","252e8087adc8ce3ff58a765302418a2c216a6e99"],"6aa13594d60227932a46e09d7219144b9c5115cd":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"bc64dbaabfd45a3fe2533c0b7daace3bbe45772e":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["fe33227f6805edab2036cbb80645cc4e2d1fa424","3f767f8c99eaedb984df754fe61f21c5de260f94"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["3a0c04b71951333291abc7f317109a6a5957bd28","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"9279b175e5e66258442d2123a50f052219a9cc1b":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["c824b5854f7ad30cd53f0634fc7cb533df74590b"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["215e40821821b2df2e69355e208532c05ef095a5"],"115923bc88e5b1dc4bef049b1ded8486723052ed":["5b4df85b7268ca40452d6c01343d8eb00ed1f70a"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7875fce026a0a335830cfc75abc3eb009eff9a73":["9279b175e5e66258442d2123a50f052219a9cc1b"],"da94fd5fcff99442877e118f00fb42094b59f497":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"aac63b614f11eae7300a15a1ec9d8bee1e057e3b":["962cd4f5e313777f35da8f521265323e84184929"],"1525b4dfbc0d413b8d7247da232009778e624836":["da94fd5fcff99442877e118f00fb42094b59f497"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["463917d1b14d6e950fa80db37a0e798f5326f105"]},"commit2Childs":{"f616abd7d3345b373ca3f5a49a3351a7a18eb741":["3a0c04b71951333291abc7f317109a6a5957bd28"],"f54f0eff6955cf57610f6b93dbbba3a2bf540619":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","962cd4f5e313777f35da8f521265323e84184929"],"1cfa38e36fa296bb93d77df7d5556257dffa4535":["1b200b1e98a34247f0d84267e31d49d1c7304673"],"518199996073b2a0fc5dcb97ddea3717400b74c5":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","ce7cfca1a733d2ed1f7089b339faf006bdcc7b70"],"d9405f486872f1e416304dfe389741f4ee2f8a4d":["f2126b84bd093fa3d921582a109a0ee578c28126","0fc5446c5624aa38009cf373a69bd551b7415352","407687e67faf6e1f02a211ca078d8e3eed631027"],"c824b5854f7ad30cd53f0634fc7cb533df74590b":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"1b200b1e98a34247f0d84267e31d49d1c7304673":["8ac5c44e4c5bbff62cdf26d21ec56e7a39619a2d"],"8bf04c3f77a2936f29948b9c0dd215d82d43f5cf":["c0372f459e6b4348374eb3fbdbde69ee47840b71"],"e66a459d38c1c4a2f97128433dab546f683a9fed":[],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["ad04daa4b07fab11f19bb17a8b556b0dde898d7f"],"8dc9df63ec3bc509a28d29b0ddcf6f14756b3e76":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"f4c07fa58a256dccf8b95364855fd5e9ad4d1401":["9279b175e5e66258442d2123a50f052219a9cc1b"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f":["2d3b6601ba8ff78129364caf7b3a2f8d01d81e43"],"425608fe319a24666a13392bde3c85ba233d05d8":["518199996073b2a0fc5dcb97ddea3717400b74c5"],"3a0c04b71951333291abc7f317109a6a5957bd28":["e66a459d38c1c4a2f97128433dab546f683a9fed","da7373b6df772f51a66550c8080379e9ddf2e7db","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"463917d1b14d6e950fa80db37a0e798f5326f105":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ba88c12c59ad335ca2ba493153932ba8ccd582ef":["6bdcb86c29922edae9a14852e636303bc52df094"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"66bcdf5bd26ae0a881d408a4ccfee95153bb4866":["252e8087adc8ce3ff58a765302418a2c216a6e99"],"c0372f459e6b4348374eb3fbdbde69ee47840b71":["7477015ee104ad8144fba06b9b0a8ea93aea50f8"],"7477015ee104ad8144fba06b9b0a8ea93aea50f8":["f616abd7d3345b373ca3f5a49a3351a7a18eb741"],"0622fbd990643ae4cacb693db6a0c82cf8916ae2":["a5a233896b7f16ac9b4ed601ef8207d98f1f0500"],"5b4df85b7268ca40452d6c01343d8eb00ed1f70a":["115923bc88e5b1dc4bef049b1ded8486723052ed"],"6bdcb86c29922edae9a14852e636303bc52df094":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"2d3b6601ba8ff78129364caf7b3a2f8d01d81e43":["f54f0eff6955cf57610f6b93dbbba3a2bf540619"],"ce7cfca1a733d2ed1f7089b339faf006bdcc7b70":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a5a233896b7f16ac9b4ed601ef8207d98f1f0500":["a6f693ed86f289b2e42b46684409b3997f2c264a"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"da7373b6df772f51a66550c8080379e9ddf2e7db":["e66a459d38c1c4a2f97128433dab546f683a9fed","5b4df85b7268ca40452d6c01343d8eb00ed1f70a","0ad30c6a479e764150a3316e57263319775f1df2","d470c8182e92b264680e34081b75e70a9f2b3c89"],"1072b8e47b50f1c4fb039e1f54a736f381d6f809":["8bf04c3f77a2936f29948b9c0dd215d82d43f5cf"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["b5a3dacb5a7d745cb12121c3b36d19d28dfd8a2f"],"0fc5446c5624aa38009cf373a69bd551b7415352":["66bcdf5bd26ae0a881d408a4ccfee95153bb4866"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"215e40821821b2df2e69355e208532c05ef095a5":["3cbd743a4843f513f793670e3ab0e272bf824faf"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"2668c99990e4c94a78bac005aa682b7c5986d23a":["8dc9df63ec3bc509a28d29b0ddcf6f14756b3e76"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","0d22ac6a4146774c1bc8400160fc0b6150294e92","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["6b824daa61db3f30b91a22213d6c04e1fa2e2b06","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"252e8087adc8ce3ff58a765302418a2c216a6e99":["1cfa38e36fa296bb93d77df7d5556257dffa4535","407687e67faf6e1f02a211ca078d8e3eed631027"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0622fbd990643ae4cacb693db6a0c82cf8916ae2"],"962cd4f5e313777f35da8f521265323e84184929":["aac63b614f11eae7300a15a1ec9d8bee1e057e3b"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["463917d1b14d6e950fa80db37a0e798f5326f105"],"6b824daa61db3f30b91a22213d6c04e1fa2e2b06":["215e40821821b2df2e69355e208532c05ef095a5"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"6aa13594d60227932a46e09d7219144b9c5115cd":["c824b5854f7ad30cd53f0634fc7cb533df74590b","fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"ad04daa4b07fab11f19bb17a8b556b0dde898d7f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"bc64dbaabfd45a3fe2533c0b7daace3bbe45772e":["518199996073b2a0fc5dcb97ddea3717400b74c5","425608fe319a24666a13392bde3c85ba233d05d8"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"9279b175e5e66258442d2123a50f052219a9cc1b":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","7875fce026a0a335830cfc75abc3eb009eff9a73"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["8fd5be977c105554c6a7b68afcdbc511439723ab","da94fd5fcff99442877e118f00fb42094b59f497"],"a6f693ed86f289b2e42b46684409b3997f2c264a":["f4c07fa58a256dccf8b95364855fd5e9ad4d1401"],"3cbd743a4843f513f793670e3ab0e272bf824faf":["bc64dbaabfd45a3fe2533c0b7daace3bbe45772e"],"115923bc88e5b1dc4bef049b1ded8486723052ed":["0ad30c6a479e764150a3316e57263319775f1df2"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","fe33227f6805edab2036cbb80645cc4e2d1fa424","0d22ac6a4146774c1bc8400160fc0b6150294e92","6aa13594d60227932a46e09d7219144b9c5115cd"],"7875fce026a0a335830cfc75abc3eb009eff9a73":["ba88c12c59ad335ca2ba493153932ba8ccd582ef","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"da94fd5fcff99442877e118f00fb42094b59f497":["f2126b84bd093fa3d921582a109a0ee578c28126","d6f074e73200c07d54f242d3880a8da5a35ff97b","c7869f64c874ebf7f317d22c00baf2b6857797a6","1525b4dfbc0d413b8d7247da232009778e624836"],"aac63b614f11eae7300a15a1ec9d8bee1e057e3b":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"1525b4dfbc0d413b8d7247da232009778e624836":["d9405f486872f1e416304dfe389741f4ee2f8a4d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e66a459d38c1c4a2f97128433dab546f683a9fed","f2126b84bd093fa3d921582a109a0ee578c28126","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","d6f074e73200c07d54f242d3880a8da5a35ff97b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","c7869f64c874ebf7f317d22c00baf2b6857797a6","407687e67faf6e1f02a211ca078d8e3eed631027","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}