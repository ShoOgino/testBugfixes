{"path":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","commits":[{"id":"226aae72c0326f4299c16280195bade4530de537","date":1324221898,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"/dev/null","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = mockSearcher.getIndexReader().getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ced66195b26fdb1f77ee00e2a77ec6918dedd766"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19a806c08dc7062fea18c513411ff4eb6643e58e","date":1327864150,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeIndexReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = mockSearcher.getIndexReader().getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da6d5ac19a80d65b1e864251f155d30960353b7e","date":1327881054,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeIndexReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = mockSearcher.getIndexReader().getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","pathOld":"lucene/src/test/org/apache/lucene/search/TestShardSearching#assertSame(IndexSearcher,NodeState.ShardIndexSearcher,Query,Sort,PreviousSearchState).mjava","sourceNew":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","sourceOld":"  private PreviousSearchState assertSame(IndexSearcher mockSearcher, NodeState.ShardIndexSearcher shardSearcher, Query q, Sort sort, PreviousSearchState state) throws IOException {\n\n    int numHits = _TestUtil.nextInt(random, 1, 100);\n    if (state != null && state.searchAfterLocal == null) {\n      // In addition to what we last searched:\n      numHits += state.numHitsPaged;\n    }\n\n    if (VERBOSE) {\n      System.out.println(\"TEST: query=\" + q + \" sort=\" + sort + \" numHits=\" + numHits);\n      if (state != null) {\n        System.out.println(\"  prev: searchAfterLocal=\" + state.searchAfterLocal + \" searchAfterShard=\" + state.searchAfterShard + \" numHitsPaged=\" + state.numHitsPaged);\n      }\n    }\n\n    // Single (mock local) searcher:\n    final TopDocs hits;\n    if (sort == null) {\n      if (state != null && state.searchAfterLocal != null) {\n        hits = mockSearcher.searchAfter(state.searchAfterLocal, q, numHits);\n      } else {\n        hits = mockSearcher.search(q, numHits);\n      }\n    } else {\n      hits = mockSearcher.search(q, numHits, sort);\n    }\n\n    // Shard searcher\n    final TopDocs shardHits;\n    if (sort == null) {\n      if (state != null && state.searchAfterShard != null) {\n        shardHits = shardSearcher.searchAfter(state.searchAfterShard, q, numHits);\n      } else {\n        shardHits = shardSearcher.search(q, numHits);\n      }\n    } else {\n      shardHits = shardSearcher.search(q, numHits, sort);\n    }\n\n    final int numNodes = shardSearcher.nodeVersions.length;\n    int[] base = new int[numNodes];\n    final IndexReader[] subs = ((CompositeReader) mockSearcher.getIndexReader()).getSequentialSubReaders();\n    assertEquals(numNodes, subs.length);\n\n    int docCount = 0;\n    for(int nodeID=0;nodeID<numNodes;nodeID++) {\n      base[nodeID] = docCount;\n      docCount += subs[nodeID].maxDoc();\n    }\n\n    if (VERBOSE) {\n      /*\n      for(int shardID=0;shardID<shardSearchers.length;shardID++) {\n        System.out.println(\"  shard=\" + shardID + \" maxDoc=\" + shardSearchers[shardID].searcher.getIndexReader().maxDoc());\n      }\n      */\n      System.out.println(\"  single searcher: \" + hits.totalHits + \" totalHits maxScore=\" + hits.getMaxScore());\n      for(int i=0;i<hits.scoreDocs.length;i++) {\n        final ScoreDoc sd = hits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" score=\" + sd.score);\n      }\n      System.out.println(\"  shard searcher: \" + shardHits.totalHits + \" totalHits maxScore=\" + shardHits.getMaxScore());\n      for(int i=0;i<shardHits.scoreDocs.length;i++) {\n        final ScoreDoc sd = shardHits.scoreDocs[i];\n        System.out.println(\"    doc=\" + sd.doc + \" (rebased: \" + (sd.doc + base[sd.shardIndex]) + \") score=\" + sd.score + \" shard=\" + sd.shardIndex);\n      }\n    }\n\n    int numHitsPaged;\n    if (state != null && state.searchAfterLocal != null) {\n      numHitsPaged = hits.scoreDocs.length; \n      if (state != null) {\n        numHitsPaged += state.numHitsPaged;\n      }\n    } else {\n      numHitsPaged = hits.scoreDocs.length;\n    }\n\n    final boolean moreHits;\n\n    final ScoreDoc bottomHit;\n    final ScoreDoc bottomHitShards;\n\n    if (numHitsPaged < hits.totalHits) {\n      // More hits to page through\n      moreHits = true;\n      if (sort == null) {\n        bottomHit = hits.scoreDocs[hits.scoreDocs.length-1];\n        final ScoreDoc sd = shardHits.scoreDocs[shardHits.scoreDocs.length-1];\n        // Must copy because below we rebase:\n        bottomHitShards = new ScoreDoc(sd.doc, sd.score, sd.shardIndex);\n        if (VERBOSE) {\n          System.out.println(\"  save bottomHit=\" + bottomHit);\n        }\n      } else {\n        bottomHit = null;\n        bottomHitShards = null;\n      }\n\n    } else {\n      assertEquals(hits.totalHits, numHitsPaged);\n      bottomHit = null;\n      bottomHitShards = null;\n      moreHits = false;\n    }\n\n    // Must rebase so assertEquals passes:\n    for(int hitID=0;hitID<shardHits.scoreDocs.length;hitID++) {\n      final ScoreDoc sd = shardHits.scoreDocs[hitID];\n      sd.doc += base[sd.shardIndex];\n    }\n\n    _TestUtil.assertEquals(hits, shardHits);\n\n    if (moreHits) {\n      // Return a continuation:\n      return new PreviousSearchState(q, sort, bottomHit, bottomHitShards, shardSearcher.nodeVersions, numHitsPaged);\n    } else {\n      return null;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"19a806c08dc7062fea18c513411ff4eb6643e58e":["226aae72c0326f4299c16280195bade4530de537"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["19a806c08dc7062fea18c513411ff4eb6643e58e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"226aae72c0326f4299c16280195bade4530de537":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5cab9a86bd67202d20b6adc463008c8e982b070a":["226aae72c0326f4299c16280195bade4530de537","da6d5ac19a80d65b1e864251f155d30960353b7e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"19a806c08dc7062fea18c513411ff4eb6643e58e":["da6d5ac19a80d65b1e864251f155d30960353b7e"],"da6d5ac19a80d65b1e864251f155d30960353b7e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"226aae72c0326f4299c16280195bade4530de537":["19a806c08dc7062fea18c513411ff4eb6643e58e","5cab9a86bd67202d20b6adc463008c8e982b070a"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["226aae72c0326f4299c16280195bade4530de537"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}