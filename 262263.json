{"path":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","commits":[{"id":"ae695f21c50b03702b5d0fa2543d5af844bb7cd3","date":1331554994,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"38e3b736c7ca086d61b7dbb841c905ee115490da","date":1331657018,"type":1,"author":"Ryan McKinley","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],IndexWriter.ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, IndexWriter.ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"211b1506e56f7860762fbd4698f6d1d1b57f672c","date":1344976996,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","date":1345029782,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3c188105a9aae04f56c24996f98f8333fc825d2e","date":1345031914,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c93396a1df03720cb20e2c2f513a6fa59b21e4c","date":1345032673,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b05c56a41b733e02a189c48895922b5bd8c7f3d1","date":1345033322,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getTopReaderContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":5,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/BufferedUpdatesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndUpdates,SegmentReader).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/BufferedDeletesStream#applyQueryDeletes(Iterable[QueryAndLimit],ReadersAndLiveDocs,SegmentReader).mjava","sourceNew":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndUpdates rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","sourceOld":"  // Delete by query\n  private static long applyQueryDeletes(Iterable<QueryAndLimit> queriesIter, ReadersAndLiveDocs rld, final SegmentReader reader) throws IOException {\n    long delCount = 0;\n    final AtomicReaderContext readerContext = reader.getContext();\n    boolean any = false;\n    for (QueryAndLimit ent : queriesIter) {\n      Query query = ent.query;\n      int limit = ent.limit;\n      final DocIdSet docs = new QueryWrapperFilter(query).getDocIdSet(readerContext, reader.getLiveDocs());\n      if (docs != null) {\n        final DocIdSetIterator it = docs.iterator();\n        if (it != null) {\n          while(true)  {\n            int doc = it.nextDoc();\n            if (doc >= limit) {\n              break;\n            }\n\n            if (!any) {\n              rld.initWritableLiveDocs();\n              any = true;\n            }\n\n            if (rld.delete(doc)) {\n              delCount++;\n            }\n          }\n        }\n      }\n    }\n\n    return delCount;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"38e3b736c7ca086d61b7dbb841c905ee115490da":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["211b1506e56f7860762fbd4698f6d1d1b57f672c"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["3c188105a9aae04f56c24996f98f8333fc825d2e"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","211b1506e56f7860762fbd4698f6d1d1b57f672c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"]},"commit2Childs":{"38e3b736c7ca086d61b7dbb841c905ee115490da":[],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3c188105a9aae04f56c24996f98f8333fc825d2e":["1c93396a1df03720cb20e2c2f513a6fa59b21e4c"],"b05c56a41b733e02a189c48895922b5bd8c7f3d1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["38e3b736c7ca086d61b7dbb841c905ee115490da","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"1c93396a1df03720cb20e2c2f513a6fa59b21e4c":["b05c56a41b733e02a189c48895922b5bd8c7f3d1"],"ae695f21c50b03702b5d0fa2543d5af844bb7cd3":["38e3b736c7ca086d61b7dbb841c905ee115490da","3c188105a9aae04f56c24996f98f8333fc825d2e","211b1506e56f7860762fbd4698f6d1d1b57f672c","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"211b1506e56f7860762fbd4698f6d1d1b57f672c":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198"],"c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["38e3b736c7ca086d61b7dbb841c905ee115490da","b05c56a41b733e02a189c48895922b5bd8c7f3d1","c1fe8ee1a5a1ef00a9c4793ec26f17bd90342198","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}