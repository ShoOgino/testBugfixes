{"path":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","commits":[{"id":"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","date":1462567286,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"/dev/null","sourceNew":"  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: check index sort.....\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n        // nocommit we prevent SCORE?\n        //comparators[i].setScorer(FAKESCORER);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45bfb4d30b7e62ec7d645a5e0113362636ac4981","date":1462660573,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","sourceNew":"  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: check index sort.....\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: check index sort.....\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n        // nocommit we prevent SCORE?\n        //comparators[i].setScorer(FAKESCORER);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd","date":1463081111,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","sourceNew":"  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: check index sort.....\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c23672acbb5104509c1c2d6e3dda7a08eaf091f","date":1463128188,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3d33e731a93d4b57e662ff094f64f94a745422d4","date":1463128289,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ad30c6a479e764150a3316e57263319775f1df2","date":1463395403,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","date":1493374641,"type":3,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/CheckIndex#testSort(CodecReader,Sort,PrintStream,boolean).mjava","sourceNew":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          throw IOUtils.rethrowAlways(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","sourceOld":"  /**\n   * Tests index sort order.\n   * @lucene.experimental\n   */\n  public static Status.IndexSortStatus testSort(CodecReader reader, Sort sort, PrintStream infoStream, boolean failFast) throws IOException {\n    // This segment claims its documents are sorted according to the incoming sort ... let's make sure:\n\n    long startNS = System.nanoTime();\n\n    Status.IndexSortStatus status = new Status.IndexSortStatus();\n\n    if (sort != null) {\n      if (infoStream != null) {\n        infoStream.print(\"    test: index sort..........\");\n      }\n\n      SortField fields[] = sort.getSort();\n      final int reverseMul[] = new int[fields.length];\n      final LeafFieldComparator comparators[] = new LeafFieldComparator[fields.length];\n\n      LeafReaderContext readerContext = new LeafReaderContext(reader);\n    \n      for (int i = 0; i < fields.length; i++) {\n        reverseMul[i] = fields[i].getReverse() ? -1 : 1;\n        comparators[i] = fields[i].getComparator(1, i).getLeafComparator(readerContext);\n      }\n\n      int maxDoc = reader.maxDoc();\n\n      try {\n\n        for(int docID=1;docID < maxDoc;docID++) {\n      \n          int cmp = 0;\n\n          for (int i = 0; i < comparators.length; i++) {\n            // TODO: would be better if copy() didnt cause a term lookup in TermOrdVal & co,\n            // the segments are always the same here...\n            comparators[i].copy(0, docID-1);\n            comparators[i].setBottom(0);\n            cmp = reverseMul[i] * comparators[i].compareBottom(docID);\n            if (cmp != 0) {\n              break;\n            }\n          }\n\n          if (cmp > 0) {\n            throw new RuntimeException(\"segment has indexSort=\" + sort + \" but docID=\" + (docID-1) + \" sorts after docID=\" + docID);\n          }\n        }\n        msg(infoStream, String.format(Locale.ROOT, \"OK [took %.3f sec]\", nsToSec(System.nanoTime()-startNS)));\n      } catch (Throwable e) {\n        if (failFast) {\n          IOUtils.reThrow(e);\n        }\n        msg(infoStream, \"ERROR [\" + String.valueOf(e.getMessage()) + \"]\");\n        status.error = e;\n        if (infoStream != null) {\n          e.printStackTrace(infoStream);\n        }\n      }\n    }\n\n    return status;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["d470c8182e92b264680e34081b75e70a9f2b3c89","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"9c23672acbb5104509c1c2d6e3dda7a08eaf091f":["0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"0ad30c6a479e764150a3316e57263319775f1df2":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3d33e731a93d4b57e662ff094f64f94a745422d4"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9c23672acbb5104509c1c2d6e3dda7a08eaf091f"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["97fc96e6cc460e0ec1fb904a9c7ecd80680780c2"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0ad30c6a479e764150a3316e57263319775f1df2"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"45bfb4d30b7e62ec7d645a5e0113362636ac4981":["0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd"],"97fc96e6cc460e0ec1fb904a9c7ecd80680780c2":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9c23672acbb5104509c1c2d6e3dda7a08eaf091f":["3d33e731a93d4b57e662ff094f64f94a745422d4"],"0a6d0e4c7ab9c0e1fc073fddd21f4784555be9cd":["9c23672acbb5104509c1c2d6e3dda7a08eaf091f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ad30c6a479e764150a3316e57263319775f1df2","3d33e731a93d4b57e662ff094f64f94a745422d4","fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89"],"0ad30c6a479e764150a3316e57263319775f1df2":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"3d33e731a93d4b57e662ff094f64f94a745422d4":["0ad30c6a479e764150a3316e57263319775f1df2"],"fbe8fc0e68a5e2e7acce82ba880a982bd15cfab8":["45bfb4d30b7e62ec7d645a5e0113362636ac4981"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["e9017cf144952056066919f1ebc7897ff9bd71b1","97fc96e6cc460e0ec1fb904a9c7ecd80680780c2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}