{"path":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#iterator().mjava","commits":[{"id":"523cc6563c99a55527ef7993efc5413c6648852d","date":1518704038,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#iterator().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public DocIdSetIterator iterator() {\n    // TODO: support two-phase\n    final Scorer leadScorer = this.scorers[0]; // higher max score\n    final DocIdSetIterator[] iterators = Arrays.stream(this.scorers)\n        .map(Scorer::iterator)\n        .toArray(DocIdSetIterator[]::new);\n    final DocIdSetIterator lead = iterators[0];\n\n    return new DocIdSetIterator() {\n\n      float maxScore;\n      int upTo = -1;\n\n      @Override\n      public int docID() {\n        return lead.docID();\n      }\n\n      @Override\n      public long cost() {\n        return lead.cost();\n      }\n\n      private void moveToNextBlock(int target) throws IOException {\n        upTo = advanceShallow(target);\n        maxScore = getMaxScore(upTo);\n\n        // Also compute the minimum required scores for a hit to be competitive\n        // A double that is less than 'score' might still be converted to 'score'\n        // when casted to a float, so we go to the previous float to avoid this issue\n        minScores[minScores.length - 1] = minScore > 0 ? Math.nextDown(minScore) : 0;\n        for (int i = scorers.length - 1; i > 0; --i) {\n          double minScore = minScores[i];\n          float clauseMaxScore = scorers[i].getMaxScore(upTo);\n          if (minScore > clauseMaxScore) {\n            minScores[i - 1] = minScore - clauseMaxScore;\n            assert minScores[i - 1] + clauseMaxScore <= minScore;\n          } else {\n            minScores[i - 1] = 0;\n          }\n        }\n      }\n\n      private int advanceTarget(int target) throws IOException {\n        if (target > upTo) {\n          moveToNextBlock(target);\n        }\n\n        while (true) {\n          assert upTo >= target;\n\n          if (maxScore >= minScore) {\n            return target;\n          }\n\n          if (upTo == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          target = upTo + 1;\n\n          moveToNextBlock(target);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(docID() + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        return doNext(lead.advance(advanceTarget(target)));\n      }\n\n      private int doNext(int doc) throws IOException {\n        advanceHead: for(;;) {\n          assert doc == lead.docID();\n\n          if (doc == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          if (minScore > 0) {\n            score = leadScorer.score();\n            if (score < minScores[0]) {\n              // computing a score is usually less costly than advancing other clauses\n              doc = lead.advance(advanceTarget(doc + 1));\n              continue;\n            }\n          }\n\n          // then find agreement with other iterators\n          for (int i = 1; i < iterators.length; ++i) {\n            final DocIdSetIterator other = iterators[i];\n            // other.doc may already be equal to doc if we \"continued advanceHead\"\n            // on the previous iteration and the advance on the lead scorer exactly matched.\n            if (other.docID() < doc) {\n              final int next = other.advance(doc);\n\n              if (next > doc) {\n                // iterator beyond the current doc - advance lead and continue to the new highest doc.\n                doc = lead.advance(advanceTarget(next));\n                continue advanceHead;\n              }\n            }\n\n            assert other.docID() == doc;\n            if (minScore > 0) {\n              score += scorers[i].score();\n\n              if (score < minScores[i]) {\n                // computing a score is usually less costly than advancing the next clause\n                doc = lead.advance(advanceTarget(doc + 1));\n                continue advanceHead;\n              }\n            }\n          }\n\n          if (minScore > 0 == false) {\n            // the score hasn't been computed on the fly, do it now\n            score = 0;\n            for (Scorer scorer : scorers) {\n              score += scorer.score();\n            }\n          }\n\n          // success - all iterators are on the same doc and the score is competitive\n          return doc;\n        }\n      }\n    };\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01967f1f709d807c3f23282f58183b20091bb073","date":1532509031,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#iterator().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#iterator().mjava","sourceNew":"  @Override\n  public DocIdSetIterator iterator() {\n    // TODO: support two-phase\n    final Scorer leadScorer = this.scorers[0]; // higher max score\n    final DocIdSetIterator[] iterators = Arrays.stream(this.scorers)\n        .map(Scorer::iterator)\n        .toArray(DocIdSetIterator[]::new);\n    final DocIdSetIterator lead = iterators[0];\n\n    return new DocIdSetIterator() {\n\n      float maxScore;\n      int upTo = -1;\n\n      @Override\n      public int docID() {\n        return lead.docID();\n      }\n\n      @Override\n      public long cost() {\n        return lead.cost();\n      }\n\n      private void moveToNextBlock(int target) throws IOException {\n        upTo = advanceShallow(target);\n        maxScore = getMaxScore(upTo);\n\n        // Also compute the minimum required scores for a hit to be competitive\n        // A double that is less than 'score' might still be converted to 'score'\n        // when casted to a float, so we go to the previous float to avoid this issue\n        minScores[minScores.length - 1] = minScore > 0 ? Math.nextDown(minScore) : 0;\n        for (int i = scorers.length - 1; i > 0; --i) {\n          double minScore = minScores[i];\n          float clauseMaxScore = scorers[i].getMaxScore(upTo);\n          if (minScore > clauseMaxScore) {\n            minScores[i - 1] = minScore - clauseMaxScore;\n            assert minScores[i - 1] + clauseMaxScore <= minScore;\n          } else {\n            minScores[i - 1] = 0;\n          }\n        }\n      }\n\n      private int advanceTarget(int target) throws IOException {\n        if (target > upTo) {\n          moveToNextBlock(target);\n        }\n\n        while (true) {\n          assert upTo >= target;\n\n          if (maxScore >= minScore) {\n            return target;\n          }\n\n          if (upTo == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          target = upTo + 1;\n\n          moveToNextBlock(target);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(docID() + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        return doNext(lead.advance(advanceTarget(target)));\n      }\n\n      private int doNext(int doc) throws IOException {\n        advanceHead: for(;;) {\n          assert doc == lead.docID();\n\n          if (doc == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          if (doc > upTo) {\n            // This check is useful when scorers return information about blocks\n            // that do not actually have any matches. Otherwise `doc` will always\n            // be in the current block already since it is always the result of\n            // lead.advance(advanceTarget(some_doc_id))\n            final int nextTarget = advanceTarget(doc);\n            if (nextTarget != doc) {\n              doc = lead.advance(nextTarget);\n              continue;\n            }\n          }\n\n          assert doc <= upTo;\n\n          if (minScore > 0) {\n            score = leadScorer.score();\n            if (score < minScores[0]) {\n              // computing a score is usually less costly than advancing other clauses\n              doc = lead.advance(advanceTarget(doc + 1));\n              continue;\n            }\n          }\n\n          // then find agreement with other iterators\n          for (int i = 1; i < iterators.length; ++i) {\n            final DocIdSetIterator other = iterators[i];\n            // other.doc may already be equal to doc if we \"continued advanceHead\"\n            // on the previous iteration and the advance on the lead scorer exactly matched.\n            if (other.docID() < doc) {\n              final int next = other.advance(doc);\n\n              if (next > doc) {\n                // iterator beyond the current doc - advance lead and continue to the new highest doc.\n                doc = lead.advance(advanceTarget(next));\n                continue advanceHead;\n              }\n            }\n\n            assert other.docID() == doc;\n            if (minScore > 0) {\n              score += scorers[i].score();\n\n              if (score < minScores[i]) {\n                // computing a score is usually less costly than advancing the next clause\n                doc = lead.advance(advanceTarget(doc + 1));\n                continue advanceHead;\n              }\n            }\n          }\n\n          if (minScore > 0 == false) {\n            // the score hasn't been computed on the fly, do it now\n            score = 0;\n            for (Scorer scorer : scorers) {\n              score += scorer.score();\n            }\n          }\n\n          // success - all iterators are on the same doc and the score is competitive\n          return doc;\n        }\n      }\n    };\n  }\n\n","sourceOld":"  @Override\n  public DocIdSetIterator iterator() {\n    // TODO: support two-phase\n    final Scorer leadScorer = this.scorers[0]; // higher max score\n    final DocIdSetIterator[] iterators = Arrays.stream(this.scorers)\n        .map(Scorer::iterator)\n        .toArray(DocIdSetIterator[]::new);\n    final DocIdSetIterator lead = iterators[0];\n\n    return new DocIdSetIterator() {\n\n      float maxScore;\n      int upTo = -1;\n\n      @Override\n      public int docID() {\n        return lead.docID();\n      }\n\n      @Override\n      public long cost() {\n        return lead.cost();\n      }\n\n      private void moveToNextBlock(int target) throws IOException {\n        upTo = advanceShallow(target);\n        maxScore = getMaxScore(upTo);\n\n        // Also compute the minimum required scores for a hit to be competitive\n        // A double that is less than 'score' might still be converted to 'score'\n        // when casted to a float, so we go to the previous float to avoid this issue\n        minScores[minScores.length - 1] = minScore > 0 ? Math.nextDown(minScore) : 0;\n        for (int i = scorers.length - 1; i > 0; --i) {\n          double minScore = minScores[i];\n          float clauseMaxScore = scorers[i].getMaxScore(upTo);\n          if (minScore > clauseMaxScore) {\n            minScores[i - 1] = minScore - clauseMaxScore;\n            assert minScores[i - 1] + clauseMaxScore <= minScore;\n          } else {\n            minScores[i - 1] = 0;\n          }\n        }\n      }\n\n      private int advanceTarget(int target) throws IOException {\n        if (target > upTo) {\n          moveToNextBlock(target);\n        }\n\n        while (true) {\n          assert upTo >= target;\n\n          if (maxScore >= minScore) {\n            return target;\n          }\n\n          if (upTo == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          target = upTo + 1;\n\n          moveToNextBlock(target);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(docID() + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        return doNext(lead.advance(advanceTarget(target)));\n      }\n\n      private int doNext(int doc) throws IOException {\n        advanceHead: for(;;) {\n          assert doc == lead.docID();\n\n          if (doc == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          if (minScore > 0) {\n            score = leadScorer.score();\n            if (score < minScores[0]) {\n              // computing a score is usually less costly than advancing other clauses\n              doc = lead.advance(advanceTarget(doc + 1));\n              continue;\n            }\n          }\n\n          // then find agreement with other iterators\n          for (int i = 1; i < iterators.length; ++i) {\n            final DocIdSetIterator other = iterators[i];\n            // other.doc may already be equal to doc if we \"continued advanceHead\"\n            // on the previous iteration and the advance on the lead scorer exactly matched.\n            if (other.docID() < doc) {\n              final int next = other.advance(doc);\n\n              if (next > doc) {\n                // iterator beyond the current doc - advance lead and continue to the new highest doc.\n                doc = lead.advance(advanceTarget(next));\n                continue advanceHead;\n              }\n            }\n\n            assert other.docID() == doc;\n            if (minScore > 0) {\n              score += scorers[i].score();\n\n              if (score < minScores[i]) {\n                // computing a score is usually less costly than advancing the next clause\n                doc = lead.advance(advanceTarget(doc + 1));\n                continue advanceHead;\n              }\n            }\n          }\n\n          if (minScore > 0 == false) {\n            // the score hasn't been computed on the fly, do it now\n            score = 0;\n            for (Scorer scorer : scorers) {\n              score += scorer.score();\n            }\n          }\n\n          // success - all iterators are on the same doc and the score is competitive\n          return doc;\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac","date":1558431344,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#iterator().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/BlockMaxConjunctionScorer#iterator().mjava","sourceNew":"  @Override\n  public DocIdSetIterator iterator() {\n    return twoPhases.length == 0 ? approximation() :\n        TwoPhaseIterator.asDocIdSetIterator(twoPhaseIterator());\n  }\n\n","sourceOld":"  @Override\n  public DocIdSetIterator iterator() {\n    // TODO: support two-phase\n    final Scorer leadScorer = this.scorers[0]; // higher max score\n    final DocIdSetIterator[] iterators = Arrays.stream(this.scorers)\n        .map(Scorer::iterator)\n        .toArray(DocIdSetIterator[]::new);\n    final DocIdSetIterator lead = iterators[0];\n\n    return new DocIdSetIterator() {\n\n      float maxScore;\n      int upTo = -1;\n\n      @Override\n      public int docID() {\n        return lead.docID();\n      }\n\n      @Override\n      public long cost() {\n        return lead.cost();\n      }\n\n      private void moveToNextBlock(int target) throws IOException {\n        upTo = advanceShallow(target);\n        maxScore = getMaxScore(upTo);\n\n        // Also compute the minimum required scores for a hit to be competitive\n        // A double that is less than 'score' might still be converted to 'score'\n        // when casted to a float, so we go to the previous float to avoid this issue\n        minScores[minScores.length - 1] = minScore > 0 ? Math.nextDown(minScore) : 0;\n        for (int i = scorers.length - 1; i > 0; --i) {\n          double minScore = minScores[i];\n          float clauseMaxScore = scorers[i].getMaxScore(upTo);\n          if (minScore > clauseMaxScore) {\n            minScores[i - 1] = minScore - clauseMaxScore;\n            assert minScores[i - 1] + clauseMaxScore <= minScore;\n          } else {\n            minScores[i - 1] = 0;\n          }\n        }\n      }\n\n      private int advanceTarget(int target) throws IOException {\n        if (target > upTo) {\n          moveToNextBlock(target);\n        }\n\n        while (true) {\n          assert upTo >= target;\n\n          if (maxScore >= minScore) {\n            return target;\n          }\n\n          if (upTo == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          target = upTo + 1;\n\n          moveToNextBlock(target);\n        }\n      }\n\n      @Override\n      public int nextDoc() throws IOException {\n        return advance(docID() + 1);\n      }\n\n      @Override\n      public int advance(int target) throws IOException {\n        return doNext(lead.advance(advanceTarget(target)));\n      }\n\n      private int doNext(int doc) throws IOException {\n        advanceHead: for(;;) {\n          assert doc == lead.docID();\n\n          if (doc == NO_MORE_DOCS) {\n            return NO_MORE_DOCS;\n          }\n\n          if (doc > upTo) {\n            // This check is useful when scorers return information about blocks\n            // that do not actually have any matches. Otherwise `doc` will always\n            // be in the current block already since it is always the result of\n            // lead.advance(advanceTarget(some_doc_id))\n            final int nextTarget = advanceTarget(doc);\n            if (nextTarget != doc) {\n              doc = lead.advance(nextTarget);\n              continue;\n            }\n          }\n\n          assert doc <= upTo;\n\n          if (minScore > 0) {\n            score = leadScorer.score();\n            if (score < minScores[0]) {\n              // computing a score is usually less costly than advancing other clauses\n              doc = lead.advance(advanceTarget(doc + 1));\n              continue;\n            }\n          }\n\n          // then find agreement with other iterators\n          for (int i = 1; i < iterators.length; ++i) {\n            final DocIdSetIterator other = iterators[i];\n            // other.doc may already be equal to doc if we \"continued advanceHead\"\n            // on the previous iteration and the advance on the lead scorer exactly matched.\n            if (other.docID() < doc) {\n              final int next = other.advance(doc);\n\n              if (next > doc) {\n                // iterator beyond the current doc - advance lead and continue to the new highest doc.\n                doc = lead.advance(advanceTarget(next));\n                continue advanceHead;\n              }\n            }\n\n            assert other.docID() == doc;\n            if (minScore > 0) {\n              score += scorers[i].score();\n\n              if (score < minScores[i]) {\n                // computing a score is usually less costly than advancing the next clause\n                doc = lead.advance(advanceTarget(doc + 1));\n                continue advanceHead;\n              }\n            }\n          }\n\n          if (minScore > 0 == false) {\n            // the score hasn't been computed on the fly, do it now\n            score = 0;\n            for (Scorer scorer : scorers) {\n              score += scorer.score();\n            }\n          }\n\n          // success - all iterators are on the same doc and the score is competitive\n          return doc;\n        }\n      }\n    };\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac":["01967f1f709d807c3f23282f58183b20091bb073"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"01967f1f709d807c3f23282f58183b20091bb073":["523cc6563c99a55527ef7993efc5413c6648852d"],"523cc6563c99a55527ef7993efc5413c6648852d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac"]},"commit2Childs":{"edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["523cc6563c99a55527ef7993efc5413c6648852d"],"01967f1f709d807c3f23282f58183b20091bb073":["edc1c8fc0262c6b5526c8e0e23f9b72ddcff6aac"],"523cc6563c99a55527ef7993efc5413c6648852d":["01967f1f709d807c3f23282f58183b20091bb073"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}