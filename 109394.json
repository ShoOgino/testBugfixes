{"path":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","commits":[{"id":"b64a4420c88dd81303e7f7959057baf9f3b45f94","date":1346077333,"type":0,"author":"Martijn van Groningen","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"/dev/null","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"05a14b2611ead08655a2b2bdc61632eb31316e57","date":1346366621,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"/dev/null","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15250ca94ba8ab3bcdd476daf6bf3f3febb92640","date":1355200097,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, 0);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8","date":1373996650,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare), true)) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"51f5280f31484820499077f41fcdfe92d527d9dc","date":1423229122,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      PostingsEnum postingsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      DocsEnum docsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          docsEnum = termsEnum.docs(acceptDocs, docsEnum, DocsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = docsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = docsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e73063b92d958076ef4ae8beb5f493e8ccdcecb4","date":1424177215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      PostingsEnum postingsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      PostingsEnum postingsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.FLAG_NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,TermsEnum).mjava","pathOld":"lucene/join/src/java/org/apache/lucene/search/join/TermsIncludingScoreQuery.SVInOrderScorer#fillDocsAndScores(FixedBitSet,Bits,TermsEnum).mjava","sourceNew":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      PostingsEnum postingsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          postingsEnum = termsEnum.postings(postingsEnum, PostingsEnum.NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","sourceOld":"    protected void fillDocsAndScores(FixedBitSet matchingDocs, Bits acceptDocs, TermsEnum termsEnum) throws IOException {\n      BytesRef spare = new BytesRef();\n      PostingsEnum postingsEnum = null;\n      for (int i = 0; i < terms.size(); i++) {\n        if (termsEnum.seekExact(terms.get(ords[i], spare))) {\n          postingsEnum = termsEnum.postings(acceptDocs, postingsEnum, PostingsEnum.NONE);\n          float score = TermsIncludingScoreQuery.this.scores[ords[i]];\n          for (int doc = postingsEnum.nextDoc(); doc != DocIdSetIterator.NO_MORE_DOCS; doc = postingsEnum.nextDoc()) {\n            matchingDocs.set(doc);\n            // In the case the same doc is also related to a another doc, a score might be overwritten. I think this\n            // can only happen in a many-to-many relation\n            scores[doc] = score;\n          }\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["b64a4420c88dd81303e7f7959057baf9f3b45f94","15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"0f4464508ee83288c8c4585b533f9faaa93aa314":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["51f5280f31484820499077f41fcdfe92d527d9dc"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["b64a4420c88dd81303e7f7959057baf9f3b45f94"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"05a14b2611ead08655a2b2bdc61632eb31316e57":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b64a4420c88dd81303e7f7959057baf9f3b45f94"],"51f5280f31484820499077f41fcdfe92d527d9dc":["eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["15250ca94ba8ab3bcdd476daf6bf3f3febb92640"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e73063b92d958076ef4ae8beb5f493e8ccdcecb4":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"15250ca94ba8ab3bcdd476daf6bf3f3febb92640":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","eee5f2a24465d2c9a5f86ab84b7c35041a30fda8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["05a14b2611ead08655a2b2bdc61632eb31316e57","b64a4420c88dd81303e7f7959057baf9f3b45f94"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"05a14b2611ead08655a2b2bdc61632eb31316e57":[],"51f5280f31484820499077f41fcdfe92d527d9dc":["e73063b92d958076ef4ae8beb5f493e8ccdcecb4"],"eee5f2a24465d2c9a5f86ab84b7c35041a30fda8":["51f5280f31484820499077f41fcdfe92d527d9dc"],"b64a4420c88dd81303e7f7959057baf9f3b45f94":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","15250ca94ba8ab3bcdd476daf6bf3f3febb92640","05a14b2611ead08655a2b2bdc61632eb31316e57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","05a14b2611ead08655a2b2bdc61632eb31316e57","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}