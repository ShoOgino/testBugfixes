{"path":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","commits":[{"id":"423470dff9e19aa0db92590e282e2ca12e34d65a","date":1381851051,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @param indexInterval The number of high zero bits for which a single index entry is built.\n   *                The index will have at most <code>2 * numValues / indexInterval</code> entries\n   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,\n   *                see {@link EliasFanoEncoder}.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li><code>indexInterval < 2</code>,\n   *         <li>the index bits do not fit in a <code>long[]</code>:\n   *             <code>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n    if (indexInterval < 2) {\n      throw new IllegalArgumentException(\"indexInterval should at least 2: \" + indexInterval);\n    }\n    // For the index:\n    long maxHighValue = upperBound >>> this.numLowBits;\n    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry\n    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;\n    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero\n    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0\n                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry - 1));\n    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);\n    if (numLongsForIndexBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForIndexBits too large to index a long array: \" + numLongsForIndexBits);\n    }\n    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];\n    this.currentEntryIndex = 0;\n    this.indexInterval = indexInterval;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["ba7a1199cd9a45991332901101cddfef2698a92d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ba7a1199cd9a45991332901101cddfef2698a92d","date":1393534875,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","sourceNew":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @param indexInterval The number of high zero bits for which a single index entry is built.\n   *                The index will have at most <code>2 * numValues / indexInterval</code> entries\n   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,\n   *                see {@link EliasFanoEncoder}.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li><code>indexInterval < 2</code>,\n   *         <li>the index bits do not fit in a <code>long[]</code>:\n   *             <code>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n    if (indexInterval < 2) {\n      throw new IllegalArgumentException(\"indexInterval should at least 2: \" + indexInterval);\n    }\n    // For the index:\n    long maxHighValue = upperBound >>> this.numLowBits;\n    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry\n    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;\n    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero\n    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0\n                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry));\n    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);\n    if (numLongsForIndexBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForIndexBits too large to index a long array: \" + numLongsForIndexBits);\n    }\n    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];\n    this.currentEntryIndex = 0;\n    this.indexInterval = indexInterval;\n  }\n\n","sourceOld":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @param indexInterval The number of high zero bits for which a single index entry is built.\n   *                The index will have at most <code>2 * numValues / indexInterval</code> entries\n   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,\n   *                see {@link EliasFanoEncoder}.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li><code>indexInterval < 2</code>,\n   *         <li>the index bits do not fit in a <code>long[]</code>:\n   *             <code>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n    if (indexInterval < 2) {\n      throw new IllegalArgumentException(\"indexInterval should at least 2: \" + indexInterval);\n    }\n    // For the index:\n    long maxHighValue = upperBound >>> this.numLowBits;\n    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry\n    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;\n    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero\n    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0\n                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry - 1));\n    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);\n    if (numLongsForIndexBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForIndexBits too large to index a long array: \" + numLongsForIndexBits);\n    }\n    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];\n    this.currentEntryIndex = 0;\n    this.indexInterval = indexInterval;\n  }\n\n","bugFix":["423470dff9e19aa0db92590e282e2ca12e34d65a"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b1eb427f2c6beed80d1724555fc1db003ccf3030","date":1417137397,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","sourceNew":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When {@code numValues >= (upperBound/3)}\n   *                a {@link FixedBitSet} will take less space.\n   * @param indexInterval The number of high zero bits for which a single index entry is built.\n   *                The index will have at most <code>2 * numValues / indexInterval</code> entries\n   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,\n   *                see {@link EliasFanoEncoder}.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             {@code (L * numValues / 64) > Integer.MAX_VALUE}, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             {@code (2 * numValues / 64) > Integer.MAX_VALUE}, or\n   *         <li>{@code indexInterval < 2},\n   *         <li>the index bits do not fit in a <code>long[]</code>:\n   *             {@code (numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE}.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n    if (indexInterval < 2) {\n      throw new IllegalArgumentException(\"indexInterval should at least 2: \" + indexInterval);\n    }\n    // For the index:\n    long maxHighValue = upperBound >>> this.numLowBits;\n    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry\n    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;\n    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero\n    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0\n                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry));\n    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);\n    if (numLongsForIndexBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForIndexBits too large to index a long array: \" + numLongsForIndexBits);\n    }\n    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];\n    this.currentEntryIndex = 0;\n    this.indexInterval = indexInterval;\n  }\n\n","sourceOld":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When <code>numValues >= (upperBound/3)</code>\n   *                a {@link FixedBitSet} will take less space.\n   * @param indexInterval The number of high zero bits for which a single index entry is built.\n   *                The index will have at most <code>2 * numValues / indexInterval</code> entries\n   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,\n   *                see {@link EliasFanoEncoder}.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             <code>(L * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             <code>(2 * numValues / 64) > Integer.MAX_VALUE</code>, or\n   *         <li><code>indexInterval < 2</code>,\n   *         <li>the index bits do not fit in a <code>long[]</code>:\n   *             <code>(numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE</code>.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n    if (indexInterval < 2) {\n      throw new IllegalArgumentException(\"indexInterval should at least 2: \" + indexInterval);\n    }\n    // For the index:\n    long maxHighValue = upperBound >>> this.numLowBits;\n    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry\n    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;\n    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero\n    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0\n                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry));\n    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);\n    if (numLongsForIndexBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForIndexBits too large to index a long array: \" + numLongsForIndexBits);\n    }\n    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];\n    this.currentEntryIndex = 0;\n    this.indexInterval = indexInterval;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556259cdb46d4f7fb27f4688c4efcb3eaee4a550","date":1432028057,"type":4,"author":"Adrien Grand","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/EliasFanoEncoder#EliasFanoEncoder(long,long,long).mjava","sourceNew":null,"sourceOld":"  /**\n   * Construct an Elias-Fano encoder.\n   * After construction, call {@link #encodeNext} <code>numValues</code> times to encode\n   * a non decreasing sequence of non negative numbers.\n   * @param numValues The number of values that is to be encoded.\n   * @param upperBound  At least the highest value that will be encoded.\n   *                For space efficiency this should not exceed the power of two that equals\n   *                or is the first higher than the actual maximum.\n   *                <br>When {@code numValues >= (upperBound/3)}\n   *                a {@link FixedBitSet} will take less space.\n   * @param indexInterval The number of high zero bits for which a single index entry is built.\n   *                The index will have at most <code>2 * numValues / indexInterval</code> entries\n   *                and each index entry will use at most <code>ceil(log2(3 * numValues))</code> bits,\n   *                see {@link EliasFanoEncoder}.\n   * @throws IllegalArgumentException when:\n   *         <ul>\n   *         <li><code>numValues</code> is negative, or\n   *         <li><code>numValues</code> is non negative and <code>upperBound</code> is negative, or\n   *         <li>the low bits do not fit in a <code>long[]</code>:\n   *             {@code (L * numValues / 64) > Integer.MAX_VALUE}, or\n   *         <li>the high bits do not fit in a <code>long[]</code>:\n   *             {@code (2 * numValues / 64) > Integer.MAX_VALUE}, or\n   *         <li>{@code indexInterval < 2},\n   *         <li>the index bits do not fit in a <code>long[]</code>:\n   *             {@code (numValues / indexInterval * ceil(2log(3 * numValues)) / 64) > Integer.MAX_VALUE}.\n   *         </ul>\n   */\n  public EliasFanoEncoder(long numValues, long upperBound, long indexInterval) {\n    if (numValues < 0L) {\n      throw new IllegalArgumentException(\"numValues should not be negative: \" + numValues);\n    }\n    this.numValues = numValues;\n    if ((numValues > 0L) && (upperBound < 0L)) {\n      throw new IllegalArgumentException(\"upperBound should not be negative: \" + upperBound + \" when numValues > 0\");\n    }\n    this.upperBound = numValues > 0 ? upperBound : -1L; // if there is no value, -1 is the best upper bound\n    int nLowBits = 0;\n    if (this.numValues > 0) { // nLowBits = max(0; floor(2log(upperBound/numValues)))\n      long lowBitsFac = this.upperBound / this.numValues;\n      if (lowBitsFac > 0) {\n        nLowBits = 63 - Long.numberOfLeadingZeros(lowBitsFac); // see Long.numberOfLeadingZeros javadocs\n      }\n    }\n    this.numLowBits = nLowBits;\n    this.lowerBitsMask = Long.MAX_VALUE >>> (Long.SIZE - 1 - this.numLowBits);\n\n    long numLongsForLowBits = numLongsForBits(numValues * numLowBits);\n    if (numLongsForLowBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForLowBits too large to index a long array: \" + numLongsForLowBits);\n    }\n    this.lowerLongs = new long[(int) numLongsForLowBits];\n\n    long numHighBitsClear = ((this.upperBound > 0) ? this.upperBound : 0) >>> this.numLowBits;\n    assert numHighBitsClear <= (2 * this.numValues);\n    long numHighBitsSet = this.numValues;\n\n    long numLongsForHighBits = numLongsForBits(numHighBitsClear + numHighBitsSet);\n    if (numLongsForHighBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForHighBits too large to index a long array: \" + numLongsForHighBits);\n    }\n    this.upperLongs = new long[(int) numLongsForHighBits];\n    if (indexInterval < 2) {\n      throw new IllegalArgumentException(\"indexInterval should at least 2: \" + indexInterval);\n    }\n    // For the index:\n    long maxHighValue = upperBound >>> this.numLowBits;\n    long nIndexEntries = maxHighValue / indexInterval; // no zero value index entry\n    this.numIndexEntries = (nIndexEntries >= 0) ? nIndexEntries : 0;\n    long maxIndexEntry = maxHighValue + numValues - 1; // clear upper bits, set upper bits, start at zero\n    this.nIndexEntryBits = (maxIndexEntry <= 0) ? 0\n                          : (64 - Long.numberOfLeadingZeros(maxIndexEntry));\n    long numLongsForIndexBits = numLongsForBits(numIndexEntries * nIndexEntryBits);\n    if (numLongsForIndexBits > Integer.MAX_VALUE) {\n      throw new IllegalArgumentException(\"numLongsForIndexBits too large to index a long array: \" + numLongsForIndexBits);\n    }\n    this.upperZeroBitPositionIndex = new long[(int) numLongsForIndexBits];\n    this.currentEntryIndex = 0;\n    this.indexInterval = indexInterval;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"556259cdb46d4f7fb27f4688c4efcb3eaee4a550":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["ba7a1199cd9a45991332901101cddfef2698a92d"],"423470dff9e19aa0db92590e282e2ca12e34d65a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba7a1199cd9a45991332901101cddfef2698a92d":["423470dff9e19aa0db92590e282e2ca12e34d65a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["556259cdb46d4f7fb27f4688c4efcb3eaee4a550"]},"commit2Childs":{"556259cdb46d4f7fb27f4688c4efcb3eaee4a550":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"b1eb427f2c6beed80d1724555fc1db003ccf3030":["556259cdb46d4f7fb27f4688c4efcb3eaee4a550"],"423470dff9e19aa0db92590e282e2ca12e34d65a":["ba7a1199cd9a45991332901101cddfef2698a92d"],"ba7a1199cd9a45991332901101cddfef2698a92d":["b1eb427f2c6beed80d1724555fc1db003ccf3030"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["423470dff9e19aa0db92590e282e2ca12e34d65a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}