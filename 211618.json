{"path":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","commits":[{"id":"5e5cbc96e6641be56fc04e988748a504d8d91b5e","date":1524724835,"type":0,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(req(elFilterQuery), elChild);\n    final Query query;\n    {\n      final SolrQueryRequest req = req(elFilterQuery);\n      try {\n        QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n        query = parser.getQuery();\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(1, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n    try {\n      assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n      final SolrQueryRequest req = req();\n      try {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }finally {\n      try {\n        assertU(delI(\"12275\"));\n        assertU(commit());\n      } catch(Throwable t) {\n        log.error(\"ignoring exception occuring in compensation routine\", t);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["e824c614ba8ba12c19a3945f1d1c838b97a870cf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"960f089602da7f0df48fb0e23de1ecbc791b95f0","date":1524725963,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","pathOld":"/dev/null","sourceNew":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(req(elFilterQuery), elChild);\n    final Query query;\n    {\n      final SolrQueryRequest req = req(elFilterQuery);\n      try {\n        QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n        query = parser.getQuery();\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(1, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n    try {\n      assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n      final SolrQueryRequest req = req();\n      try {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }finally {\n      try {\n        assertU(delI(\"12275\"));\n        assertU(commit());\n      } catch(Throwable t) {\n        log.error(\"ignoring exception occuring in compensation routine\", t);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e824c614ba8ba12c19a3945f1d1c838b97a870cf","date":1524763064,"type":3,"author":"Mikhail Khludnev","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","sourceNew":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(\"precondition: single doc match\", \n         req(elFilterQuery), elChild);\n    final Query query;\n    try(final SolrQueryRequest req = req(elFilterQuery)) {\n      QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n      query = parser.getQuery();\n      final TopDocs topDocs = req.getSearcher().search(query, 10);\n      assertEquals(1, topDocs.totalHits);\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n\n    assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n\n    try(final SolrQueryRequest req = req()) {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(req(elFilterQuery), elChild);\n    final Query query;\n    {\n      final SolrQueryRequest req = req(elFilterQuery);\n      try {\n        QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n        query = parser.getQuery();\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(1, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n    try {\n      assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n      final SolrQueryRequest req = req();\n      try {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }finally {\n      try {\n        assertU(delI(\"12275\"));\n        assertU(commit());\n      } catch(Throwable t) {\n        log.error(\"ignoring exception occuring in compensation routine\", t);\n      }\n    }\n  }\n\n","bugFix":["5e5cbc96e6641be56fc04e988748a504d8d91b5e"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3a3934808ca385ff0f01756464ed6f7a5ab4025","date":1524832780,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","sourceNew":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(\"precondition: single doc match\", \n         req(elFilterQuery), elChild);\n    final Query query;\n    try(final SolrQueryRequest req = req(elFilterQuery)) {\n      QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n      query = parser.getQuery();\n      final TopDocs topDocs = req.getSearcher().search(query, 10);\n      assertEquals(1, topDocs.totalHits);\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n\n    assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n\n    try(final SolrQueryRequest req = req()) {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(req(elFilterQuery), elChild);\n    final Query query;\n    {\n      final SolrQueryRequest req = req(elFilterQuery);\n      try {\n        QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n        query = parser.getQuery();\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(1, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n    try {\n      assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n      final SolrQueryRequest req = req();\n      try {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n      }finally {\n        req.close();\n      }\n    }finally {\n      try {\n        assertU(delI(\"12275\"));\n        assertU(commit());\n      } catch(Throwable t) {\n        log.error(\"ignoring exception occuring in compensation routine\", t);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6d71c47cb42702580f18a54321282c0238c2d2a","date":1532960436,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","sourceNew":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(\"precondition: single doc match\", \n         req(elFilterQuery), elChild);\n    final Query query;\n    try(final SolrQueryRequest req = req(elFilterQuery)) {\n      QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n      query = parser.getQuery();\n      final TopDocs topDocs = req.getSearcher().search(query, 10);\n      assertEquals(1, topDocs.totalHits);\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n\n    assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n\n    try(final SolrQueryRequest req = req()) {\n        final int count = req.getSearcher().count(query);\n        assertEquals(\"expecting new doc is visible to old query\", 2, count);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(\"precondition: single doc match\", \n         req(elFilterQuery), elChild);\n    final Query query;\n    try(final SolrQueryRequest req = req(elFilterQuery)) {\n      QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n      query = parser.getQuery();\n      final TopDocs topDocs = req.getSearcher().search(query, 10);\n      assertEquals(1, topDocs.totalHits);\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n\n    assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n\n    try(final SolrQueryRequest req = req()) {\n        final TopDocs topDocs = req.getSearcher().search(query, 10);\n        assertEquals(\"expecting new doc is visible to old query\", 2, topDocs.totalHits);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","pathOld":"solr/core/src/test/org/apache/solr/search/join/BJQParserTest#testFiltersCache().mjava","sourceNew":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(\"precondition: single doc match\", \n         req(elFilterQuery), elChild);\n    final Query query;\n    try(final SolrQueryRequest req = req(elFilterQuery)) {\n      QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n      query = parser.getQuery();\n      final TopDocs topDocs = req.getSearcher().search(query, 10);\n      assertEquals(1, topDocs.totalHits.value);\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n\n    assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n\n    try(final SolrQueryRequest req = req()) {\n        final int count = req.getSearcher().count(query);\n        assertEquals(\"expecting new doc is visible to old query\", 2, count);\n    }\n  }\n\n","sourceOld":"  @Test\n  public void testFiltersCache() throws SyntaxError, IOException {\n    final String [] elFilterQuery = new String[] {\"q\", \"{!filters param=$child.fq v=$gchq}\",\n        \"child.fq\", \"childparent_s:e\",\n        \"child.fq\", \"child_s:l\",\n        \"gchq\", \"child_s:[* TO *]\"};\n    assertQ(\"precondition: single doc match\", \n         req(elFilterQuery), elChild);\n    final Query query;\n    try(final SolrQueryRequest req = req(elFilterQuery)) {\n      QParser parser = QParser.getParser(req.getParams().get(\"q\"), null, req);\n      query = parser.getQuery();\n      final TopDocs topDocs = req.getSearcher().search(query, 10);\n      assertEquals(1, topDocs.totalHits);\n    }\n    assertU(adoc(\"id\", \"12275\", \n        \"child_s\", \"l\", \"childparent_s\", \"e\"));\n    assertU(commit());\n\n    assertQ(\"here we rely on autowarming for cathing cache leak\",  //cache=false\n          req(elFilterQuery), \"//*[@numFound='2']\");\n\n    try(final SolrQueryRequest req = req()) {\n        final int count = req.getSearcher().count(query);\n        assertEquals(\"expecting new doc is visible to old query\", 2, count);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d3a3934808ca385ff0f01756464ed6f7a5ab4025":["960f089602da7f0df48fb0e23de1ecbc791b95f0","e824c614ba8ba12c19a3945f1d1c838b97a870cf"],"e824c614ba8ba12c19a3945f1d1c838b97a870cf":["960f089602da7f0df48fb0e23de1ecbc791b95f0"],"960f089602da7f0df48fb0e23de1ecbc791b95f0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5e5cbc96e6641be56fc04e988748a504d8d91b5e"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["c6d71c47cb42702580f18a54321282c0238c2d2a"],"c6d71c47cb42702580f18a54321282c0238c2d2a":["d3a3934808ca385ff0f01756464ed6f7a5ab4025"],"5e5cbc96e6641be56fc04e988748a504d8d91b5e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["83788ad129a5154d5c6562c4e8ce3db48793aada"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["960f089602da7f0df48fb0e23de1ecbc791b95f0","5e5cbc96e6641be56fc04e988748a504d8d91b5e"],"d3a3934808ca385ff0f01756464ed6f7a5ab4025":["c6d71c47cb42702580f18a54321282c0238c2d2a"],"e824c614ba8ba12c19a3945f1d1c838b97a870cf":["d3a3934808ca385ff0f01756464ed6f7a5ab4025"],"960f089602da7f0df48fb0e23de1ecbc791b95f0":["d3a3934808ca385ff0f01756464ed6f7a5ab4025","e824c614ba8ba12c19a3945f1d1c838b97a870cf"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5e5cbc96e6641be56fc04e988748a504d8d91b5e":["960f089602da7f0df48fb0e23de1ecbc791b95f0"],"c6d71c47cb42702580f18a54321282c0238c2d2a":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}