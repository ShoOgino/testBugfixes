{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","commits":[{"id":"1bbcda32e5cd37ef61ea1190bacd080308e22070","date":1508850553,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getOperation().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getOperation() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n          session.matrix.add(new Row(srcNode, session.getPolicy().params, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ef7c0ae2232b955007fc003318142c3bdb0e5e8c","date":1515055559,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":["1bbcda32e5cd37ef61ea1190bacd080308e22070"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session.cloudManager));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9f0e33082a86447f4f2b59a1a5f69a310500276a","date":1519970482,"type":3,"author":"noble","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if(session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9837f40c922407d857991971de6def18eda0857b","date":1529994497,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"27639bb5e041490ce599065875dd2f6d8beef62a","date":1532829373,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> collectionShardPairs = new HashSet<>(s);\n        collections.forEach(c -> collectionShardPairs.add(new Pair<>(c, null)));\n        collections.forEach(c -> {\n          try {\n            getWithCollection(c).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + c, e);\n          }\n        });\n        s.forEach(kv -> {\n          try {\n            getWithCollection(kv.first()).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + kv.first(), e);\n          }\n        });\n        setupCollection(collectionShardPairs);\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode))) {\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n          }\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","sourceOld":"  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> shards = new HashSet<>(s);\n        collections.stream().forEach(c -> shards.add(new Pair<>(c, null)));\n        ClusterStateProvider stateProvider = session.cloudManager.getClusterStateProvider();\n        for (Pair<String, String> shard : shards) {\n          // if this is not a known collection from the existing clusterstate,\n          // then add it\n          if (session.matrix.stream().noneMatch(row -> row.collectionVsShardVsReplicas.containsKey(shard.first()))) {\n            session.addClausesForCollection(stateProvider, shard.first());\n          }\n          for (Row row : session.matrix) {\n            Map<String, List<ReplicaInfo>> shardInfo = row.collectionVsShardVsReplicas.computeIfAbsent(shard.first(), it -> new HashMap<>());\n            if (shard.second() != null) shardInfo.computeIfAbsent(shard.second(), it -> new ArrayList<>());\n          }\n        }\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode)))\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5028c6838e2e49cb9da1cf70269851c049f107a","date":1584984100,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> collectionShardPairs = new HashSet<>(s);\n        collections.forEach(c -> collectionShardPairs.add(new Pair<>(c, null)));\n        collections.forEach(c -> {\n          try {\n            getWithCollection(c).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + c, e);\n          }\n        });\n        s.forEach(kv -> {\n          try {\n            getWithCollection(kv.first()).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + kv.first(), e);\n          }\n        });\n        setupCollection(collectionShardPairs);\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode))) {\n            session.matrix.add(new Row(srcNode, session.getPolicy().getParams(), session.getPolicy().getPerReplicaAttributes(), session));\n          }\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> collectionShardPairs = new HashSet<>(s);\n        collections.forEach(c -> collectionShardPairs.add(new Pair<>(c, null)));\n        collections.forEach(c -> {\n          try {\n            getWithCollection(c).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + c, e);\n          }\n        });\n        s.forEach(kv -> {\n          try {\n            getWithCollection(kv.first()).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + kv.first(), e);\n          }\n        });\n        setupCollection(collectionShardPairs);\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode))) {\n            session.matrix.add(new Row(srcNode, session.getPolicy().params, session.getPolicy().perReplicaAttributes, session));\n          }\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"527adea7ce767368d7317339023e18e39702132e","date":1592163810,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> collectionShardPairs = new HashSet<>(s);\n        collections.forEach(c -> collectionShardPairs.add(new Pair<>(c, null)));\n        collections.forEach(c -> {\n          try {\n            getWithCollection(c).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + c, e);\n          }\n        });\n        s.forEach(kv -> {\n          try {\n            getWithCollection(kv.first()).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + kv.first(), e);\n          }\n        });\n        setupCollection(collectionShardPairs);\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode))) {\n            session.matrix.add(new Row(srcNode, session.getPolicy().getParams(), session.getPolicy().getPerReplicaAttributes(), session));\n          }\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> collectionShardPairs = new HashSet<>(s);\n        collections.forEach(c -> collectionShardPairs.add(new Pair<>(c, null)));\n        collections.forEach(c -> {\n          try {\n            getWithCollection(c).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + c, e);\n          }\n        });\n        s.forEach(kv -> {\n          try {\n            getWithCollection(kv.first()).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + kv.first(), e);\n          }\n        });\n        setupCollection(collectionShardPairs);\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode))) {\n            session.matrix.add(new Row(srcNode, session.getPolicy().getParams(), session.getPolicy().getPerReplicaAttributes(), session));\n          }\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/cloud/autoscaling/Suggester#getSuggestion().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public SolrRequest getSuggestion() {\n    if (!isInitialized) {\n      Set<String> collections = (Set<String>) hints.getOrDefault(Hint.COLL, Collections.emptySet());\n      Set<Pair<String, String>> s = (Set<Pair<String, String>>) hints.getOrDefault(Hint.COLL_SHARD, Collections.emptySet());\n      if (!collections.isEmpty() || !s.isEmpty()) {\n        HashSet<Pair<String, String>> collectionShardPairs = new HashSet<>(s);\n        collections.forEach(c -> collectionShardPairs.add(new Pair<>(c, null)));\n        collections.forEach(c -> {\n          try {\n            getWithCollection(c).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + c, e);\n          }\n        });\n        s.forEach(kv -> {\n          try {\n            getWithCollection(kv.first()).ifPresent(withCollection -> collectionShardPairs.add(new Pair<>(withCollection, null)));\n          } catch (IOException e) {\n            throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n                \"Exception while fetching 'withCollection' attribute for collection: \" + kv.first(), e);\n          }\n        });\n        setupCollection(collectionShardPairs);\n        Collections.sort(session.expandedClauses);\n      }\n      Set<String> srcNodes = (Set<String>) hints.get(Hint.SRC_NODE);\n      if (srcNodes != null && !srcNodes.isEmpty()) {\n        // the source node is dead so live nodes may not have it\n        for (String srcNode : srcNodes) {\n          if (session.matrix.stream().noneMatch(row -> row.node.equals(srcNode))) {\n            session.matrix.add(new Row(srcNode, session.getPolicy().getParams(), session.getPolicy().getPerReplicaAttributes(), session));\n          }\n        }\n      }\n      session.applyRules();\n      originalViolations.addAll(session.getViolations());\n      this.operation = init();\n      isInitialized = true;\n    }\n    if (operation != null && session.transaction != null && session.transaction.isOpen()) {\n      session.transaction.updateSession(session);\n    }\n    return operation;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["1bbcda32e5cd37ef61ea1190bacd080308e22070","ef7c0ae2232b955007fc003318142c3bdb0e5e8c"],"3f504512a03d978990cbff30db0522b354e846db":["527adea7ce767368d7317339023e18e39702132e"],"ef7c0ae2232b955007fc003318142c3bdb0e5e8c":["1bbcda32e5cd37ef61ea1190bacd080308e22070"],"9f0e33082a86447f4f2b59a1a5f69a310500276a":["b94236357aaa22b76c10629851fe4e376e0cea82"],"e5028c6838e2e49cb9da1cf70269851c049f107a":["27639bb5e041490ce599065875dd2f6d8beef62a"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["9f0e33082a86447f4f2b59a1a5f69a310500276a","9837f40c922407d857991971de6def18eda0857b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"527adea7ce767368d7317339023e18e39702132e":["e5028c6838e2e49cb9da1cf70269851c049f107a"],"1bbcda32e5cd37ef61ea1190bacd080308e22070":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9837f40c922407d857991971de6def18eda0857b":["9f0e33082a86447f4f2b59a1a5f69a310500276a"],"27639bb5e041490ce599065875dd2f6d8beef62a":["9837f40c922407d857991971de6def18eda0857b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["9f0e33082a86447f4f2b59a1a5f69a310500276a","9837f40c922407d857991971de6def18eda0857b"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["9f0e33082a86447f4f2b59a1a5f69a310500276a"],"ef7c0ae2232b955007fc003318142c3bdb0e5e8c":["b94236357aaa22b76c10629851fe4e376e0cea82"],"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9f0e33082a86447f4f2b59a1a5f69a310500276a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","9837f40c922407d857991971de6def18eda0857b","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e5028c6838e2e49cb9da1cf70269851c049f107a":["527adea7ce767368d7317339023e18e39702132e"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1bbcda32e5cd37ef61ea1190bacd080308e22070"],"527adea7ce767368d7317339023e18e39702132e":["3f504512a03d978990cbff30db0522b354e846db"],"1bbcda32e5cd37ef61ea1190bacd080308e22070":["b94236357aaa22b76c10629851fe4e376e0cea82","ef7c0ae2232b955007fc003318142c3bdb0e5e8c"],"9837f40c922407d857991971de6def18eda0857b":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","27639bb5e041490ce599065875dd2f6d8beef62a","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"27639bb5e041490ce599065875dd2f6d8beef62a":["e5028c6838e2e49cb9da1cf70269851c049f107a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}