{"path":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","commits":[{"id":"3cdb67100dc016748799a77218aa409478372d79","date":1353699950,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError {\n    return getBooleanQuery(clauses, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError {\n    return getBooleanQuery(clauses, false);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81d0720146de53dd3a4a023d2a3d1089d86d748d","date":1442268215,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n    BooleanQuery.Builder query = newBooleanQuery();\n    for(final BooleanClause clause: clauses) {\n      query.add(clause);\n    }\n    return query.build();\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError {\n    return getBooleanQuery(clauses, false);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68c354ba50abc8ed5c5fe98901e61d68f93952bb","date":1479836000,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<String> fieldValues = null;\n\n\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && clauses.size() > TERMS_QUERY_THRESHOLD;\n    int clausesAdded = 0;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<String>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if (fieldValues == null && useTermsQuery || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq.externalVal);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      clausesAdded++;\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<String>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      if (sfield.indexed() && fieldValues.size() < TERMS_QUERY_THRESHOLD || fieldValues.size() == 1) {\n        // use boolean query instead\n        for (String externalVal : fieldValues) {\n          Query subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n          clausesAdded++;\n          booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        Query subq = ft.getSetQuery(this.parser, sfield, fieldValues);\n        if (fieldValues.size() == clauses.size()) return subq; // if this is everything, don't wrap in a boolean query\n        clausesAdded++;\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    return booleanBuilder.build();\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n    BooleanQuery.Builder query = newBooleanQuery();\n    for(final BooleanClause clause: clauses) {\n      query.add(clause);\n    }\n    return query.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"727bb765ff2542275f6d31f67be18d7104bae148","date":1480353976,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<String> fieldValues = null;\n\n\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && clauses.size() > TERMS_QUERY_THRESHOLD;\n    int clausesAdded = 0;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<String>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if (fieldValues == null && useTermsQuery || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq.externalVal);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      clausesAdded++;\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<String>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      if (sfield.indexed() && fieldValues.size() < TERMS_QUERY_THRESHOLD || fieldValues.size() == 1) {\n        // use boolean query instead\n        for (String externalVal : fieldValues) {\n          Query subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n          clausesAdded++;\n          booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        Query subq = ft.getSetQuery(this.parser, sfield, fieldValues);\n        if (fieldValues.size() == clauses.size()) return subq; // if this is everything, don't wrap in a boolean query\n        clausesAdded++;\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    return booleanBuilder.build();\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n    BooleanQuery.Builder query = newBooleanQuery();\n    for(final BooleanClause clause: clauses) {\n      query.add(clause);\n    }\n    return query.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e55782fb51a6e9789542818eb2161a3247f39ace","date":1489707707,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<String> fieldValues = null;\n\n\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && clauses.size() > TERMS_QUERY_THRESHOLD;\n    int clausesAdded = 0;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<String>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if (fieldValues == null && useTermsQuery || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq.externalVal);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      clausesAdded++;\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<String>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      if (sfield.indexed() && fieldValues.size() < TERMS_QUERY_THRESHOLD || fieldValues.size() == 1) {\n        // use boolean query instead\n        for (String externalVal : fieldValues) {\n          Query subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n          clausesAdded++;\n          booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        Query subq = ft.getSetQuery(this.parser, sfield, fieldValues);\n        if (fieldValues.size() == clauses.size()) return subq; // if this is everything, don't wrap in a boolean query\n        clausesAdded++;\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    return booleanBuilder.build();\n  }\n\n","bugFix":null,"bugIntro":["0d1728ac6bfc0cea61f3e27436b418295d9982a3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c03778630c4604270d88c148afb8c7de35b51d3c","date":1490280010,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<String> fieldValues = null;\n\n\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && clauses.size() > TERMS_QUERY_THRESHOLD;\n    int clausesAdded = 0;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<String>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if (fieldValues == null && useTermsQuery || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq.externalVal);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      clausesAdded++;\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<String>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      if (sfield.indexed() && fieldValues.size() < TERMS_QUERY_THRESHOLD || fieldValues.size() == 1) {\n        // use boolean query instead\n        for (String externalVal : fieldValues) {\n          Query subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n          clausesAdded++;\n          booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n        }\n      } else {\n        Query subq = ft.getSetQuery(this.parser, sfield, fieldValues);\n        if (fieldValues.size() == clauses.size()) return subq; // if this is everything, don't wrap in a boolean query\n        clausesAdded++;\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    return booleanBuilder.build();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d1728ac6bfc0cea61f3e27436b418295d9982a3","date":1491423806,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","bugFix":["e55782fb51a6e9789542818eb2161a3247f39ace"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"39fdbc59d893f5a211736e861fe145798a40b9ff","date":1498161919,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = QueryUtils.build(booleanBuilder,parser);\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = QueryUtils.build(booleanBuilder,parser);\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = QueryUtils.build(booleanBuilder,parser);\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = booleanBuilder.build();\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"47d74fab5d64854ddafa81b65ed399b192f2d947","date":1512411916,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","pathOld":"solr/core/src/java/org/apache/solr/parser/SolrQueryParserBase#getBooleanQuery(List[BooleanClause]).mjava","sourceNew":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            SynonymQueryStyle synonymQueryStyle = AS_SAME_TERM;\n            if (ft instanceof TextField) {\n              synonymQueryStyle = ((TextField)(ft)).getSynonymQueryStyle();\n            }\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries, synonymQueryStyle);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = QueryUtils.build(booleanBuilder,parser);\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","sourceOld":"  /**\n   * Factory method for generating query, given a set of clauses.\n   * By default creates a boolean query composed of clauses passed in.\n   *\n   * Can be overridden by extending classes, to modify query being\n   * returned.\n   *\n   * @param clauses List that contains {@link org.apache.lucene.search.BooleanClause} instances\n   *    to join.\n   *\n   * @return Resulting {@link org.apache.lucene.search.Query} object.\n   */\n  protected Query getBooleanQuery(List<BooleanClause> clauses) throws SyntaxError\n  {\n    if (clauses.size()==0) {\n      return null; // all clause words were filtered away by the analyzer.\n    }\n\n    SchemaField sfield = null;\n    List<RawQuery> fieldValues = null;\n\n    boolean onlyRawQueries = true;\n    int allRawQueriesTermCount = 0;\n    for (BooleanClause clause : clauses) {\n      if (clause.getQuery() instanceof RawQuery) {\n        allRawQueriesTermCount += ((RawQuery)clause.getQuery()).getTermCount();\n      } else {\n        onlyRawQueries = false;\n      }\n    }\n    boolean useTermsQuery = (flags & QParser.FLAG_FILTER)!=0 && allRawQueriesTermCount > TERMS_QUERY_THRESHOLD;\n\n    BooleanQuery.Builder booleanBuilder = newBooleanQuery();\n    Map<SchemaField, List<RawQuery>> fmap = new HashMap<>();\n\n    for (BooleanClause clause : clauses) {\n      Query subq = clause.getQuery();\n      if (subq instanceof RawQuery) {\n        if (clause.getOccur() != BooleanClause.Occur.SHOULD) {\n          // We only collect optional terms for set queries.  Since this isn't optional,\n          // convert the raw query to a normal query and handle as usual.\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        } else {\n          // Optional raw query.\n          RawQuery rawq = (RawQuery) subq;\n\n          // only look up fmap and type info on a field change\n          if (sfield != rawq.sfield) {\n            sfield = rawq.sfield;\n            fieldValues = fmap.get(sfield);\n            // If this field isn't indexed, or if it is indexed and we want to use TermsQuery, then collect this value.\n            // We are currently relying on things like PointField not being marked as indexed in order to bypass\n            // the \"useTermQuery\" check.\n            if ((fieldValues == null && useTermsQuery) || !sfield.indexed()) {\n              fieldValues = new ArrayList<>(2);\n              fmap.put(sfield, fieldValues);\n            }\n          }\n\n          if (fieldValues != null) {\n            fieldValues.add(rawq);\n            continue;\n          }\n\n          clause = new BooleanClause( rawToNormal(subq), clause.getOccur() );\n        }\n      }\n\n      booleanBuilder.add(clause);\n    }\n\n\n    for (Map.Entry<SchemaField,List<RawQuery>> entry : fmap.entrySet()) {\n      sfield = entry.getKey();\n      fieldValues = entry.getValue();\n      FieldType ft = sfield.getType();\n\n      // TODO: pull more of this logic out to FieldType?  We would need to be able to add clauses to our existing booleanBuilder.\n      int termCount = fieldValues.stream().mapToInt(RawQuery::getTermCount).sum();\n      if ((sfield.indexed() && termCount < TERMS_QUERY_THRESHOLD) || termCount == 1) {\n        // use boolean query instead\n        for (RawQuery rawq : fieldValues) {\n          Query subq;\n          if (ft.isTokenized() && sfield.indexed()) {\n            boolean fieldAutoGenPhraseQueries = ft instanceof TextField && ((TextField)ft).getAutoGeneratePhraseQueries();\n            boolean fieldEnableGraphQueries = ft instanceof TextField && ((TextField)ft).getEnableGraphQueries();\n\n            subq = newFieldQuery(getAnalyzer(), sfield.getName(), rawq.getJoinedExternalVal(),\n                false, fieldAutoGenPhraseQueries, fieldEnableGraphQueries);\n            booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n          } else {\n            for (String externalVal : rawq.getExternalVals()) {\n              subq = ft.getFieldQuery(this.parser, sfield, externalVal);\n              booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n            }\n          }\n        }\n      } else {\n        List<String> externalVals\n            = fieldValues.stream().flatMap(rawq -> rawq.getExternalVals().stream()).collect(Collectors.toList());\n        Query subq = ft.getSetQuery(this.parser, sfield, externalVals);\n        if (onlyRawQueries && termCount == allRawQueriesTermCount) return subq; // if this is everything, don't wrap in a boolean query\n        booleanBuilder.add(subq, BooleanClause.Occur.SHOULD);\n      }\n    }\n\n    BooleanQuery bq = QueryUtils.build(booleanBuilder,parser);\n    if (bq.clauses().size() == 1) { // Unwrap single SHOULD query\n      BooleanClause clause = bq.clauses().iterator().next();\n      if (clause.getOccur() == BooleanClause.Occur.SHOULD) {\n        return clause.getQuery();\n      }\n    }\n    return bq;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["c03778630c4604270d88c148afb8c7de35b51d3c"],"3cdb67100dc016748799a77218aa409478372d79":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["0d1728ac6bfc0cea61f3e27436b418295d9982a3"],"407687e67faf6e1f02a211ca078d8e3eed631027":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3cdb67100dc016748799a77218aa409478372d79"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["3cdb67100dc016748799a77218aa409478372d79"],"c03778630c4604270d88c148afb8c7de35b51d3c":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","39fdbc59d893f5a211736e861fe145798a40b9ff"],"e55782fb51a6e9789542818eb2161a3247f39ace":["68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"28288370235ed02234a64753cdbf0c6ec096304a":["0d1728ac6bfc0cea61f3e27436b418295d9982a3","39fdbc59d893f5a211736e861fe145798a40b9ff"],"727bb765ff2542275f6d31f67be18d7104bae148":["81d0720146de53dd3a4a023d2a3d1089d86d748d","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"47d74fab5d64854ddafa81b65ed399b192f2d947":["28288370235ed02234a64753cdbf0c6ec096304a"],"0d1728ac6bfc0cea61f3e27436b418295d9982a3":["e55782fb51a6e9789542818eb2161a3247f39ace"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["81d0720146de53dd3a4a023d2a3d1089d86d748d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["47d74fab5d64854ddafa81b65ed399b192f2d947"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1"],"3cdb67100dc016748799a77218aa409478372d79":["407687e67faf6e1f02a211ca078d8e3eed631027","81d0720146de53dd3a4a023d2a3d1089d86d748d"],"39fdbc59d893f5a211736e861fe145798a40b9ff":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"c03778630c4604270d88c148afb8c7de35b51d3c":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"81d0720146de53dd3a4a023d2a3d1089d86d748d":["727bb765ff2542275f6d31f67be18d7104bae148","68c354ba50abc8ed5c5fe98901e61d68f93952bb"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"e55782fb51a6e9789542818eb2161a3247f39ace":["0d1728ac6bfc0cea61f3e27436b418295d9982a3"],"28288370235ed02234a64753cdbf0c6ec096304a":["47d74fab5d64854ddafa81b65ed399b192f2d947"],"727bb765ff2542275f6d31f67be18d7104bae148":[],"47d74fab5d64854ddafa81b65ed399b192f2d947":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0d1728ac6bfc0cea61f3e27436b418295d9982a3":["39fdbc59d893f5a211736e861fe145798a40b9ff","28288370235ed02234a64753cdbf0c6ec096304a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cdb67100dc016748799a77218aa409478372d79","407687e67faf6e1f02a211ca078d8e3eed631027"],"68c354ba50abc8ed5c5fe98901e61d68f93952bb":["c03778630c4604270d88c148afb8c7de35b51d3c","e55782fb51a6e9789542818eb2161a3247f39ace","727bb765ff2542275f6d31f67be18d7104bae148"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","727bb765ff2542275f6d31f67be18d7104bae148","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}