{"path":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","commits":[{"id":"d911f2420bc2c190c6ca1cbded67eca0f2bdf932","date":1494452425,"type":0,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"/dev/null","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length != 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir>\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      // we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final Element mainContent = doc.select(\".main-content\").first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main-content div\");\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n      // NOTE: add <body> to the nodesWithIds so we check the main section anchor as well\n      nodesWithIds.addAll(doc.select(\"body[id]\"));\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case ids that we ignore\n        if (id.equals(\"preamble\")) {\n          continue;\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    \n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b31ebc7a867ddea79d438a8fca876a94e644d11a","date":1494496172,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"/dev/null","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length != 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir>\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      // we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final Element mainContent = doc.select(\".main-content\").first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main-content div\");\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n      // NOTE: add <body> to the nodesWithIds so we check the main section anchor as well\n      nodesWithIds.addAll(doc.select(\"body[id]\"));\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case ids that we ignore\n        if (id.equals(\"preamble\")) {\n          continue;\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    \n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"/dev/null","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length != 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir>\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      // we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final Element mainContent = doc.select(\".main-content\").first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main-content div\");\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n      // NOTE: add <body> to the nodesWithIds so we check the main section anchor as well\n      nodesWithIds.addAll(doc.select(\"body[id]\"));\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case ids that we ignore\n        if (id.equals(\"preamble\")) {\n          continue;\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    \n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eea30ba14966e200d448689ae952aceb69598108","date":1509731043,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length < 1 || 2 < args.length ) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [<bare-bones-boolean>]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final boolean bareBones = (2 == args.length) ? Boolean.parseBoolean(args[1]) : false;\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      \n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already \n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n          \n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length != 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir>\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      // we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final Element mainContent = doc.select(\".main-content\").first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main-content div\");\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n      // NOTE: add <body> to the nodesWithIds so we check the main section anchor as well\n      nodesWithIds.addAll(doc.select(\"body[id]\"));\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case ids that we ignore\n        if (id.equals(\"preamble\")) {\n          continue;\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    \n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length < 1 || 2 < args.length ) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [<bare-bones-boolean>]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final boolean bareBones = (2 == args.length) ? Boolean.parseBoolean(args[1]) : false;\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      \n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already \n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n          \n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length != 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir>\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      // we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final Element mainContent = doc.select(\".main-content\").first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main-content div\");\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n      // NOTE: add <body> to the nodesWithIds so we check the main section anchor as well\n      nodesWithIds.addAll(doc.select(\"body[id]\"));\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case ids that we ignore\n        if (id.equals(\"preamble\")) {\n          continue;\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    \n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7bbe6dd460caa5613fcc7c7f752288b495f01503","date":1510699634,"type":3,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1 || 2 < args.length ) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [<bare-bones-boolean>]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final boolean bareBones = (2 == args.length) ? Boolean.parseBoolean(args[1]) : false;\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n\n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) {\n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n    \n    if (args.length < 1 || 2 < args.length ) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [<bare-bones-boolean>]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final boolean bareBones = (2 == args.length) ? Boolean.parseBoolean(args[1]) : false;\n    \n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n    \n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      \n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n      \n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already \n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n          \n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n        \n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) { \n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6386630e21191d0e7ac5e25205c21144f1be7312","date":1522797309,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [-check-all-relative-links] [-bare-bones]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final Set<String> options = new LinkedHashSet<>();\n    for (int i = 1; i < args.length; i++) {\n      if (! args[i].trim().isEmpty()) { // ignore blank options - maybe an ant sysprop blanked on purpose\n        options.add(args[i]);\n      }\n    }\n    final boolean bareBones = options.remove(\"-bare-bones\");\n    final boolean checkAllRelativeLinks = options.remove(\"-check-all-relative-links\");\n    if (! options.isEmpty()) {\n      for (String brokenOpt : options) {\n        System.err.println(\"CheckLinksAndAnchors: Unrecognized option: \" + brokenOpt);\n      }\n      System.exit(-1);\n    }\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"CheckLinksAndAnchors: No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new LinkedHashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n\n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if ((null == frag || \"\".equals(frag)) && ! uri.getPath().startsWith(\"../\")) {\n              // we must have a fragment for intra-page links to work correctly\n              // but relative links \"up and out\" of ref-guide (Ex: local javadocs)\n              // don't require them (even if checkAllRelativeLinks is set)\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final File dest = new File(htmlDir, path);\n        if ( ! dest.exists() ) {\n          // this is only a problem if it's in our dir, or checkAllRelativeLinks is set...\n          if (checkAllRelativeLinks || ! path.startsWith(\"../\")) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        } else {\n          if ( ! path.startsWith(\"../\") ) {\n            // if the dest file is part of the ref guide (ie: not an \"up and out\" link to javadocs)\n            // then we validate the fragment is known and unique...\n            final String frag = link.getFragment();\n            if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n              if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                   // id exists, but not in linked file\n                   ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) {\n                problems++;\n                System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n                System.err.println(\" ... source: \" + source.toURI().toString());\n              }\n            }\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1 || 2 < args.length ) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [<bare-bones-boolean>]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final boolean bareBones = (2 == args.length) ? Boolean.parseBoolean(args[1]) : false;\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new HashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n\n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if (null == frag || \"\".equals(frag)) {\n              // we must have a fragment for intra-page links to work correctly\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final String frag = link.getFragment();\n        if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n          final File dest = new File(htmlDir, path);\n          if ( ! dest.exists() ) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          } else if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                      // id exists, but not in linked file\n                      ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) {\n            problems++;\n            System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"85c36086410040c844558b891758a21e0fd741ab","date":1541430421,"type":3,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [-check-all-relative-links] [-bare-bones]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final Set<String> options = new LinkedHashSet<>();\n    for (int i = 1; i < args.length; i++) {\n      if (! args[i].trim().isEmpty()) { // ignore blank options - maybe an ant sysprop blanked on purpose\n        options.add(args[i]);\n      }\n    }\n    final boolean bareBones = options.remove(\"-bare-bones\");\n    final boolean checkAllRelativeLinks = options.remove(\"-check-all-relative-links\");\n    if (! options.isEmpty()) {\n      for (String brokenOpt : options) {\n        System.err.println(\"CheckLinksAndAnchors: Unrecognized option: \" + brokenOpt);\n      }\n      System.exit(-1);\n    }\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"CheckLinksAndAnchors: No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new LinkedHashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n\n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if ((null == frag || \"\".equals(frag)) && ! uri.getPath().startsWith(\"../\")) {\n              // we must have a fragment for intra-page links to work correctly\n              // but relative links \"up and out\" of ref-guide (Ex: local javadocs)\n              // don't require them (even if checkAllRelativeLinks is set)\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final File dest = new File(htmlDir, path);\n        if ( ! dest.exists() ) {\n          // this is only a problem if it's in our dir, or checkAllRelativeLinks is set...\n          if (checkAllRelativeLinks || ! path.startsWith(\"../\")) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        } else {\n          if ( ! path.startsWith(\"../\") ) {\n            // if the dest file is part of the ref guide (ie: not an \"up and out\" link to javadocs)\n            // then we validate the fragment is known and unique...\n            final String frag = link.getFragment();\n            if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n              if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                   // id exists, but not in linked file\n                   ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) {\n                problems++;\n                System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n                System.err.println(\" ... source: \" + source.toURI().toString());\n              }\n            }\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [-check-all-relative-links] [-bare-bones]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final Set<String> options = new LinkedHashSet<>();\n    for (int i = 1; i < args.length; i++) {\n      if (! args[i].trim().isEmpty()) { // ignore blank options - maybe an ant sysprop blanked on purpose\n        options.add(args[i]);\n      }\n    }\n    final boolean bareBones = options.remove(\"-bare-bones\");\n    final boolean checkAllRelativeLinks = options.remove(\"-check-all-relative-links\");\n    if (! options.isEmpty()) {\n      for (String brokenOpt : options) {\n        System.err.println(\"CheckLinksAndAnchors: Unrecognized option: \" + brokenOpt);\n      }\n      System.exit(-1);\n    }\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"CheckLinksAndAnchors: No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new LinkedHashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='main-content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".main-content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the main-content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n\n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if ((null == frag || \"\".equals(frag)) && ! uri.getPath().startsWith(\"../\")) {\n              // we must have a fragment for intra-page links to work correctly\n              // but relative links \"up and out\" of ref-guide (Ex: local javadocs)\n              // don't require them (even if checkAllRelativeLinks is set)\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final File dest = new File(htmlDir, path);\n        if ( ! dest.exists() ) {\n          // this is only a problem if it's in our dir, or checkAllRelativeLinks is set...\n          if (checkAllRelativeLinks || ! path.startsWith(\"../\")) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        } else {\n          if ( ! path.startsWith(\"../\") ) {\n            // if the dest file is part of the ref guide (ie: not an \"up and out\" link to javadocs)\n            // then we validate the fragment is known and unique...\n            final String frag = link.getFragment();\n            if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n              if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                   // id exists, but not in linked file\n                   ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) {\n                problems++;\n                System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n                System.err.println(\" ... source: \" + source.toURI().toString());\n              }\n            }\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"580584a6c5fc0f03777842090bc2d2dfb64337e5","date":1574200470,"type":3,"author":"Cassandra Targett","isMerge":false,"pathNew":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","pathOld":"solr/solr-ref-guide/tools/CheckLinksAndAnchors#main(String[]).mjava","sourceNew":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [-check-all-relative-links] [-bare-bones]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final Set<String> options = new LinkedHashSet<>();\n    for (int i = 1; i < args.length; i++) {\n      if (! args[i].trim().isEmpty()) { // ignore blank options - maybe an ant sysprop blanked on purpose\n        options.add(args[i]);\n      }\n    }\n    final boolean bareBones = options.remove(\"-bare-bones\");\n    final boolean checkAllRelativeLinks = options.remove(\"-check-all-relative-links\");\n    if (! options.isEmpty()) {\n      for (String brokenOpt : options) {\n        System.err.println(\"CheckLinksAndAnchors: Unrecognized option: \" + brokenOpt);\n      }\n      System.exit(-1);\n    }\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"CheckLinksAndAnchors: No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Map<String,Set<String>> filesToIds = new HashMap<>();\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n    int totalIds = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n      final Set<String> idsInThisFile = new LinkedHashSet<String>(17);\n      filesToIds.put(file.getName(), idsInThisFile);\n\n      // use this for error reporting if an ID exists multiple times in a single document\n      final Map<String,List<Element>> idsToNodes = new HashMap<>();\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // All of the ID (nodes) in (the content of) this doc\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue; // Note: we specifically don't count this in totalIds\n          }\n        }\n\n        if (idsInThisFile.contains(id)) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains ID multiple times: \" + id);\n        }\n        idsInThisFile.add(id);\n        totalIds++; // Note: we specifically don't count 'preamble'\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if ((null == frag || \"\".equals(frag)) && ! uri.getPath().startsWith(\"../\")) {\n              // we must have a fragment for intra-page links to work correctly\n              // but relative links \"up and out\" of ref-guide (Ex: local javadocs)\n              // don't require them (even if checkAllRelativeLinks is set)\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final File dest = new File(htmlDir, path);\n        if ( ! dest.exists() ) {\n          // this is only a problem if it's in our dir, or checkAllRelativeLinks is set...\n          if (checkAllRelativeLinks || ! path.startsWith(\"../\")) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        } else {\n          if ( ! path.startsWith(\"../\") ) {\n            // if the dest file is part of the ref guide (ie: not an \"up and out\" link to javadocs)\n            // then we validate the fragment is known and exists in that file...\n            final String frag = link.getFragment();\n            final Set<String> knownIdsInDest = filesToIds.get(dest.getName());\n            assert null != knownIdsInDest : dest.getName();\n            if (! knownIdsInDest.contains(frag) ) {\n              problems++;\n              System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n              System.err.println(\" ... source: \" + source.toURI().toString());\n            }\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       totalIds + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","sourceOld":"  public static void main(String[] args) throws Exception {\n    int problems = 0;\n\n    if (args.length < 1) {\n      System.err.println(\"usage: CheckLinksAndAnchors <htmldir> [-check-all-relative-links] [-bare-bones]\");\n      System.exit(-1);\n    }\n    final File htmlDir = new File(args[0]);\n    final Set<String> options = new LinkedHashSet<>();\n    for (int i = 1; i < args.length; i++) {\n      if (! args[i].trim().isEmpty()) { // ignore blank options - maybe an ant sysprop blanked on purpose\n        options.add(args[i]);\n      }\n    }\n    final boolean bareBones = options.remove(\"-bare-bones\");\n    final boolean checkAllRelativeLinks = options.remove(\"-check-all-relative-links\");\n    if (! options.isEmpty()) {\n      for (String brokenOpt : options) {\n        System.err.println(\"CheckLinksAndAnchors: Unrecognized option: \" + brokenOpt);\n      }\n      System.exit(-1);\n    }\n\n    final File[] pages = htmlDir.listFiles(new HtmlFileFilter());\n    if (0 == pages.length) {\n      System.err.println(\"CheckLinksAndAnchors: No HTML Files found, wrong htmlDir? forgot to built the site?\");\n      System.exit(-1);\n    }\n\n    final Map<String,List<File>> idsToFiles = new HashMap<>();\n    final Map<File,List<URI>> filesToRelativeLinks = new HashMap<>();\n    final Set<String> idsInMultiFiles = new LinkedHashSet<>(0);\n\n    int totalLinks = 0;\n    int totalRelativeLinks = 0;\n\n    for (File file : pages) {\n      //System.out.println(\"input File URI: \" + file.toURI().toString());\n\n      assert ! filesToRelativeLinks.containsKey(file);\n      final List<URI> linksInThisFile = new ArrayList<URI>(17);\n      filesToRelativeLinks.put(file, linksInThisFile);\n\n      final String fileContents = readFile(file.getPath());\n      final Document doc = Jsoup.parse(fileContents);\n\n      // For Jekyll, we only care about class='content' -- we don't want to worry\n      // about ids/links duplicated in the header/footer of every page,\n      final String mainContentSelector = bareBones ? \"body\" : \".content\";\n      final Element mainContent = doc.select(mainContentSelector).first();\n      if (mainContent == null) {\n        throw new RuntimeException(file.getName() + \" has no main content: \" + mainContentSelector);\n      }\n\n      // Add all of the IDs in (the content of) this doc to idsToFiles (and idsInMultiFiles if needed)\n      final Elements nodesWithIds = mainContent.select(\"[id]\");\n\n      if (bareBones) {\n        // It's a pain in the ass to customize the HTML output structure asciidoctor's bare-bones html5 backend\n        // so instead we \"fake\" that the body tag contains the attribute we use in jekyll\n        // (and what gets added explicitly to each top level section in the PDF)\n        nodesWithIds.add(new Element(Tag.valueOf(\"body\"), \"\").attr(\"id\", file.getName().replaceAll(\"\\\\.html$\",\"\")));\n      } else {\n        // We have to add Jekyll's <body> to the nodesWithIds so we check the main section anchor as well\n        // since we've already\n        nodesWithIds.addAll(doc.select(\"body[id]\"));\n      }\n\n      boolean foundPreamble = false;\n      for (Element node : nodesWithIds) {\n        final String id = node.id();\n        assert null != id;\n        assert 0 != id.length();\n\n        // special case id: we ignore the first 'preamble' because\n        // it's part of the core markup that asciidoctor always uses\n        // if we find it a second time in a single page, fail with a special error...\n        if (id.equals(\"preamble\")) {\n          if (foundPreamble) {\n            problems++;\n            System.err.println(file.toURI().toString() +\n                               \" contains 'preamble' anchor, this is special in jekyll and must not be used in content.\");\n          } else {\n            foundPreamble = true;\n            continue;\n          }\n        }\n\n        if (idsToFiles.containsKey(id)) {\n          idsInMultiFiles.add(id);\n        } else {\n          idsToFiles.put(id, new ArrayList<File>(1));\n        }\n        idsToFiles.get(id).add(file);\n      }\n\n      // check for (relative) links that don't include a fragment\n      final Elements links = mainContent.select(\"a[href]\");\n      for (Element link : links) {\n        totalLinks++;\n        final String href = link.attr(\"href\");\n        if (0 == href.length()) {\n          problems++;\n          System.err.println(file.toURI().toString() + \" contains link with empty href\");\n        }\n        try {\n          final URI uri = new URI(href);\n          if (! uri.isAbsolute()) {\n            totalRelativeLinks++;\n            final String frag = uri.getFragment();\n            if ((null == frag || \"\".equals(frag)) && ! uri.getPath().startsWith(\"../\")) {\n              // we must have a fragment for intra-page links to work correctly\n              // but relative links \"up and out\" of ref-guide (Ex: local javadocs)\n              // don't require them (even if checkAllRelativeLinks is set)\n              problems++;\n              System.err.println(file.toURI().toString() + \" contains relative link w/o an '#anchor': \" + href);\n            } else {\n              // track the link to validate it exists in the target doc\n              linksInThisFile.add(uri);\n            }\n          }\n        } catch (URISyntaxException uri_ex) {\n          // before reporting a problem, see if it can be parsed as a valid (absolute) URL\n          // some solr examples URLs have characters that aren't legal URI characters\n          // Example: \"ipod^3.0\", \"foo:[*+TO+*]\", etc...\n          boolean href_is_valid_absolute_url = false;\n          try {\n            // if this isn't absolute, it will fail\n            final URL ignored = new URL(href);\n            href_is_valid_absolute_url = true;\n          } catch (MalformedURLException url_ex) {\n            problems++;\n            System.err.println(file.toURI().toString() + \" contains link w/ invalid syntax: \" + href);\n            System.err.println(\" ... as URI: \" + uri_ex.toString());\n            System.err.println(\" ... as URL: \" + url_ex.toString());\n          }\n        }\n      }\n\n      problems += validateHtmlStructure(file, mainContent);\n    }\n\n    // if there are problematic ids, report them\n    for (String id : idsInMultiFiles) {\n      problems++;\n      System.err.println(\"ID occurs multiple times: \" + id);\n      for (File file : idsToFiles.get(id)) {\n        System.err.println(\" ... \" + file.toURI().toString());\n      }\n    }\n\n    // check every (realtive) link in every file to ensure the frag exists in the target page\n    for (Map.Entry<File,List<URI>> entry : filesToRelativeLinks.entrySet()) {\n      final File source = entry.getKey();\n      for (URI link : entry.getValue()) {\n        final String path = (null == link.getPath() || \"\".equals(link.getPath())) ? source.getName() : link.getPath();\n        final File dest = new File(htmlDir, path);\n        if ( ! dest.exists() ) {\n          // this is only a problem if it's in our dir, or checkAllRelativeLinks is set...\n          if (checkAllRelativeLinks || ! path.startsWith(\"../\")) {\n            problems++;\n            System.err.println(\"Relative link points at dest file that doesn't exist: \" + link);\n            System.err.println(\" ... source: \" + source.toURI().toString());\n          }\n        } else {\n          if ( ! path.startsWith(\"../\") ) {\n            // if the dest file is part of the ref guide (ie: not an \"up and out\" link to javadocs)\n            // then we validate the fragment is known and unique...\n            final String frag = link.getFragment();\n            if ( ! idsInMultiFiles.contains(frag) ) { // skip problematic dups already reported\n              if ( ( ! idsToFiles.containsKey(frag) ) || // no file contains this id, or...\n                   // id exists, but not in linked file\n                   ( ! idsToFiles.get(frag).get(0).getName().equals(path) )) {\n                problems++;\n                System.err.println(\"Relative link points at id that doesn't exist in dest: \" + link);\n                System.err.println(\" ... source: \" + source.toURI().toString());\n              }\n            }\n          }\n        }\n      }\n    }\n\n    System.err.println(\"Processed \" + totalLinks + \" links (\" + totalRelativeLinks + \" relative) to \" +\n                       idsToFiles.size() + \" anchors in \" + pages.length + \" files\");\n    if (0 < problems) {\n      System.err.println(\"Total of \" + problems + \" problems found\");\n      System.exit(-1);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d911f2420bc2c190c6ca1cbded67eca0f2bdf932"],"b31ebc7a867ddea79d438a8fca876a94e644d11a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d911f2420bc2c190c6ca1cbded67eca0f2bdf932"],"d911f2420bc2c190c6ca1cbded67eca0f2bdf932":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7bbe6dd460caa5613fcc7c7f752288b495f01503":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["d911f2420bc2c190c6ca1cbded67eca0f2bdf932","eea30ba14966e200d448689ae952aceb69598108"],"580584a6c5fc0f03777842090bc2d2dfb64337e5":["85c36086410040c844558b891758a21e0fd741ab"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"85c36086410040c844558b891758a21e0fd741ab":["6386630e21191d0e7ac5e25205c21144f1be7312"],"6386630e21191d0e7ac5e25205c21144f1be7312":["7bbe6dd460caa5613fcc7c7f752288b495f01503"],"eea30ba14966e200d448689ae952aceb69598108":["d911f2420bc2c190c6ca1cbded67eca0f2bdf932"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["580584a6c5fc0f03777842090bc2d2dfb64337e5"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"b31ebc7a867ddea79d438a8fca876a94e644d11a":[],"d911f2420bc2c190c6ca1cbded67eca0f2bdf932":["e9017cf144952056066919f1ebc7897ff9bd71b1","b31ebc7a867ddea79d438a8fca876a94e644d11a","d523b8189b211dd1630166aa77b8c88bb48b3fcc","eea30ba14966e200d448689ae952aceb69598108"],"7bbe6dd460caa5613fcc7c7f752288b495f01503":["6386630e21191d0e7ac5e25205c21144f1be7312"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["7bbe6dd460caa5613fcc7c7f752288b495f01503"],"580584a6c5fc0f03777842090bc2d2dfb64337e5":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","b31ebc7a867ddea79d438a8fca876a94e644d11a","d911f2420bc2c190c6ca1cbded67eca0f2bdf932"],"85c36086410040c844558b891758a21e0fd741ab":["580584a6c5fc0f03777842090bc2d2dfb64337e5"],"6386630e21191d0e7ac5e25205c21144f1be7312":["85c36086410040c844558b891758a21e0fd741ab"],"eea30ba14966e200d448689ae952aceb69598108":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","b31ebc7a867ddea79d438a8fca876a94e644d11a","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}