{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","commits":[{"id":"6e9ca12badc371399673a8a074cb281a72f34049","date":1395419500,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"/dev/null","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    assertFalse(IndexWriter.isLocked(dir));\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["05fe562aa248790944d43cdd478f512572835ba0"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d0ef034a4f10871667ae75181537775ddcf8ade4","date":1407610475,"type":3,"author":"Ryan Ernst","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    assertFalse(IndexWriter.isLocked(dir));\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(TEST_VERSION_CURRENT, null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    assertFalse(IndexWriter.isLocked(dir));\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"21c17a1bc8f2fd8591c652187d0a32853c86bc87","date":1418833631,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    assertFalse(IndexWriter.isLocked(dir));\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    assertFalse(IndexWriter.isLocked(dir));\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"618635065f043788c9e034f96ca5cd5cea1b4592","date":1433442044,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    assertFalse(IndexWriter.isLocked(dir));\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2a1862266772deb28cdcb7d996b64d2177022687","date":1453077824,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw, false);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05fe562aa248790944d43cdd478f512572835ba0","date":1455901667,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      iw.rollback();\n    });\n    assertEquals(\"BOOM!\", expected.getMessage());\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    try {\n      iw.rollback();\n      fail();\n    } catch (RuntimeException expected) {\n      assertEquals(\"BOOM!\", expected.getMessage());\n    }\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","bugFix":["6e9ca12badc371399673a8a074cb281a72f34049"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterExceptions#testExceptionDuringRollback().mjava","sourceNew":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    IndexWriter iw = new IndexWriter(dir, iwc) {\n      @Override\n      protected boolean isEnableTestPoints() {\n        return true;\n      }\n    };\n\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      iw.rollback();\n    });\n    assertEquals(\"BOOM!\", expected.getMessage());\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","sourceOld":"  public void testExceptionDuringRollback() throws Exception {\n    // currently: fail in two different places\n    final String messageToFailOn = random().nextBoolean() ? \n        \"rollback: done finish merges\" : \"rollback before checkpoint\";\n    \n    // infostream that throws exception during rollback\n    InfoStream evilInfoStream = new InfoStream() {\n      @Override\n      public void message(String component, String message) {\n        if (messageToFailOn.equals(message)) {\n          throw new RuntimeException(\"BOOM!\");\n        }\n      }\n\n      @Override\n      public boolean isEnabled(String component) {\n        return true;\n      }\n      \n      @Override\n      public void close() throws IOException {}\n    };\n    \n    Directory dir = newMockDirectory(); // we want to ensure we don't leak any locks or file handles\n    IndexWriterConfig iwc = new IndexWriterConfig(null);\n    iwc.setInfoStream(evilInfoStream);\n    IndexWriter iw = new IndexWriter(dir, iwc);\n    // TODO: cutover to RandomIndexWriter.mockIndexWriter?\n    iw.enableTestPoints = true;\n    Document doc = new Document();\n    for (int i = 0; i < 10; i++) {\n      iw.addDocument(doc);\n    }\n    iw.commit();\n\n    iw.addDocument(doc);\n    \n    // pool readers\n    DirectoryReader r = DirectoryReader.open(iw);\n\n    // sometimes sneak in a pending commit: we don't want to leak a file handle to that segments_N\n    if (random().nextBoolean()) {\n      iw.prepareCommit();\n    }\n    \n    RuntimeException expected = expectThrows(RuntimeException.class, () -> {\n      iw.rollback();\n    });\n    assertEquals(\"BOOM!\", expected.getMessage());\n    \n    r.close();\n    \n    // even though we hit exception: we are closed, no locks or files held, index in good state\n    assertTrue(iw.isClosed());\n    dir.obtainLock(IndexWriter.WRITE_LOCK_NAME).close();\n    \n    r = DirectoryReader.open(dir);\n    assertEquals(10, r.maxDoc());\n    r.close();\n    \n    // no leaks\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"618635065f043788c9e034f96ca5cd5cea1b4592":["21c17a1bc8f2fd8591c652187d0a32853c86bc87"],"2a1862266772deb28cdcb7d996b64d2177022687":["618635065f043788c9e034f96ca5cd5cea1b4592"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["05fe562aa248790944d43cdd478f512572835ba0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"05fe562aa248790944d43cdd478f512572835ba0":["2a1862266772deb28cdcb7d996b64d2177022687"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["6e9ca12badc371399673a8a074cb281a72f34049"],"6e9ca12badc371399673a8a074cb281a72f34049":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"21c17a1bc8f2fd8591c652187d0a32853c86bc87":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"]},"commit2Childs":{"618635065f043788c9e034f96ca5cd5cea1b4592":["2a1862266772deb28cdcb7d996b64d2177022687"],"2a1862266772deb28cdcb7d996b64d2177022687":["05fe562aa248790944d43cdd478f512572835ba0"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6e9ca12badc371399673a8a074cb281a72f34049"],"05fe562aa248790944d43cdd478f512572835ba0":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"d0ef034a4f10871667ae75181537775ddcf8ade4":["21c17a1bc8f2fd8591c652187d0a32853c86bc87"],"6e9ca12badc371399673a8a074cb281a72f34049":["d0ef034a4f10871667ae75181537775ddcf8ade4"],"21c17a1bc8f2fd8591c652187d0a32853c86bc87":["618635065f043788c9e034f96ca5cd5cea1b4592"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}