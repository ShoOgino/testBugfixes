{"path":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","commits":[{"id":"073f1aa70444ec64f3e216816af2a3b43fa38fe7","date":1488920481,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f34d83c894e07c24f5f957820777b5da2cc29e5a","date":1489491395,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b","date":1489651910,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d6879a535f14bc53be7c86de58142558c4f9eee","date":1492512399,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"54ca69905c5d9d1529286f06ab1d12c68f6c13cb","date":1492683554,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daeaac5f7b42498079f0fb7c3a91802e588fc21a","date":1493066118,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, false, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6afb0ba86024b96e8b34cfc2e15562239dc36360","date":1579768208,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report: {}\", e.toString());\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report\", e.toString());\n    }\n\n  }\n\n","bugFix":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9df8125ba9193a2e2e285ed92157810b1952a244","date":1587326330,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Error sending metric report: {}\", e.toString());\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      log.debug(\"Error sending metric report: {}\", e.toString());\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"575e66bd4b2349209027f6801184da7fc3cba13f","date":1587609169,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Error sending metric report: {}\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Error sending metric report: {}\", e.toString());\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"233211c3dbff6f367588be5bbb4ac77f72eae193","date":1602085975,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","pathOld":"solr/core/src/java/org/apache/solr/metrics/reporters/solr/SolrReporter#report().mjava","sourceNew":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.ALL_PROPERTIES, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Error sending metric report: {}\", e);\n      }\n    }\n\n  }\n\n","sourceOld":"  @Override\n  public void report() {\n    String url = urlProvider.get();\n    // if null then suppress reporting\n    if (url == null) {\n      return;\n    }\n\n    SolrClient solr;\n    if (cloudClient) {\n      solr = clientCache.getCloudSolrClient(url);\n    } else {\n      solr = clientCache.getHttpSolrClient(url);\n    }\n    UpdateRequest req = new UpdateRequest(handler);\n    req.setParams(params);\n    compiledReports.forEach(report -> {\n      Set<String> registryNames = metricManager.registryNames(report.registryPattern);\n      registryNames.forEach(registryName -> {\n        String label = report.label;\n        if (label != null && label.indexOf('$') != -1) {\n          // label with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          label = m.replaceFirst(label);\n        }\n        final String effectiveLabel = label;\n        String group = report.group;\n        if (group.indexOf('$') != -1) {\n          // group with back-references\n          Matcher m = report.registryPattern.matcher(registryName);\n          group = m.replaceFirst(group);\n        }\n        final String effectiveGroup = group;\n        MetricUtils.toSolrInputDocuments(metricManager.registry(registryName), Collections.singletonList(report.filter), MetricFilter.ALL,\n            MetricUtils.PropertyFilter.ALL, skipHistograms, skipAggregateValues, compact, metadata, doc -> {\n              doc.setField(REGISTRY_ID, registryName);\n              doc.setField(GROUP_ID, effectiveGroup);\n              if (effectiveLabel != null) {\n                doc.setField(LABEL_ID, effectiveLabel);\n              }\n              req.add(doc);\n            });\n      });\n    });\n\n    // if no docs added then don't send a report\n    if (req.getDocuments() == null || req.getDocuments().isEmpty()) {\n      return;\n    }\n    try {\n      //log.info(\"%%% sending to \" + url + \": \" + req.getParams());\n      solr.request(req);\n    } catch (Exception e) {\n      if (log.isDebugEnabled()) {\n        log.debug(\"Error sending metric report: {}\", e);\n      }\n    }\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["ab68488225b6a6c357dda72ed11dedca9914a192"],"575e66bd4b2349209027f6801184da7fc3cba13f":["9df8125ba9193a2e2e285ed92157810b1952a244"],"233211c3dbff6f367588be5bbb4ac77f72eae193":["575e66bd4b2349209027f6801184da7fc3cba13f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb","daeaac5f7b42498079f0fb7c3a91802e588fc21a"],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["daeaac5f7b42498079f0fb7c3a91802e588fc21a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f34d83c894e07c24f5f957820777b5da2cc29e5a":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"ab68488225b6a6c357dda72ed11dedca9914a192":["073f1aa70444ec64f3e216816af2a3b43fa38fe7","0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["233211c3dbff6f367588be5bbb4ac77f72eae193"],"9df8125ba9193a2e2e285ed92157810b1952a244":["6afb0ba86024b96e8b34cfc2e15562239dc36360"],"daeaac5f7b42498079f0fb7c3a91802e588fc21a":["0d6879a535f14bc53be7c86de58142558c4f9eee"],"0d6879a535f14bc53be7c86de58142558c4f9eee":["f34d83c894e07c24f5f957820777b5da2cc29e5a"],"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"]},"commit2Childs":{"54ca69905c5d9d1529286f06ab1d12c68f6c13cb":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"575e66bd4b2349209027f6801184da7fc3cba13f":["233211c3dbff6f367588be5bbb4ac77f72eae193"],"233211c3dbff6f367588be5bbb4ac77f72eae193":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"6afb0ba86024b96e8b34cfc2e15562239dc36360":["9df8125ba9193a2e2e285ed92157810b1952a244"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["073f1aa70444ec64f3e216816af2a3b43fa38fe7"],"073f1aa70444ec64f3e216816af2a3b43fa38fe7":["f34d83c894e07c24f5f957820777b5da2cc29e5a","ab68488225b6a6c357dda72ed11dedca9914a192","0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b"],"f34d83c894e07c24f5f957820777b5da2cc29e5a":["0d6879a535f14bc53be7c86de58142558c4f9eee"],"ab68488225b6a6c357dda72ed11dedca9914a192":["54ca69905c5d9d1529286f06ab1d12c68f6c13cb"],"9df8125ba9193a2e2e285ed92157810b1952a244":["575e66bd4b2349209027f6801184da7fc3cba13f"],"daeaac5f7b42498079f0fb7c3a91802e588fc21a":["e9017cf144952056066919f1ebc7897ff9bd71b1","6afb0ba86024b96e8b34cfc2e15562239dc36360"],"0d5e442cae8cd58c4f22df43dacbd0018fc0ac1b":["ab68488225b6a6c357dda72ed11dedca9914a192"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0d6879a535f14bc53be7c86de58142558c4f9eee":["daeaac5f7b42498079f0fb7c3a91802e588fc21a"]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}