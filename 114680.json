{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","commits":[{"id":"3661d6742eed69ff6cc30ea2538d572624a7cdf8","date":1472676864,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":1,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessorByArray#findTopSlots().mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  private SimpleOrderedMap<Object> findTopSlots() throws IOException {\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    int maxsize = (int)(freq.limit >= 0 ?  freq.offset + lim : Integer.MAX_VALUE - 1);\n    maxsize = Math.min(maxsize, nTerms);\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n    final SlotAcc sortAcc = this.sortAcc;\n\n    PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxsize) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      }\n    };\n\n    Slot bottom = null;\n    for (int i = 0; i < nTerms; i++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(i) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        int ord = startTermIndex + i;\n        BytesRef br = lookupOrd(ord);\n        Object val = sf.getType().toObject(sf, br);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        if (sortAcc.compare(bottom.slot, i) * sortMul < 0) {\n          bottom.slot = i;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = i;\n        queue.add(s);\n        if (queue.size() >= maxsize) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      if (allBucketsAcc != null) {\n        allBucketsAcc.setValues(allBuckets, allBucketsSlot);\n      }\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    ArrayList<SimpleOrderedMap<Object>> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    // TODO: do this with a callback instead?\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n\n      // get the ord of the slot...\n      int ord = startTermIndex + slotNum;\n\n      BytesRef br = lookupOrd(ord);\n      Object val = sf.getType().toObject(sf, br);\n\n      bucket.add(\"val\", val);\n\n      TermQuery filter = needFilter ? new TermQuery(new Term(sf.getName(), br)) : null;\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"/dev/null","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0981d4ba58f3187f57224acc8e4f15a4249f1fce","date":1477333392,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"60b61628d1912768f51eccaa8ead5a5a32ab34c6","date":1477427681,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n    // add a modest amount of over-request if this is a shard request\n    final int lim = freq.limit >= 0 ? (fcontext.isShard() ? (int)(freq.limit*1.1+4) : (int)freq.limit) : Integer.MAX_VALUE;\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (lim >= 0 ? (long) off + lim : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (lim > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= lim;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8ec805ca8fedc0166461148c7182f1bcbbd18ee1","date":1489767223,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58b93c361b4f6fe193e84bfd27ea523366eada52","date":1490100167,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":["7cb985c6555057b5e71cb07eb5862b9a7a65ca1d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11ab475c994c79138885cc8a30b2641d929cdc43","date":1490280010,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8908009aaa8e9318b455c1c22b83e0e87738228a","date":1490280013,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b65e1e1139651e98138d35a941b15107427618e3","date":1493072237,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        DocSet domain = fcontext.base;\n        if (freq.prefix != null) {\n          Query prefixFilter = sf.getType().getPrefixQuery(null, sf, freq.prefix);\n          domain = fcontext.searcher.getDocSet(prefixFilter, domain);\n        }\n\n        HLLAgg agg = new HLLAgg(freq.field);\n        SlotAcc acc = agg.createSlotAcc(fcontext, domain.size(), 1);\n        acc.collect(domain, 0);\n        acc.key = \"numBuckets\";\n        acc.setValues(res, 0);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":["3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"bugIntro":["1c841e27891873cab110ebeb89f124a8ec470176"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"84e83c6774414730d58276083becadc66f4e4aca","date":1493132430,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        DocSet domain = fcontext.base;\n        if (freq.prefix != null) {\n          Query prefixFilter = sf.getType().getPrefixQuery(null, sf, freq.prefix);\n          domain = fcontext.searcher.getDocSet(prefixFilter, domain);\n        }\n\n        HLLAgg agg = new HLLAgg(freq.field);\n        SlotAcc acc = agg.createSlotAcc(fcontext, domain.size(), 1);\n        acc.collect(domain, 0);\n        acc.key = \"numBuckets\";\n        acc.setValues(res, 0);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735","date":1493175404,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":["0981d4ba58f3187f57224acc8e4f15a4249f1fce"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n    List<Object> bucketVals = null;\n    if (freq.numBuckets && fcontext.isShard()) {\n      bucketVals = new ArrayList<>(100);\n    }\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        // add over-request if this is a shard request\n        if (freq.overrequest == -1) {\n          effectiveLimit = (long) (effectiveLimit*1.1+4); // default: add 10% plus 4 (to overrequest for very small limits)\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(off + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n      // screen out buckets not matching mincount immediately (i.e. don't even increment numBuckets)\n      if (effectiveMincount > 0 && countAcc.getCount(slotNum) < effectiveMincount) {\n        continue;\n      }\n\n      numBuckets++;\n      if (bucketVals != null && bucketVals.size()<100) {\n        Object val = bucketValFromSlotNumFunc.apply(slotNum);\n        bucketVals.add(val);\n      }\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        SimpleOrderedMap<Object> map = new SimpleOrderedMap<>(2);\n        map.add(\"numBuckets\", numBuckets);\n        map.add(\"vals\", bucketVals);\n        res.add(\"numBuckets\", map);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= effectiveLimit;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7cb985c6555057b5e71cb07eb5862b9a7a65ca1d","date":1520906162,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n      res.add(\"missing\", missingBucket);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    return res;\n  }\n\n","bugFix":["3661d6742eed69ff6cc30ea2538d572624a7cdf8","58b93c361b4f6fe193e84bfd27ea523366eada52"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? sf.getType().getFieldQuery(null, sf, fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e8220da23feaeb400771f18161c4965dea5ab4cd","date":1530366342,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"94ce69d020f939568b84a1dbbfbd11bfd9907b73","date":1543618146,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      }\n    }\n\n\n    final int sortMul = freq.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts.\n    int collectCount = Math.max(0, queue.size() - off);\n    assert collectCount <= maxTopVals;\n    int[] sortedSlots = new int[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      sortedSlots[i] = queue.pop().slot;\n    }\n\n    ArrayList<SimpleOrderedMap> bucketList = new ArrayList<>(collectCount);\n    res.add(\"buckets\", bucketList);\n\n    boolean needFilter = deferredAggs != null || freq.getSubFacets().size() > 0;\n\n    for (int slotNum : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      Comparable val = bucketValFromSlotNumFunc.apply(slotNum);\n      bucket.add(\"val\", val);\n\n      Query filter = needFilter ? makeBucketQuery(fieldQueryValFunc.apply(val)) : null;\n\n      fillBucket(bucket, countAcc.getCount(slotNum), slotNum, null, filter);\n\n      bucketList.add(bucket);\n    }\n\n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"055706edcc08dfbacd42d8ed4144209d3dc05b67","date":1569388195,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    assert this.sortAcc != null;\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<Slot>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":["3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1c841e27891873cab110ebeb89f124a8ec470176","date":1586527220,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    assert this.sortAcc != null;\n    long numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        long count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    assert this.sortAcc != null;\n    int numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        int count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", (long) numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":["3661d6742eed69ff6cc30ea2538d572624a7cdf8","b65e1e1139651e98138d35a941b15107427618e3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a56a9893014b284af4d1af451e6c02e7ffdf5b6e","date":1590065972,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetFieldProcessor#findTopSlots(int,int,IntFunction[Comparable],Function[Comparable,String]).mjava","sourceNew":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        @SuppressWarnings(\"rawtypes\") IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        @SuppressWarnings(\"rawtypes\") Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    assert this.sortAcc != null;\n    long numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        long count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    @SuppressWarnings({\"rawtypes\"})\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","sourceOld":"  /** Processes the collected data to finds the top slots, and composes it in the response NamedList. */\n  SimpleOrderedMap<Object> findTopSlots(final int numSlots, final int slotCardinality,\n                                        IntFunction<Comparable> bucketValFromSlotNumFunc,\n                                        Function<Comparable, String> fieldQueryValFunc) throws IOException {\n    assert this.sortAcc != null;\n    long numBuckets = 0;\n\n    final int off = fcontext.isShard() ? 0 : (int) freq.offset;\n\n    long effectiveLimit = Integer.MAX_VALUE; // use max-int instead of max-long to avoid overflow\n    if (freq.limit >= 0) {\n      effectiveLimit = freq.limit;\n      if (fcontext.isShard()) {\n        if (freq.overrequest == -1) {\n          // add over-request if this is a shard request and if we have a small offset (large offsets will already be gathering many more buckets than needed)\n          if (freq.offset < 10) {\n            effectiveLimit = (long) (effectiveLimit * 1.1 + 4); // default: add 10% plus 4 (to overrequest for very small limits)\n          }\n        } else {\n          effectiveLimit += freq.overrequest;\n        }\n      } else if (null != resort && 0 < freq.overrequest) {\n        // in non-shard situations, if we have a 'resort' we check for explicit overrequest > 0\n        effectiveLimit += freq.overrequest;\n      }\n    }\n\n    final int sortMul = sort.sortDirection.getMultiplier();\n\n    int maxTopVals = (int) (effectiveLimit >= 0 ? Math.min(freq.offset + effectiveLimit, Integer.MAX_VALUE - 1) : Integer.MAX_VALUE - 1);\n    maxTopVals = Math.min(maxTopVals, slotCardinality);\n    final SlotAcc sortAcc = this.sortAcc, indexOrderAcc = this.indexOrderAcc;\n    final BiPredicate<Slot,Slot> orderPredicate;\n    if (indexOrderAcc != null && indexOrderAcc != sortAcc) {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? (indexOrderAcc.compare(a.slot, b.slot) > 0) : cmp < 0;\n      };\n    } else {\n      orderPredicate = (a, b) -> {\n        int cmp = sortAcc.compare(a.slot, b.slot) * sortMul;\n        return cmp == 0 ? b.slot < a.slot : cmp < 0;\n      };\n    }\n    final PriorityQueue<Slot> queue = new PriorityQueue<>(maxTopVals) {\n      @Override\n      protected boolean lessThan(Slot a, Slot b) { return orderPredicate.test(a, b); }\n    };\n\n    // note: We avoid object allocation by having a Slot and re-using the 'bottom'.\n    Slot bottom = null;\n    Slot scratchSlot = new Slot();\n    boolean shardHasMoreBuckets = false;  // This shard has more buckets than were returned\n    for (int slotNum = 0; slotNum < numSlots; slotNum++) {\n\n      // screen out buckets not matching mincount\n      if (effectiveMincount > 0) {\n        long count = countAcc.getCount(slotNum);\n        if (count  < effectiveMincount) {\n          if (count > 0)\n            numBuckets++;  // Still increment numBuckets as long as we have some count.  This is for consistency between distrib and non-distrib mode.\n          continue;\n        }\n      }\n\n      numBuckets++;\n\n      if (bottom != null) {\n        shardHasMoreBuckets = true;\n        scratchSlot.slot = slotNum; // scratchSlot is only used to hold this slotNum for the following line\n        if (orderPredicate.test(bottom, scratchSlot)) {\n          bottom.slot = slotNum;\n          bottom = queue.updateTop();\n        }\n      } else if (effectiveLimit > 0) {\n        // queue not full\n        Slot s = new Slot();\n        s.slot = slotNum;\n        queue.add(s);\n        if (queue.size() >= maxTopVals) {\n          bottom = queue.top();\n        }\n      }\n    }\n\n    assert queue.size() <= numBuckets;\n\n    SimpleOrderedMap<Object> res = new SimpleOrderedMap<>();\n    if (freq.numBuckets) {\n      if (!fcontext.isShard()) {\n        res.add(\"numBuckets\", numBuckets);\n      } else {\n        calculateNumBuckets(res);\n      }\n    }\n\n    FacetDebugInfo fdebug = fcontext.getDebugInfo();\n    if (fdebug != null) fdebug.putInfoItem(\"numBuckets\", numBuckets);\n\n    if (freq.allBuckets) {\n      SimpleOrderedMap<Object> allBuckets = new SimpleOrderedMap<>();\n      // countAcc.setValues(allBuckets, allBucketsSlot);\n      allBuckets.add(\"count\", allBucketsAcc.getSpecialCount());\n      allBucketsAcc.setValues(allBuckets, -1); // -1 slotNum is unused for SpecialSlotAcc\n      // allBuckets currently doesn't execute sub-facets (because it doesn't change the domain?)\n      res.add(\"allBuckets\", allBuckets);\n    }\n\n    SimpleOrderedMap<Object> missingBucket = new SimpleOrderedMap<>();\n    if (freq.missing) {\n      res.add(\"missing\", missingBucket);\n      // moved missing fillBucket after we fill facet since it will reset all the accumulators.\n    }\n\n    final boolean needFilter = (!deferredAggs.isEmpty()) || freq.getSubFacets().size() > 0;\n    if (needFilter) {\n      createOtherAccs(-1, 1);\n    }\n\n    // if we are deep paging, we don't have to order the highest \"offset\" counts...\n    // ...unless we need to resort.\n    int collectCount = Math.max(0, queue.size() - (null == this.resort ? off : 0));\n    //\n    assert collectCount <= maxTopVals;\n    Slot[] sortedSlots = new Slot[collectCount];\n    for (int i = collectCount - 1; i >= 0; i--) {\n      Slot slot = sortedSlots[i] = queue.pop();\n      // At this point we know we're either returning this Slot as a Bucket, or resorting it,\n      // so definitely fill in the bucket value -- we'll need it either way\n      slot.bucketVal = bucketValFromSlotNumFunc.apply(slot.slot);\n      \n      if (needFilter || null != this.resort) {\n        slot.bucketFilter = makeBucketQuery(fieldQueryValFunc.apply(slot.bucketVal));\n      }\n    }\n    \n    final SlotAcc resortAccForFill = resortSlots(sortedSlots); // No-Op if not needed\n    \n    if (null != this.resort) {\n      // now that we've completely resorted, throw away extra docs from possible offset/overrequest...\n      final int endOffset = (int)Math.min((long) sortedSlots.length,\n                                          // NOTE: freq.limit is long, so no risk of overflow here\n                                          off + (freq.limit < 0 ? Integer.MAX_VALUE : freq.limit));\n      if (0 < off || endOffset < sortedSlots.length) {\n        sortedSlots = Arrays.copyOfRange(sortedSlots, off, endOffset);\n      }\n    }\n    List<SimpleOrderedMap> bucketList = new ArrayList<>(sortedSlots.length);\n\n    for (Slot slot : sortedSlots) {\n      SimpleOrderedMap<Object> bucket = new SimpleOrderedMap<>();\n      bucket.add(\"val\", slot.bucketVal);\n\n      fillBucketFromSlot(bucket, slot, resortAccForFill);\n\n      bucketList.add(bucket);\n    }\n\n    res.add(\"buckets\", bucketList);\n      \n    \n    if (fcontext.isShard() && shardHasMoreBuckets) {\n      // Currently, \"more\" is an internal implementation detail and only returned for distributed sub-requests\n      res.add(\"more\", true);\n    }\n\n    if (freq.missing) {\n      // TODO: it would be more efficient to build up a missing DocSet if we need it here anyway.\n      fillBucket(missingBucket, getFieldMissingQuery(fcontext.searcher, freq.field), null, false, null);\n    }\n\n    return res;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e8220da23feaeb400771f18161c4965dea5ab4cd":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"7cb985c6555057b5e71cb07eb5862b9a7a65ca1d":["9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735"],"84e83c6774414730d58276083becadc66f4e4aca":["b65e1e1139651e98138d35a941b15107427618e3"],"bc8f206328a706450934717bec7ccc22ad166fc0":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"1c841e27891873cab110ebeb89f124a8ec470176":["055706edcc08dfbacd42d8ed4144209d3dc05b67"],"60b61628d1912768f51eccaa8ead5a5a32ab34c6":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","0981d4ba58f3187f57224acc8e4f15a4249f1fce"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["8908009aaa8e9318b455c1c22b83e0e87738228a","9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["1c841e27891873cab110ebeb89f124a8ec470176"],"9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735":["84e83c6774414730d58276083becadc66f4e4aca"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["2c705a0d590cf911e7c942df49563ca2ea176e22","e8220da23feaeb400771f18161c4965dea5ab4cd"],"11ab475c994c79138885cc8a30b2641d929cdc43":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3661d6742eed69ff6cc30ea2538d572624a7cdf8"],"3661d6742eed69ff6cc30ea2538d572624a7cdf8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0981d4ba58f3187f57224acc8e4f15a4249f1fce":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["2c705a0d590cf911e7c942df49563ca2ea176e22","e8220da23feaeb400771f18161c4965dea5ab4cd"],"58b93c361b4f6fe193e84bfd27ea523366eada52":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1"],"b65e1e1139651e98138d35a941b15107427618e3":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["e8220da23feaeb400771f18161c4965dea5ab4cd"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["11ab475c994c79138885cc8a30b2641d929cdc43"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["7cb985c6555057b5e71cb07eb5862b9a7a65ca1d"],"055706edcc08dfbacd42d8ed4144209d3dc05b67":["94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"]},"commit2Childs":{"e8220da23feaeb400771f18161c4965dea5ab4cd":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","94ce69d020f939568b84a1dbbfbd11bfd9907b73"],"7cb985c6555057b5e71cb07eb5862b9a7a65ca1d":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"84e83c6774414730d58276083becadc66f4e4aca":["9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"8ec805ca8fedc0166461148c7182f1bcbbd18ee1":["58b93c361b4f6fe193e84bfd27ea523366eada52"],"60b61628d1912768f51eccaa8ead5a5a32ab34c6":["8ec805ca8fedc0166461148c7182f1bcbbd18ee1","11ab475c994c79138885cc8a30b2641d929cdc43","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"1c841e27891873cab110ebeb89f124a8ec470176":["a56a9893014b284af4d1af451e6c02e7ffdf5b6e"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"9fed7a1fcc332afbb217fb8b7e9cddc74d0bb735":["7cb985c6555057b5e71cb07eb5862b9a7a65ca1d","e9017cf144952056066919f1ebc7897ff9bd71b1"],"a56a9893014b284af4d1af451e6c02e7ffdf5b6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"11ab475c994c79138885cc8a30b2641d929cdc43":["8908009aaa8e9318b455c1c22b83e0e87738228a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","3661d6742eed69ff6cc30ea2538d572624a7cdf8","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["60b61628d1912768f51eccaa8ead5a5a32ab34c6","0981d4ba58f3187f57224acc8e4f15a4249f1fce","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"3661d6742eed69ff6cc30ea2538d572624a7cdf8":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"0981d4ba58f3187f57224acc8e4f15a4249f1fce":["60b61628d1912768f51eccaa8ead5a5a32ab34c6"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[],"58b93c361b4f6fe193e84bfd27ea523366eada52":["b65e1e1139651e98138d35a941b15107427618e3"],"b65e1e1139651e98138d35a941b15107427618e3":["84e83c6774414730d58276083becadc66f4e4aca"],"8908009aaa8e9318b455c1c22b83e0e87738228a":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"94ce69d020f939568b84a1dbbfbd11bfd9907b73":["055706edcc08dfbacd42d8ed4144209d3dc05b67"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["e8220da23feaeb400771f18161c4965dea5ab4cd","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"055706edcc08dfbacd42d8ed4144209d3dc05b67":["1c841e27891873cab110ebeb89f124a8ec470176"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","e9017cf144952056066919f1ebc7897ff9bd71b1","0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}