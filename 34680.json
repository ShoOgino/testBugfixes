{"path":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","commits":[{"id":"0c3e228bf650e96f3002a8fb73dd0c13d55af077","date":1138253849,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","pathOld":"/dev/null","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n\n    while(true) {\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while (true) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"796f0d3bc33e21ecefaedc718af98547d2bfc355","date":1199548787,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","pathOld":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n\n    while(true) {\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while (true) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n\n    while(true) {\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while (true) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f3c8bf2c66aa5d9a077e78c426bcb4422cfea2df","date":1199550124,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","pathOld":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n\n    while(true) {\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while (true) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n\n    while(true) {\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while (true) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"187b932e3f791668d245124e03d899af557d22df","date":1199907679,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","pathOld":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < readAheadLimitMinus1) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < readAheadLimitMinus1) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= readAheadLimitMinus1){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n\n    while(true) {\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while (true) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83385346e1f8330381d5fb9b78f65985059f35ef","date":1207834583,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","pathOld":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < readAheadLimitMinus1) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < readAheadLimitMinus1) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= readAheadLimitMinus1){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equalsIgnoreCase(\"script\") || name.equalsIgnoreCase(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < readAheadLimitMinus1) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < readAheadLimitMinus1) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= readAheadLimitMinus1){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equals(\"script\") || name.equals(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc8463025ae069ea6b9e8206613cb2d0d6f372f","date":1242140461,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","pathOld":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < safeReadAheadLimit) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < safeReadAheadLimit) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= safeReadAheadLimit){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equalsIgnoreCase(\"script\") || name.equalsIgnoreCase(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < readAheadLimitMinus1) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < readAheadLimitMinus1) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= readAheadLimitMinus1){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equalsIgnoreCase(\"script\") || name.equalsIgnoreCase(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bd69280df0902763e47cb14745388ee17a2fb602","date":1249686305,"type":5,"author":"Koji Sekiguchi","isMerge":false,"pathNew":"src/java/org/apache/solr/analysis/HTMLStripCharFilter#readTag().mjava","pathOld":"src/java/org/apache/solr/analysis/HTMLStripReader#readTag().mjava","sourceNew":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < safeReadAheadLimit) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < safeReadAheadLimit) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= safeReadAheadLimit){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equalsIgnoreCase(\"script\") || name.equalsIgnoreCase(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","sourceOld":"  private int readTag() throws IOException {\n    // at this point '<' has already been read\n    int ch = next();\n    if (!isAlpha(ch)) {\n      push(ch);\n      return MISMATCH;\n    }\n\n    sb.setLength(0);\n    sb.append((char)ch);\n    while((numRead - lastMark) < safeReadAheadLimit) {\n\n      ch = next();\n      if (isIdChar(ch)) {\n        sb.append((char)ch);\n      } else if (ch=='/') {\n        // Hmmm, a tag can close with \"/>\" as well as \"/ >\"\n        // read end tag '/>' or '/ >', etc\n        return nextSkipWS()=='>' ? MATCH : MISMATCH;\n      } else {\n        break;\n      }\n    }\n    if (escapedTags!=null && escapedTags.contains(sb.toString())){\n      //if this is a reservedTag, then keep it\n      return MISMATCH;\n    }\n    // After the tag id, there needs to be either whitespace or\n    // '>'\n    if ( !(ch=='>' || isSpace(ch)) ) {\n      return MISMATCH;\n    }\n\n    if (ch!='>') {\n      // process attributes\n      while ((numRead - lastMark) < safeReadAheadLimit) {\n        ch=next();\n        if (isSpace(ch)) {\n          continue;\n        } else if (isFirstIdChar(ch)) {\n          push(ch);\n          int ret = readAttr2();\n          if (ret==MISMATCH) return ret;\n        } else if (ch=='/') {\n          // read end tag '/>' or '/ >', etc\n          return nextSkipWS()=='>' ? MATCH : MISMATCH;\n        } else if (ch=='>') {\n          break;\n        } else {\n          return MISMATCH;\n        }\n\n      }\n      if ((numRead - lastMark) >= safeReadAheadLimit){\n        return MISMATCH;//exit out if we exceeded the buffer\n      }\n    }\n\n    // We only get to this point after we have read the\n    // entire tag.  Now let's see if it's a special tag.\n    String name=sb.toString();\n    if (name.equalsIgnoreCase(\"script\") || name.equalsIgnoreCase(\"style\")) {\n     // The content of script and style elements is\n     //  CDATA in HTML 4 but PCDATA in XHTML.\n\n     /* From HTML4:\n       Although the STYLE and SCRIPT elements use CDATA for their data model,\n       for these elements, CDATA must be handled differently by user agents.\n       Markup and entities must be treated as raw text and passed to the application\n       as is. The first occurrence of the character sequence \"</\" (end-tag open\n       delimiter) is treated as terminating the end of the element's content. In\n       valid documents, this would be the end tag for the element.\n      */\n\n     // discard everything until endtag is hit (except\n     // if it occurs in a comment.\n\n     // reset the stream mark to here, since we know that we sucessfully matched\n     // a tag, and if we can't find the end tag, this is where we will want\n     // to roll back to.\n     saveState();\n     pushed.setLength(0);\n     return findEndTag();\n    }\n    return MATCH;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"796f0d3bc33e21ecefaedc718af98547d2bfc355":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"6dc8463025ae069ea6b9e8206613cb2d0d6f372f":["83385346e1f8330381d5fb9b78f65985059f35ef"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"83385346e1f8330381d5fb9b78f65985059f35ef":["187b932e3f791668d245124e03d899af557d22df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"f3c8bf2c66aa5d9a077e78c426bcb4422cfea2df":["796f0d3bc33e21ecefaedc718af98547d2bfc355"],"bd69280df0902763e47cb14745388ee17a2fb602":["6dc8463025ae069ea6b9e8206613cb2d0d6f372f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"187b932e3f791668d245124e03d899af557d22df":["f3c8bf2c66aa5d9a077e78c426bcb4422cfea2df"]},"commit2Childs":{"796f0d3bc33e21ecefaedc718af98547d2bfc355":["f3c8bf2c66aa5d9a077e78c426bcb4422cfea2df"],"0c3e228bf650e96f3002a8fb73dd0c13d55af077":["796f0d3bc33e21ecefaedc718af98547d2bfc355"],"6dc8463025ae069ea6b9e8206613cb2d0d6f372f":["bd69280df0902763e47cb14745388ee17a2fb602"],"83385346e1f8330381d5fb9b78f65985059f35ef":["6dc8463025ae069ea6b9e8206613cb2d0d6f372f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["0c3e228bf650e96f3002a8fb73dd0c13d55af077"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f3c8bf2c66aa5d9a077e78c426bcb4422cfea2df":["187b932e3f791668d245124e03d899af557d22df"],"bd69280df0902763e47cb14745388ee17a2fb602":[],"187b932e3f791668d245124e03d899af557d22df":["83385346e1f8330381d5fb9b78f65985059f35ef"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bd69280df0902763e47cb14745388ee17a2fb602","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}