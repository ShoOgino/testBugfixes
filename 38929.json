{"path":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","commits":[{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#doTest().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"979e22aa7c63c9dc651adf861610c7e444d45832","date":1454615713,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":["ce70cdb9511a671e0e15d4dc93b8334c86b6e681"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b1704c078ec59838c9d95d5bf5738b393b537494","date":1454693901,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"62615e56c1409ee481e76cb3b7ba152e325d9241","date":1456163070,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"419a8f52c6635419beb951255cacbbb281044c57","date":1456189353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"05569170a222447d3aec8fad773feedf4429fdd5","date":1476800012,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // Test PeerSync after replica misses delete\n    v = 2500;\n    add(client0, seenLeader, sdoc(\"id\", \"2500\", \"_version_\", ++v));\n    add(client1, seenLeader, sdoc(\"id\", \"2500\", \"_version_\", v));\n    client0.commit();\n    client1.commit();\n    del(client0, params(DISTRIB_UPDATE_PARAM, FROM_LEADER, \"_version_\", Long.toString(-++v)), \"2500\");\n    add(client0, seenLeader, sdoc(\"id\", \"2501\", \"_version_\", ++v));\n    add(client1, seenLeader, sdoc(\"id\", \"2501\", \"_version_\", v));\n    // Sync should be able to delete the document\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit();\n    client1.commit();\n    queryAndCompare(params(\"q\", \"*:*\", \"sort\", \"_version_ desc\"), client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b437b84da5e49daf1197c9cd533015490cdcb2c2","date":1476818430,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // Test PeerSync after replica misses delete\n    v = 2500;\n    add(client0, seenLeader, sdoc(\"id\", \"2500\", \"_version_\", ++v));\n    add(client1, seenLeader, sdoc(\"id\", \"2500\", \"_version_\", v));\n    client0.commit();\n    client1.commit();\n    del(client0, params(DISTRIB_UPDATE_PARAM, FROM_LEADER, \"_version_\", Long.toString(-++v)), \"2500\");\n    add(client0, seenLeader, sdoc(\"id\", \"2501\", \"_version_\", ++v));\n    add(client1, seenLeader, sdoc(\"id\", \"2501\", \"_version_\", v));\n    // Sync should be able to delete the document\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit();\n    client1.commit();\n    queryAndCompare(params(\"q\", \"*:*\", \"sort\", \"_version_ desc\"), client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b11122ff28c20e6e4e02cb1366eaa029a92f69ce","date":1477307742,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); \n    queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); \n    queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"415bbbe7da8065dd3c477bdc3c703c6425622998","date":1485393793,"type":3,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    Set<Integer> docsAdded = new LinkedHashSet<>();\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n    for (int i=0; i<10; i++) docsAdded.add(i+1);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit();\n    QueryResponse qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n      docsAdded.add(i+11);\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // test delete and deleteByQuery\n    v=1000;\n    SolrInputDocument doc = sdoc(\"id\",\"1000\",\"_version_\",++v);\n    add(client0, seenLeader, doc);\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n    docsAdded.add(1002); // 1002 added\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n    docsAdded.add(2002); // 2002 added\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n    docsAdded.add(3000);\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    docsAdded.add(3001); // 3001 added\n    docsAdded.add(3002); // 3002 added\n    \n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    docsAdded.add(4000);\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      docsAdded.add((int)v+i+1);\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    \n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // lets add some in-place updates\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(0, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    ModifiableSolrParams inPlaceParams = new ModifiableSolrParams(seenLeader);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5000\");\n    add(client0, inPlaceParams, sdoc(\"id\", \"5000\", \"val_i_dvo\", 1, \"_version_\", 5001)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(1, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // interleave the in-place updates with a few deletes to other documents\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5002\"),  4001);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5003\"),  \"id:4002\");\n    docsAdded.remove(4001);\n    docsAdded.remove(4002);\n    \n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5001\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 2, \"_version_\", 5004)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(2, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // a DBQ with value\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5005\"),  \"val_i_dvo:1\"); // current val is 2, so this should not delete anything\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    boolean deleteTheUpdatedDocument = random().nextBoolean();\n    if (deleteTheUpdatedDocument) { // if doc with id=5000 is deleted, further in-place-updates should fail\n      delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5006\"),  \"val_i_dvo:2\"); // current val is 2, this will delete id=5000\n      assertSync(client1, numVersions, true, shardsArr[0]);\n      SolrException ex = expectThrows(SolrException.class, () -> {\n        inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n        add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5007));\n      });\n      assertEquals(ex.toString(), SolrException.ErrorCode.SERVER_ERROR.code, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Can't find document with id=5000\"));\n    } else {\n      inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n      add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5006));\n      assertSync(client1, numVersions, true, shardsArr[0]);\n\n      // verify the in-place updated document (id=5000) has correct fields\n      assertEquals(3, client1.getById(\"5000\").get(\"val_i_dvo\"));\n      assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n          \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n      if (random().nextBoolean()) {\n        client0.commit(); client1.commit();\n        qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n        validateQACResponse(docsAdded, qacResponse);\n      }\n      del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5007\"),  5000);\n      docsAdded.remove(5000);\n      assertSync(client1, numVersions, true, shardsArr[0]);\n\n      client0.commit(); client1.commit();\n      qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n      validateQACResponse(docsAdded, qacResponse);\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); \n    queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":["ce70cdb9511a671e0e15d4dc93b8334c86b6e681"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"598b5d23aa7c9732bf473c21a9cd309c44599394","date":1485530378,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    Set<Integer> docsAdded = new LinkedHashSet<>();\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n    for (int i=0; i<10; i++) docsAdded.add(i+1);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit();\n    QueryResponse qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n      docsAdded.add(i+11);\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // test delete and deleteByQuery\n    v=1000;\n    SolrInputDocument doc = sdoc(\"id\",\"1000\",\"_version_\",++v);\n    add(client0, seenLeader, doc);\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n    docsAdded.add(1002); // 1002 added\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n    docsAdded.add(2002); // 2002 added\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n    docsAdded.add(3000);\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    docsAdded.add(3001); // 3001 added\n    docsAdded.add(3002); // 3002 added\n    \n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    docsAdded.add(4000);\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      docsAdded.add((int)v+i+1);\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    \n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // lets add some in-place updates\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(0, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    ModifiableSolrParams inPlaceParams = new ModifiableSolrParams(seenLeader);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5000\");\n    add(client0, inPlaceParams, sdoc(\"id\", \"5000\", \"val_i_dvo\", 1, \"_version_\", 5001)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(1, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // interleave the in-place updates with a few deletes to other documents\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5002\"),  4001);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5003\"),  \"id:4002\");\n    docsAdded.remove(4001);\n    docsAdded.remove(4002);\n    \n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5001\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 2, \"_version_\", 5004)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(2, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // a DBQ with value\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5005\"),  \"val_i_dvo:1\"); // current val is 2, so this should not delete anything\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    boolean deleteTheUpdatedDocument = random().nextBoolean();\n    if (deleteTheUpdatedDocument) { // if doc with id=5000 is deleted, further in-place-updates should fail\n      delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5006\"),  \"val_i_dvo:2\"); // current val is 2, this will delete id=5000\n      assertSync(client1, numVersions, true, shardsArr[0]);\n      SolrException ex = expectThrows(SolrException.class, () -> {\n        inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n        add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5007));\n      });\n      assertEquals(ex.toString(), SolrException.ErrorCode.SERVER_ERROR.code, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Can't find document with id=5000\"));\n    } else {\n      inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n      add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5006));\n      assertSync(client1, numVersions, true, shardsArr[0]);\n\n      // verify the in-place updated document (id=5000) has correct fields\n      assertEquals(3, client1.getById(\"5000\").get(\"val_i_dvo\"));\n      assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n          \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n      if (random().nextBoolean()) {\n        client0.commit(); client1.commit();\n        qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n        validateQACResponse(docsAdded, qacResponse);\n      }\n      del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5007\"),  5000);\n      docsAdded.remove(5000);\n      assertSync(client1, numVersions, true, shardsArr[0]);\n\n      client0.commit(); client1.commit();\n      qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n      validateQACResponse(docsAdded, qacResponse);\n    }\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    add(client0, seenLeader, sdoc(\"id\",\"1000\",\"_version_\",++v));\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); \n    queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\", \"sort\",\"_version_ desc\"), client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7e2e9e62efb6c79c406fe3c2b8bc2739fa192e40","date":1487267132,"type":3,"author":"yonik","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    Set<Integer> docsAdded = new LinkedHashSet<>();\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n    for (int i=0; i<10; i++) docsAdded.add(i+1);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n      docsAdded.add(i+11);\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    SolrInputDocument doc = sdoc(\"id\",\"1000\",\"_version_\",++v);\n    add(client0, seenLeader, doc);\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n    docsAdded.add(1002); // 1002 added\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n    docsAdded.add(2002); // 2002 added\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n    docsAdded.add(3000);\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    docsAdded.add(3001); // 3001 added\n    docsAdded.add(3002); // 3002 added\n    \n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    docsAdded.add(4000);\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      docsAdded.add((int)v+i+1);\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    \n    validateDocs(docsAdded, client0, client1);\n\n    // lets add some in-place updates\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(0, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    ModifiableSolrParams inPlaceParams = new ModifiableSolrParams(seenLeader);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5000\");\n    add(client0, inPlaceParams, sdoc(\"id\", \"5000\", \"val_i_dvo\", 1, \"_version_\", 5001)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(1, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // interleave the in-place updates with a few deletes to other documents\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5002\"),  4001);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5003\"),  \"id:4002\");\n    docsAdded.remove(4001);\n    docsAdded.remove(4002);\n    \n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5001\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 2, \"_version_\", 5004)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(2, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // a DBQ with value\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5005\"),  \"val_i_dvo:1\"); // current val is 2, so this should not delete anything\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n\n\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5006));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(3, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"),\n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    validateDocs(docsAdded, client0, client1);\n\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5007\"),  5000);\n    docsAdded.remove(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n\n    // if doc with id=6000 is deleted, further in-place-updates should fail\n    add(client0, seenLeader, sdoc(\"id\", \"6000\", \"val_i_dvo\", 6, \"title\", \"mytitle\", \"_version_\", 6000)); // full update\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"6004\"),  \"val_i_dvo:6\"); // current val is 6000, this will delete id=6000\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    SolrException ex = expectThrows(SolrException.class, () -> {\n      inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"6000\");\n      add(client0, inPlaceParams, sdoc(\"id\", 6000, \"val_i_dvo\", 6003, \"_version_\", 5007));\n    });\n    assertEquals(ex.toString(), SolrException.ErrorCode.SERVER_ERROR.code, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Can't find document with id=6000\"));\n\n\n    // Reordered DBQ with Child-nodes (SOLR-10114)\n    docsAdded.clear();\n\n    // Reordered full delete should not delete child-docs\n    add(client0, seenLeader, sdocWithChildren(7001, \"7001\", 2)); // add with later version\n    docsAdded.add(7001);\n    docsAdded.add(7001001);\n    docsAdded.add(7001002);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"7000\"),  \"id:*\"); // reordered delete\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // Reordered DBQ should not affect update\n    add(client0, seenLeader, sdocWithChildren(8000, \"8000\", 5)); // add with later version\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"8002\"),  \"id:8500\"); // not found, arrives earlier\n    add(client0, seenLeader, sdocWithChildren(8000, \"8001\", 2)); // update with two childs\n    docsAdded.add(8000);\n    docsAdded.add(8000001);\n    docsAdded.add(8000002);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    Set<Integer> docsAdded = new LinkedHashSet<>();\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n    for (int i=0; i<10; i++) docsAdded.add(i+1);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit();\n    QueryResponse qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n      docsAdded.add(i+11);\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // test delete and deleteByQuery\n    v=1000;\n    SolrInputDocument doc = sdoc(\"id\",\"1000\",\"_version_\",++v);\n    add(client0, seenLeader, doc);\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n    docsAdded.add(1002); // 1002 added\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n    docsAdded.add(2002); // 2002 added\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n    docsAdded.add(3000);\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    docsAdded.add(3001); // 3001 added\n    docsAdded.add(3002); // 3002 added\n    \n    assertSync(client1, numVersions, true, shardsArr[0]);\n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    docsAdded.add(4000);\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      docsAdded.add((int)v+i+1);\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    \n    client0.commit(); client1.commit();\n    qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n    validateQACResponse(docsAdded, qacResponse);\n\n    // lets add some in-place updates\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(0, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    ModifiableSolrParams inPlaceParams = new ModifiableSolrParams(seenLeader);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5000\");\n    add(client0, inPlaceParams, sdoc(\"id\", \"5000\", \"val_i_dvo\", 1, \"_version_\", 5001)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(1, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // interleave the in-place updates with a few deletes to other documents\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5002\"),  4001);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5003\"),  \"id:4002\");\n    docsAdded.remove(4001);\n    docsAdded.remove(4002);\n    \n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5001\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 2, \"_version_\", 5004)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(2, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // a DBQ with value\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5005\"),  \"val_i_dvo:1\"); // current val is 2, so this should not delete anything\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    boolean deleteTheUpdatedDocument = random().nextBoolean();\n    if (deleteTheUpdatedDocument) { // if doc with id=5000 is deleted, further in-place-updates should fail\n      delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5006\"),  \"val_i_dvo:2\"); // current val is 2, this will delete id=5000\n      assertSync(client1, numVersions, true, shardsArr[0]);\n      SolrException ex = expectThrows(SolrException.class, () -> {\n        inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n        add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5007));\n      });\n      assertEquals(ex.toString(), SolrException.ErrorCode.SERVER_ERROR.code, ex.code());\n      assertThat(ex.getMessage(), containsString(\"Can't find document with id=5000\"));\n    } else {\n      inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n      add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5006));\n      assertSync(client1, numVersions, true, shardsArr[0]);\n\n      // verify the in-place updated document (id=5000) has correct fields\n      assertEquals(3, client1.getById(\"5000\").get(\"val_i_dvo\"));\n      assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n          \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n      if (random().nextBoolean()) {\n        client0.commit(); client1.commit();\n        qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n        validateQACResponse(docsAdded, qacResponse);\n      }\n      del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5007\"),  5000);\n      docsAdded.remove(5000);\n      assertSync(client1, numVersions, true, shardsArr[0]);\n\n      client0.commit(); client1.commit();\n      qacResponse = queryAndCompare(params(\"q\", \"*:*\", \"rows\", \"10000\", \"sort\",\"_version_ desc\"), client0, client1);\n      validateQACResponse(docsAdded, qacResponse);\n    }\n  }\n\n","bugFix":null,"bugIntro":["ce70cdb9511a671e0e15d4dc93b8334c86b6e681"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce70cdb9511a671e0e15d4dc93b8334c86b6e681","date":1542017422,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/PeerSyncTest#test().mjava","sourceNew":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    Set<Integer> docsAdded = new LinkedHashSet<>();\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n    for (int i=0; i<10; i++) docsAdded.add(i+1);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n    testOverlap(docsAdded, client0, client1, v);\n    // test delete and deleteByQuery\n    v=1000;\n    SolrInputDocument doc = sdoc(\"id\",\"1000\",\"_version_\",++v);\n    add(client0, seenLeader, doc);\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n    docsAdded.add(1002); // 1002 added\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n    docsAdded.add(2002); // 2002 added\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n    docsAdded.add(3000);\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    docsAdded.add(3001); // 3001 added\n    docsAdded.add(3002); // 3002 added\n    \n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    docsAdded.add(4000);\n    int toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      docsAdded.add((int)v+i+1);\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    \n    validateDocs(docsAdded, client0, client1);\n\n    // lets add some in-place updates\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(0, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    ModifiableSolrParams inPlaceParams = new ModifiableSolrParams(seenLeader);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5000\");\n    add(client0, inPlaceParams, sdoc(\"id\", \"5000\", \"val_i_dvo\", 1, \"_version_\", 5001)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(1, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // interleave the in-place updates with a few deletes to other documents\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5002\"),  4001);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5003\"),  \"id:4002\");\n    docsAdded.remove(4001);\n    docsAdded.remove(4002);\n    \n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5001\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 2, \"_version_\", 5004)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(2, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // a DBQ with value\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5005\"),  \"val_i_dvo:1\"); // current val is 2, so this should not delete anything\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n\n\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5006));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(3, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"),\n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    validateDocs(docsAdded, client0, client1);\n\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5007\"),  5000);\n    docsAdded.remove(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n\n    // if doc with id=6000 is deleted, further in-place-updates should fail\n    add(client0, seenLeader, sdoc(\"id\", \"6000\", \"val_i_dvo\", 6, \"title\", \"mytitle\", \"_version_\", 6000)); // full update\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"6004\"),  \"val_i_dvo:6\"); // current val is 6000, this will delete id=6000\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    SolrException ex = expectThrows(SolrException.class, () -> {\n      inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"6000\");\n      add(client0, inPlaceParams, sdoc(\"id\", 6000, \"val_i_dvo\", 6003, \"_version_\", 5007));\n    });\n    assertEquals(ex.toString(), SolrException.ErrorCode.SERVER_ERROR.code, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Can't find document with id=6000\"));\n\n\n    // Reordered DBQ with Child-nodes (SOLR-10114)\n    docsAdded.clear();\n\n    // Reordered full delete should not delete child-docs\n    add(client0, seenLeader, sdocWithChildren(7001, \"7001\", 2)); // add with later version\n    docsAdded.add(7001);\n    docsAdded.add(7001001);\n    docsAdded.add(7001002);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"7000\"),  \"id:*\"); // reordered delete\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // Reordered DBQ should not affect update\n    add(client0, seenLeader, sdocWithChildren(8000, \"8000\", 5)); // add with later version\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"8002\"),  \"id:8500\"); // not found, arrives earlier\n    add(client0, seenLeader, sdocWithChildren(8000, \"8001\", 2)); // update with two childs\n    docsAdded.add(8000);\n    docsAdded.add(8000001);\n    docsAdded.add(8000002);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n  }\n\n","sourceOld":"  @Test\n  @ShardsFixed(num = 3)\n  public void test() throws Exception {\n    Set<Integer> docsAdded = new LinkedHashSet<>();\n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    handle.put(\"score\", SKIPVAL);\n    handle.put(\"maxScore\", SKIPVAL);\n\n    SolrClient client0 = clients.get(0);\n    SolrClient client1 = clients.get(1);\n    SolrClient client2 = clients.get(2);\n\n    long v = 0;\n    add(client0, seenLeader, sdoc(\"id\",\"1\",\"_version_\",++v));\n\n    // this fails because client0 has no context (i.e. no updates of its own to judge if applying the updates\n    // from client1 will bring it into sync with client1)\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // bring client1 back into sync with client0 by adding the doc\n    add(client1, seenLeader, sdoc(\"id\",\"1\",\"_version_\",v));\n\n    // both have the same version list, so sync should now return true\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // TODO: test that updates weren't necessary\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"2\",\"_version_\",++v)));\n\n    // now client1 has the context to sync\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    client0.commit(); client1.commit(); queryAndCompare(params(\"q\", \"*:*\"), client0, client1);\n\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"3\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"4\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"5\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"6\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"7\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"8\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"9\",\"_version_\",++v)));\n    add(client0, seenLeader, addRandFields(sdoc(\"id\",\"10\",\"_version_\",++v)));\n    for (int i=0; i<10; i++) docsAdded.add(i+1);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n    int toAdd = (int)(numVersions *.95);\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n      docsAdded.add(i+11);\n    }\n\n    // sync should fail since there's not enough overlap to give us confidence\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // add some of the docs that were missing... just enough to give enough overlap\n    int toAdd2 = (int)(numVersions * .25);\n    for (int i=0; i<toAdd2; i++) {\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString(i+11),\"_version_\",v+i+1));\n    }\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // test delete and deleteByQuery\n    v=1000;\n    SolrInputDocument doc = sdoc(\"id\",\"1000\",\"_version_\",++v);\n    add(client0, seenLeader, doc);\n    add(client0, seenLeader, sdoc(\"id\",\"1001\",\"_version_\",++v));\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:1001 OR id:1002\");\n    add(client0, seenLeader, sdoc(\"id\",\"1002\",\"_version_\",++v));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"1000\");\n    docsAdded.add(1002); // 1002 added\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // test that delete by query is returned even if not requested, and that it doesn't delete newer stuff than it should\n    v=2000;\n    SolrClient client = client0;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n    docsAdded.add(2002); // 2002 added\n\n    v=2000;\n    client = client1;\n    add(client, seenLeader, sdoc(\"id\",\"2000\",\"_version_\",++v));\n    ++v;  // pretend we missed the add of 2001.  peersync should retrieve it, but should also retrieve any deleteByQuery objects after it\n    // add(client, seenLeader, sdoc(\"id\",\"2001\",\"_version_\",++v));\n    delQ(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"id:2001 OR id:2002\");\n    add(client, seenLeader, sdoc(\"id\",\"2002\",\"_version_\",++v));\n    del(client, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",Long.toString(-++v)), \"2000\");\n\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n    //\n    // Test that handling reorders work when applying docs retrieved from peer\n    //\n\n    // this should cause us to retrieve the delete (but not the following add)\n    // the reorder in application shouldn't affect anything\n    add(client0, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    add(client1, seenLeader, sdoc(\"id\",\"3000\",\"_version_\",3001));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3000\"),  \"3000\");\n    docsAdded.add(3000);\n\n    // this should cause us to retrieve an add tha was previously deleted\n    add(client0, seenLeader, sdoc(\"id\",\"3001\",\"_version_\",3003));\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n    del(client1, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"3001\"),  \"3004\");\n\n    // this should cause us to retrieve an older add that was overwritten\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3004));\n    add(client0, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    add(client1, seenLeader, sdoc(\"id\",\"3002\",\"_version_\",3005));\n    docsAdded.add(3001); // 3001 added\n    docsAdded.add(3002); // 3002 added\n    \n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // now lets check fingerprinting causes appropriate fails\n    v = 4000;\n    add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    docsAdded.add(4000);\n    toAdd = numVersions+10;\n    for (int i=0; i<toAdd; i++) {\n      add(client0, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v+i+1),\"_version_\",v+i+1));\n      docsAdded.add((int)v+i+1);\n    }\n\n    // client0 now has an additional add beyond our window and the fingerprint should cause this to fail\n    assertSync(client1, numVersions, false, shardsArr[0]);\n\n    // if we turn of fingerprinting, it should succeed\n    System.setProperty(\"solr.disableFingerprint\", \"true\");\n    try {\n      assertSync(client1, numVersions, true, shardsArr[0]);\n    } finally {\n      System.clearProperty(\"solr.disableFingerprint\");\n    }\n\n    // lets add the missing document and verify that order doesn't matter\n    add(client1, seenLeader, sdoc(\"id\",Integer.toString((int)v),\"_version_\",v));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // lets do some overwrites to ensure that repeated updates and maxDoc don't matter\n    for (int i=0; i<10; i++) {\n      add(client0, seenLeader, sdoc(\"id\", Integer.toString((int) v + i + 1), \"_version_\", v + i + 1));\n    }\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    \n    validateDocs(docsAdded, client0, client1);\n\n    // lets add some in-place updates\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(0, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    ModifiableSolrParams inPlaceParams = new ModifiableSolrParams(seenLeader);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5000\");\n    add(client0, inPlaceParams, sdoc(\"id\", \"5000\", \"val_i_dvo\", 1, \"_version_\", 5001)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(1, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // interleave the in-place updates with a few deletes to other documents\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5002\"),  4001);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5003\"),  \"id:4002\");\n    docsAdded.remove(4001);\n    docsAdded.remove(4002);\n    \n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5001\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 2, \"_version_\", 5004)); // in-place update\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(2, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"), \n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    // a DBQ with value\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5005\"),  \"val_i_dvo:1\"); // current val is 2, so this should not delete anything\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n\n\n    add(client0, seenLeader, sdoc(\"id\", \"5000\", \"val_i_dvo\", 0, \"title\", \"mytitle\", \"_version_\", 5000)); // full update\n    docsAdded.add(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"5004\");\n    add(client0, inPlaceParams, sdoc(\"id\", 5000, \"val_i_dvo\", 3, \"_version_\", 5006));\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    // verify the in-place updated document (id=5000) has correct fields\n    assertEquals(3, client1.getById(\"5000\").get(\"val_i_dvo\"));\n    assertEquals(client0.getById(\"5000\")+\" and \"+client1.getById(\"5000\"),\n        \"mytitle\", client1.getById(\"5000\").getFirstValue(\"title\"));\n\n    validateDocs(docsAdded, client0, client1);\n\n    del(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"5007\"),  5000);\n    docsAdded.remove(5000);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n\n    validateDocs(docsAdded, client0, client1);\n\n\n    // if doc with id=6000 is deleted, further in-place-updates should fail\n    add(client0, seenLeader, sdoc(\"id\", \"6000\", \"val_i_dvo\", 6, \"title\", \"mytitle\", \"_version_\", 6000)); // full update\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"6004\"),  \"val_i_dvo:6\"); // current val is 6000, this will delete id=6000\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    SolrException ex = expectThrows(SolrException.class, () -> {\n      inPlaceParams.set(DistributedUpdateProcessor.DISTRIB_INPLACE_PREVVERSION, \"6000\");\n      add(client0, inPlaceParams, sdoc(\"id\", 6000, \"val_i_dvo\", 6003, \"_version_\", 5007));\n    });\n    assertEquals(ex.toString(), SolrException.ErrorCode.SERVER_ERROR.code, ex.code());\n    assertThat(ex.getMessage(), containsString(\"Can't find document with id=6000\"));\n\n\n    // Reordered DBQ with Child-nodes (SOLR-10114)\n    docsAdded.clear();\n\n    // Reordered full delete should not delete child-docs\n    add(client0, seenLeader, sdocWithChildren(7001, \"7001\", 2)); // add with later version\n    docsAdded.add(7001);\n    docsAdded.add(7001001);\n    docsAdded.add(7001002);\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"7000\"),  \"id:*\"); // reordered delete\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n    // Reordered DBQ should not affect update\n    add(client0, seenLeader, sdocWithChildren(8000, \"8000\", 5)); // add with later version\n    delQ(client0, params(DISTRIB_UPDATE_PARAM,FROM_LEADER,\"_version_\",\"8002\"),  \"id:8500\"); // not found, arrives earlier\n    add(client0, seenLeader, sdocWithChildren(8000, \"8001\", 2)); // update with two childs\n    docsAdded.add(8000);\n    docsAdded.add(8000001);\n    docsAdded.add(8000002);\n    assertSync(client1, numVersions, true, shardsArr[0]);\n    validateDocs(docsAdded, client0, client1);\n\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f","7e2e9e62efb6c79c406fe3c2b8bc2739fa192e40","415bbbe7da8065dd3c477bdc3c703c6425622998","979e22aa7c63c9dc651adf861610c7e444d45832"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["b11122ff28c20e6e4e02cb1366eaa029a92f69ce"],"598b5d23aa7c9732bf473c21a9cd309c44599394":["80d0e6d59ae23f4a6f30eaf40bfb40742300287f","415bbbe7da8065dd3c477bdc3c703c6425622998"],"abb23fcc2461782ab204e61213240feb77d355aa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ce70cdb9511a671e0e15d4dc93b8334c86b6e681":["7e2e9e62efb6c79c406fe3c2b8bc2739fa192e40"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["abb23fcc2461782ab204e61213240feb77d355aa","979e22aa7c63c9dc651adf861610c7e444d45832"],"419a8f52c6635419beb951255cacbbb281044c57":["979e22aa7c63c9dc651adf861610c7e444d45832","62615e56c1409ee481e76cb3b7ba152e325d9241"],"05569170a222447d3aec8fad773feedf4429fdd5":["419a8f52c6635419beb951255cacbbb281044c57"],"7e2e9e62efb6c79c406fe3c2b8bc2739fa192e40":["415bbbe7da8065dd3c477bdc3c703c6425622998"],"b11122ff28c20e6e4e02cb1366eaa029a92f69ce":["b437b84da5e49daf1197c9cd533015490cdcb2c2"],"b437b84da5e49daf1197c9cd533015490cdcb2c2":["05569170a222447d3aec8fad773feedf4429fdd5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["419a8f52c6635419beb951255cacbbb281044c57","b11122ff28c20e6e4e02cb1366eaa029a92f69ce"],"979e22aa7c63c9dc651adf861610c7e444d45832":["abb23fcc2461782ab204e61213240feb77d355aa"],"b1704c078ec59838c9d95d5bf5738b393b537494":["abb23fcc2461782ab204e61213240feb77d355aa","979e22aa7c63c9dc651adf861610c7e444d45832"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ce70cdb9511a671e0e15d4dc93b8334c86b6e681"],"62615e56c1409ee481e76cb3b7ba152e325d9241":["979e22aa7c63c9dc651adf861610c7e444d45832"]},"commit2Childs":{"415bbbe7da8065dd3c477bdc3c703c6425622998":["598b5d23aa7c9732bf473c21a9cd309c44599394","7e2e9e62efb6c79c406fe3c2b8bc2739fa192e40"],"598b5d23aa7c9732bf473c21a9cd309c44599394":[],"abb23fcc2461782ab204e61213240feb77d355aa":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","979e22aa7c63c9dc651adf861610c7e444d45832","b1704c078ec59838c9d95d5bf5738b393b537494"],"ce70cdb9511a671e0e15d4dc93b8334c86b6e681":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"419a8f52c6635419beb951255cacbbb281044c57":["05569170a222447d3aec8fad773feedf4429fdd5","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"05569170a222447d3aec8fad773feedf4429fdd5":["b437b84da5e49daf1197c9cd533015490cdcb2c2"],"7e2e9e62efb6c79c406fe3c2b8bc2739fa192e40":["ce70cdb9511a671e0e15d4dc93b8334c86b6e681"],"b11122ff28c20e6e4e02cb1366eaa029a92f69ce":["415bbbe7da8065dd3c477bdc3c703c6425622998","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"b437b84da5e49daf1197c9cd533015490cdcb2c2":["b11122ff28c20e6e4e02cb1366eaa029a92f69ce"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["598b5d23aa7c9732bf473c21a9cd309c44599394"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["abb23fcc2461782ab204e61213240feb77d355aa"],"979e22aa7c63c9dc651adf861610c7e444d45832":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","419a8f52c6635419beb951255cacbbb281044c57","b1704c078ec59838c9d95d5bf5738b393b537494","62615e56c1409ee481e76cb3b7ba152e325d9241"],"b1704c078ec59838c9d95d5bf5738b393b537494":[],"62615e56c1409ee481e76cb3b7ba152e325d9241":["419a8f52c6635419beb951255cacbbb281044c57"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["598b5d23aa7c9732bf473c21a9cd309c44599394","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b1704c078ec59838c9d95d5bf5738b393b537494","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}