{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","commits":[{"id":"44de42d869f7d8e5235d43c4ad9a99f520363a2f","date":1389871557,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"/dev/null","sourceNew":"  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase().equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase().equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf3dec259855047447dd4d8b00a92ac220a476d1","date":1389889474,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","sourceNew":"  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":"  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase().equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase().equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8497bb4f9de61b5520423bd9af88ea11a6e109e7","date":1393245090,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","sourceNew":" /* private void handleProp(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String name = message.getStr(\"name\");\n    String val = message.getStr(\"val\");\n    Map m = zkStateReader.getClusterProps();\n    if(val ==null) m.remove(name);\n    else m.put(name,val);\n    if(zkStateReader.getZkClient().exists(ZkStateReader.CLUSTER_PROPS,true))\n      zkStateReader.getZkClient().setData(ZkStateReader.CLUSTER_PROPS,ZkStateReader.toJSON(m),true);\n    else\n      zkStateReader.getZkClient().create(ZkStateReader.CLUSTER_PROPS, ZkStateReader.toJSON(m),CreateMode.PERSISTENT, true);\n\n\n\n  }*/\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":"  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6225820ca5f401e2fe460f36e4a919a384cef6c","date":1393272577,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","sourceNew":"  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":" /* private void handleProp(ZkNodeProps message, NamedList results) throws KeeperException, InterruptedException {\n    String name = message.getStr(\"name\");\n    String val = message.getStr(\"val\");\n    Map m = zkStateReader.getClusterProps();\n    if(val ==null) m.remove(name);\n    else m.put(name,val);\n    if(zkStateReader.getZkClient().exists(ZkStateReader.CLUSTER_PROPS,true))\n      zkStateReader.getZkClient().setData(ZkStateReader.CLUSTER_PROPS,ZkStateReader.toJSON(m),true);\n    else\n      zkStateReader.getZkClient().create(ZkStateReader.CLUSTER_PROPS, ZkStateReader.toJSON(m),CreateMode.PERSISTENT, true);\n\n\n\n  }*/\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c688f7052130cef7bd419c85e3c5be214f7b9e","date":1411018984,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":"  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b693a83132c9e45afcd564fd65a25b60ed80388b","date":1436882146,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) Utils.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, Utils.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, Utils.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) ZkStateReader.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, ZkStateReader.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, ZkStateReader.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionMessageHandler#processRoleCommand(ZkNodeProps,String).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor#processRoleCommand(ZkNodeProps,String).mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) Utils.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, Utils.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, Utils.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          overseerPrioritizer.prioritizeOverseerNodes(myId);\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  private void processRoleCommand(ZkNodeProps message, String operation) throws KeeperException, InterruptedException {\n    SolrZkClient zkClient = zkStateReader.getZkClient();\n    Map roles = null;\n    String node = message.getStr(\"node\");\n\n    String roleName = message.getStr(\"role\");\n    boolean nodeExists = false;\n    if(nodeExists = zkClient.exists(ZkStateReader.ROLES, true)){\n      roles = (Map) Utils.fromJSON(zkClient.getData(ZkStateReader.ROLES, null, new Stat(), true));\n    } else {\n      roles = new LinkedHashMap(1);\n    }\n\n    List nodeList= (List) roles.get(roleName);\n    if(nodeList == null) roles.put(roleName, nodeList = new ArrayList());\n    if(ADDROLE.toString().toLowerCase(Locale.ROOT).equals(operation) ){\n      log.info(\"Overseer role added to {}\", node);\n      if(!nodeList.contains(node)) nodeList.add(node);\n    } else if(REMOVEROLE.toString().toLowerCase(Locale.ROOT).equals(operation)) {\n      log.info(\"Overseer role removed from {}\", node);\n      nodeList.remove(node);\n    }\n\n    if(nodeExists){\n      zkClient.setData(ZkStateReader.ROLES, Utils.toJSON(roles),true);\n    } else {\n      zkClient.create(ZkStateReader.ROLES, Utils.toJSON(roles), CreateMode.PERSISTENT,true);\n    }\n    //if there are too many nodes this command may time out. And most likely dedicated\n    // overseers are created when there are too many nodes  . So , do this operation in a separate thread\n    new Thread(){\n      @Override\n      public void run() {\n        try {\n          prioritizeOverseerNodes();\n        } catch (Exception e) {\n          log.error(\"Error in prioritizing Overseer\",e);\n        }\n\n      }\n    }.start();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"bf3dec259855047447dd4d8b00a92ac220a476d1":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b693a83132c9e45afcd564fd65a25b60ed80388b":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"e6225820ca5f401e2fe460f36e4a919a384cef6c":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["e6225820ca5f401e2fe460f36e4a919a384cef6c"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["bf3dec259855047447dd4d8b00a92ac220a476d1"],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"]},"commit2Childs":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bf3dec259855047447dd4d8b00a92ac220a476d1":["8497bb4f9de61b5520423bd9af88ea11a6e109e7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["44de42d869f7d8e5235d43c4ad9a99f520363a2f"],"b693a83132c9e45afcd564fd65a25b60ed80388b":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"e6225820ca5f401e2fe460f36e4a919a384cef6c":["30c688f7052130cef7bd419c85e3c5be214f7b9e"],"44de42d869f7d8e5235d43c4ad9a99f520363a2f":["bf3dec259855047447dd4d8b00a92ac220a476d1"],"30c688f7052130cef7bd419c85e3c5be214f7b9e":["b693a83132c9e45afcd564fd65a25b60ed80388b"],"8497bb4f9de61b5520423bd9af88ea11a6e109e7":["e6225820ca5f401e2fe460f36e4a919a384cef6c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}