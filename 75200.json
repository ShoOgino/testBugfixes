{"path":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","commits":[{"id":"55110eb60c5105294fc2ae7912d82b750865aa58","date":1341389822,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) throws IOException {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) throws IOException {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"035130b0c342f404c027af8c8870587c3741cb1e","date":1342898805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) throws IOException {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e099715aa0cb8da9a56320dd21c24f1ad6728b03","date":1345471998,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8615860cb50aefb8eebca1d1b3893dbe21cf126","date":1345550448,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) throws IOException {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"001b25b42373b22a52f399dbf072f1224632e8e6","date":1345889167,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) throws IOException {\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cb89814ad85fb3340f275e6b76a0bc319a6cc02b","date":1348100270,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @throws IOException\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c661dcad9680b8a6ce5bf2cc583a69ec965328bc","date":1352297862,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);\n        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {\n          assert version == VERSION_START;\n          final long endPointer = in.getFilePointer() + byteCount;\n          // Some consumers of direct readers assume that reading the last value\n          // will make the underlying IndexInput go to the end of the packed\n          // stream, but this is not true because packed ints storage used to be\n          // long-aligned and is now byte-aligned, hence this additional\n          // condition when reading the last value\n          return new DirectPackedReader(bitsPerValue, valueCount, in) {\n            @Override\n            public long get(int index) {\n              final long result = super.get(index);\n              if (index == valueCount - 1) {\n                try {\n                  in.seek(endPointer);\n                } catch (IOException e) {\n                  throw new IllegalStateException(\"failed\", e);\n                }\n              }\n              return result;\n            }\n          };\n        } else {\n          return new DirectPackedReader(bitsPerValue, valueCount, in);\n        }\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3","date":1401710950,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);\n        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {\n          assert version == VERSION_START;\n          final long endPointer = in.getFilePointer() + byteCount;\n          // Some consumers of direct readers assume that reading the last value\n          // will make the underlying IndexInput go to the end of the packed\n          // stream, but this is not true because packed ints storage used to be\n          // long-aligned and is now byte-aligned, hence this additional\n          // condition when reading the last value\n          return new DirectPackedReader(bitsPerValue, valueCount, in) {\n            @Override\n            public long get(int index) {\n              final long result = super.get(index);\n              if (index == valueCount - 1) {\n                try {\n                  in.seek(endPointer);\n                } catch (IOException e) {\n                  throw new IllegalStateException(\"failed\", e);\n                }\n              }\n              return result;\n            }\n          };\n        } else {\n          return DirectPackedReader.getInstance(bitsPerValue, valueCount, in);\n        }\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);\n        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {\n          assert version == VERSION_START;\n          final long endPointer = in.getFilePointer() + byteCount;\n          // Some consumers of direct readers assume that reading the last value\n          // will make the underlying IndexInput go to the end of the packed\n          // stream, but this is not true because packed ints storage used to be\n          // long-aligned and is now byte-aligned, hence this additional\n          // condition when reading the last value\n          return new DirectPackedReader(bitsPerValue, valueCount, in) {\n            @Override\n            public long get(int index) {\n              final long result = super.get(index);\n              if (index == valueCount - 1) {\n                try {\n                  in.seek(endPointer);\n                } catch (IOException e) {\n                  throw new IllegalStateException(\"failed\", e);\n                }\n              }\n              return result;\n            }\n          };\n        } else {\n          return new DirectPackedReader(bitsPerValue, valueCount, in);\n        }\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8106bc60c7452250f84c65cdb43ab6b1d8eb1534","date":1401906364,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);\n        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {\n          assert version == VERSION_START;\n          final long endPointer = in.getFilePointer() + byteCount;\n          // Some consumers of direct readers assume that reading the last value\n          // will make the underlying IndexInput go to the end of the packed\n          // stream, but this is not true because packed ints storage used to be\n          // long-aligned and is now byte-aligned, hence this additional\n          // condition when reading the last value\n          return new DirectPackedReader(bitsPerValue, valueCount, in) {\n            @Override\n            public long get(int index) {\n              final long result = super.get(index);\n              if (index == valueCount - 1) {\n                try {\n                  in.seek(endPointer);\n                } catch (IOException e) {\n                  throw new IllegalStateException(\"failed\", e);\n                }\n              }\n              return result;\n            }\n          };\n        } else {\n          return new DirectPackedReader(bitsPerValue, valueCount, in);\n        }\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);\n        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {\n          assert version == VERSION_START;\n          final long endPointer = in.getFilePointer() + byteCount;\n          // Some consumers of direct readers assume that reading the last value\n          // will make the underlying IndexInput go to the end of the packed\n          // stream, but this is not true because packed ints storage used to be\n          // long-aligned and is now byte-aligned, hence this additional\n          // condition when reading the last value\n          return new DirectPackedReader(bitsPerValue, valueCount, in) {\n            @Override\n            public long get(int index) {\n              final long result = super.get(index);\n              if (index == valueCount - 1) {\n                try {\n                  in.seek(endPointer);\n                } catch (IOException e) {\n                  throw new IllegalStateException(\"failed\", e);\n                }\n              }\n              return result;\n            }\n          };\n        } else {\n          return DirectPackedReader.getInstance(bitsPerValue, valueCount, in);\n        }\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0b5f2776cabd1c1bbd3fe122be0f1d547189717","date":1418824930,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        final long byteCount = format.byteCount(version, valueCount, bitsPerValue);\n        if (byteCount != format.byteCount(VERSION_CURRENT, valueCount, bitsPerValue)) {\n          assert version == VERSION_START;\n          final long endPointer = in.getFilePointer() + byteCount;\n          // Some consumers of direct readers assume that reading the last value\n          // will make the underlying IndexInput go to the end of the packed\n          // stream, but this is not true because packed ints storage used to be\n          // long-aligned and is now byte-aligned, hence this additional\n          // condition when reading the last value\n          return new DirectPackedReader(bitsPerValue, valueCount, in) {\n            @Override\n            public long get(int index) {\n              final long result = super.get(index);\n              if (index == valueCount - 1) {\n                try {\n                  in.seek(endPointer);\n                } catch (IOException e) {\n                  throw new IllegalStateException(\"failed\", e);\n                }\n              }\n              return result;\n            }\n          };\n        } else {\n          return new DirectPackedReader(bitsPerValue, valueCount, in);\n        }\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"14600834a1fbc7c12faf344466e00cca8cc67de4","date":1423303834,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * <p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * </p><p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2af44fa9bd43d5df330d6438c1af390323f7d567","date":1574847240,"type":3,"author":"Benedict Jin","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/packed/PackedInts#getDirectReaderNoHeader(IndexInput,Format,int,int,int).mjava","sourceNew":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * <p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknown format: \" + format);\n    }\n  }\n\n","sourceOld":"  /**\n   * Expert: Construct a direct {@link Reader} from a stream without reading\n   * metadata at the beginning of the stream. This method is useful to restore\n   * data from streams which have been created using\n   * {@link PackedInts#getWriterNoHeader(DataOutput, Format, int, int, int)}.\n   * <p>\n   * The returned reader will have very little memory overhead, but every call\n   * to {@link Reader#get(int)} is likely to perform a disk seek.\n   *\n   * @param in           the stream to read data from\n   * @param format       the format used to serialize\n   * @param version      the version used to serialize the data\n   * @param valueCount   how many values the stream holds\n   * @param bitsPerValue the number of bits per value\n   * @return a direct Reader\n   * @lucene.internal\n   */\n  public static Reader getDirectReaderNoHeader(final IndexInput in, Format format,\n      int version, int valueCount, int bitsPerValue) {\n    checkVersion(version);\n    switch (format) {\n      case PACKED:\n        return new DirectPackedReader(bitsPerValue, valueCount, in);\n      case PACKED_SINGLE_BLOCK:\n        return new DirectPacked64SingleBlockReader(bitsPerValue, valueCount, in);\n      default:\n        throw new AssertionError(\"Unknwown format: \" + format);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"001b25b42373b22a52f399dbf072f1224632e8e6":["55110eb60c5105294fc2ae7912d82b750865aa58","f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"c0b5f2776cabd1c1bbd3fe122be0f1d547189717":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"55110eb60c5105294fc2ae7912d82b750865aa58":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"14600834a1fbc7c12faf344466e00cca8cc67de4":["c0b5f2776cabd1c1bbd3fe122be0f1d547189717"],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["cb89814ad85fb3340f275e6b76a0bc319a6cc02b"],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["55110eb60c5105294fc2ae7912d82b750865aa58","e099715aa0cb8da9a56320dd21c24f1ad6728b03"],"cb89814ad85fb3340f275e6b76a0bc319a6cc02b":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","55110eb60c5105294fc2ae7912d82b750865aa58"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"2af44fa9bd43d5df330d6438c1af390323f7d567":["14600834a1fbc7c12faf344466e00cca8cc67de4"],"035130b0c342f404c027af8c8870587c3741cb1e":["fe33227f6805edab2036cbb80645cc4e2d1fa424"],"e099715aa0cb8da9a56320dd21c24f1ad6728b03":["035130b0c342f404c027af8c8870587c3741cb1e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2af44fa9bd43d5df330d6438c1af390323f7d567"]},"commit2Childs":{"001b25b42373b22a52f399dbf072f1224632e8e6":[],"55110eb60c5105294fc2ae7912d82b750865aa58":["001b25b42373b22a52f399dbf072f1224632e8e6","f8615860cb50aefb8eebca1d1b3893dbe21cf126","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"c0b5f2776cabd1c1bbd3fe122be0f1d547189717":["14600834a1fbc7c12faf344466e00cca8cc67de4"],"14600834a1fbc7c12faf344466e00cca8cc67de4":["2af44fa9bd43d5df330d6438c1af390323f7d567"],"c661dcad9680b8a6ce5bf2cc583a69ec965328bc":["d36ccb9a1c11aeb91962e89bda4a2e643c8629b3"],"f8615860cb50aefb8eebca1d1b3893dbe21cf126":["001b25b42373b22a52f399dbf072f1224632e8e6","cb89814ad85fb3340f275e6b76a0bc319a6cc02b"],"cb89814ad85fb3340f275e6b76a0bc319a6cc02b":["c661dcad9680b8a6ce5bf2cc583a69ec965328bc"],"d36ccb9a1c11aeb91962e89bda4a2e643c8629b3":["8106bc60c7452250f84c65cdb43ab6b1d8eb1534"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["035130b0c342f404c027af8c8870587c3741cb1e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["55110eb60c5105294fc2ae7912d82b750865aa58","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"8106bc60c7452250f84c65cdb43ab6b1d8eb1534":["c0b5f2776cabd1c1bbd3fe122be0f1d547189717"],"2af44fa9bd43d5df330d6438c1af390323f7d567":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"035130b0c342f404c027af8c8870587c3741cb1e":["e099715aa0cb8da9a56320dd21c24f1ad6728b03"],"e099715aa0cb8da9a56320dd21c24f1ad6728b03":["f8615860cb50aefb8eebca1d1b3893dbe21cf126"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["001b25b42373b22a52f399dbf072f1224632e8e6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}