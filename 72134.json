{"path":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","commits":[{"id":"9fc0d60683b47b5d922124c31f57c8b34734f9e6","date":1480846684,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = 0;\n      for(;prefix<bytesPerDim;prefix++) {\n        if (splitPackedValues[address+prefix] != lastSplitValues[splitDim * bytesPerDim + prefix]) {\n          break;\n        }\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9856095f7afb5a607bf5e65077615ed91273508c","date":1481837697,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = 0;\n      for(;prefix<bytesPerDim;prefix++) {\n        if (splitPackedValues[address+prefix] != lastSplitValues[splitDim * bytesPerDim + prefix]) {\n          break;\n        }\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f6652c943595e92c187ee904c382863013eae28f","date":1539042663,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = 0;\n      for(;prefix<bytesPerDim;prefix++) {\n        if (splitPackedValues[address+prefix] != lastSplitValues[splitDim * bytesPerDim + prefix]) {\n          break;\n        }\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = 0;\n      for(;prefix<bytesPerDim;prefix++) {\n        if (splitPackedValues[address+prefix] != lastSplitValues[splitDim * bytesPerDim + prefix]) {\n          break;\n        }\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"68144b3b30df82b7233727bc4fb958ce52e5b483","date":1543396715,"type":3,"author":"Christoph Büscher","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = FutureArrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = 0;\n      for(;prefix<bytesPerDim;prefix++) {\n        if (splitPackedValues[address+prefix] != lastSplitValues[splitDim * bytesPerDim + prefix]) {\n          break;\n        }\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"409da428f28953cf35fddd5c9ff5c7e4f5439863","date":1547556145,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(ByteBuffersDataOutput,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/bkd/BKDWriter#recursePackIndex(RAMOutputStream,long[],byte[],long,List[byte[]],int,byte[],boolean[],boolean).mjava","sourceNew":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(ByteBuffersDataOutput writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = FutureArrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      \n      byte[] bytes2 = writeBuffer.toArrayCopy();\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + bytes2.length + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","sourceOld":"  /**\n   * lastSplitValues is per-dimension split value previously seen; we use this to prefix-code the split byte[] on each inner node\n   */\n  private int recursePackIndex(RAMOutputStream writeBuffer, long[] leafBlockFPs, byte[] splitPackedValues, long minBlockFP, List<byte[]> blocks,\n                               int nodeID, byte[] lastSplitValues, boolean[] negativeDeltas, boolean isLeft) throws IOException {\n    if (nodeID >= leafBlockFPs.length) {\n      int leafID = nodeID - leafBlockFPs.length;\n      //System.out.println(\"recursePack leaf nodeID=\" + nodeID);\n\n      // In the unbalanced case it's possible the left most node only has one child:\n      if (leafID < leafBlockFPs.length) {\n        long delta = leafBlockFPs[leafID] - minBlockFP;\n        if (isLeft) {\n          assert delta == 0;\n          return 0;\n        } else {\n          assert nodeID == 1 || delta > 0: \"nodeID=\" + nodeID;\n          writeBuffer.writeVLong(delta);\n          return appendBlock(writeBuffer, blocks);\n        }\n      } else {\n        return 0;\n      }\n    } else {\n      long leftBlockFP;\n      if (isLeft == false) {\n        leftBlockFP = getLeftMostLeafBlockFP(leafBlockFPs, nodeID);\n        long delta = leftBlockFP - minBlockFP;\n        assert nodeID == 1 || delta > 0 : \"expected nodeID=1 or delta > 0; got nodeID=\" + nodeID + \" and delta=\" + delta;\n        writeBuffer.writeVLong(delta);\n      } else {\n        // The left tree's left most leaf block FP is always the minimal FP:\n        leftBlockFP = minBlockFP;\n      }\n\n      int address = nodeID * (1+bytesPerDim);\n      int splitDim = splitPackedValues[address++] & 0xff;\n\n      //System.out.println(\"recursePack inner nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      // find common prefix with last split value in this dim:\n      int prefix = FutureArrays.mismatch(splitPackedValues, address, address + bytesPerDim, lastSplitValues,\n          splitDim * bytesPerDim, splitDim * bytesPerDim + bytesPerDim);\n      if (prefix == -1) {\n        prefix = bytesPerDim;\n      }\n\n      //System.out.println(\"writeNodeData nodeID=\" + nodeID + \" splitDim=\" + splitDim + \" numDims=\" + numDims + \" bytesPerDim=\" + bytesPerDim + \" prefix=\" + prefix);\n\n      int firstDiffByteDelta;\n      if (prefix < bytesPerDim) {\n        //System.out.println(\"  delta byte cur=\" + Integer.toHexString(splitPackedValues[address+prefix]&0xFF) + \" prev=\" + Integer.toHexString(lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF) + \" negated?=\" + negativeDeltas[splitDim]);\n        firstDiffByteDelta = (splitPackedValues[address+prefix]&0xFF) - (lastSplitValues[splitDim * bytesPerDim + prefix]&0xFF);\n        if (negativeDeltas[splitDim]) {\n          firstDiffByteDelta = -firstDiffByteDelta;\n        }\n        //System.out.println(\"  delta=\" + firstDiffByteDelta);\n        assert firstDiffByteDelta > 0;\n      } else {\n        firstDiffByteDelta = 0;\n      }\n\n      // pack the prefix, splitDim and delta first diff byte into a single vInt:\n      int code = (firstDiffByteDelta * (1+bytesPerDim) + prefix) * numIndexDims + splitDim;\n\n      //System.out.println(\"  code=\" + code);\n      //System.out.println(\"  splitValue=\" + new BytesRef(splitPackedValues, address, bytesPerDim));\n\n      writeBuffer.writeVInt(code);\n\n      // write the split value, prefix coded vs. our parent's split value:\n      int suffix = bytesPerDim - prefix;\n      byte[] savSplitValue = new byte[suffix];\n      if (suffix > 1) {\n        writeBuffer.writeBytes(splitPackedValues, address+prefix+1, suffix-1);\n      }\n\n      byte[] cmp = lastSplitValues.clone();\n\n      System.arraycopy(lastSplitValues, splitDim * bytesPerDim + prefix, savSplitValue, 0, suffix);\n\n      // copy our split value into lastSplitValues for our children to prefix-code against\n      System.arraycopy(splitPackedValues, address+prefix, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      int numBytes = appendBlock(writeBuffer, blocks);\n\n      // placeholder for left-tree numBytes; we need this so that at search time if we only need to recurse into the right sub-tree we can\n      // quickly seek to its starting point\n      int idxSav = blocks.size();\n      blocks.add(null);\n\n      boolean savNegativeDelta = negativeDeltas[splitDim];\n      negativeDeltas[splitDim] = true;\n\n      int leftNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID, lastSplitValues, negativeDeltas, true);\n\n      if (nodeID * 2 < leafBlockFPs.length) {\n        writeBuffer.writeVInt(leftNumBytes);\n      } else {\n        assert leftNumBytes == 0: \"leftNumBytes=\" + leftNumBytes;\n      }\n      int numBytes2 = Math.toIntExact(writeBuffer.getFilePointer());\n      byte[] bytes2 = new byte[numBytes2];\n      writeBuffer.writeTo(bytes2, 0);\n      writeBuffer.reset();\n      // replace our placeholder:\n      blocks.set(idxSav, bytes2);\n\n      negativeDeltas[splitDim] = false;\n      int rightNumBytes = recursePackIndex(writeBuffer, leafBlockFPs, splitPackedValues, leftBlockFP, blocks, 2*nodeID+1, lastSplitValues, negativeDeltas, false);\n\n      negativeDeltas[splitDim] = savNegativeDelta;\n\n      // restore lastSplitValues to what caller originally passed us:\n      System.arraycopy(savSplitValue, 0, lastSplitValues, splitDim * bytesPerDim + prefix, suffix);\n\n      assert Arrays.equals(lastSplitValues, cmp);\n      \n      return numBytes + numBytes2 + leftNumBytes + rightNumBytes;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"68144b3b30df82b7233727bc4fb958ce52e5b483":["f6652c943595e92c187ee904c382863013eae28f"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["68144b3b30df82b7233727bc4fb958ce52e5b483"],"f6652c943595e92c187ee904c382863013eae28f":["9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"9856095f7afb5a607bf5e65077615ed91273508c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","9fc0d60683b47b5d922124c31f57c8b34734f9e6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["409da428f28953cf35fddd5c9ff5c7e4f5439863"]},"commit2Childs":{"9fc0d60683b47b5d922124c31f57c8b34734f9e6":["f6652c943595e92c187ee904c382863013eae28f","9856095f7afb5a607bf5e65077615ed91273508c"],"68144b3b30df82b7233727bc4fb958ce52e5b483":["409da428f28953cf35fddd5c9ff5c7e4f5439863"],"409da428f28953cf35fddd5c9ff5c7e4f5439863":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f6652c943595e92c187ee904c382863013eae28f":["68144b3b30df82b7233727bc4fb958ce52e5b483"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9fc0d60683b47b5d922124c31f57c8b34734f9e6","9856095f7afb5a607bf5e65077615ed91273508c"],"9856095f7afb5a607bf5e65077615ed91273508c":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["9856095f7afb5a607bf5e65077615ed91273508c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}