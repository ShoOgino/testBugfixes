{"path":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","commits":[{"id":"deea3439de4f487ae553317e50d5d641ca386374","date":1537522941,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"/dev/null","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1fec8b37cbb6884a64d39565e9dd7b4522a0598","date":1537699559,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"/dev/null","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea","date":1538045138,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          Overseer.getStateUpdateQueue(zkStateReader.getZkClient()).offer(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":["deea3439de4f487ae553317e50d5d641ca386374"],"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56","5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4949836c6e83246ddba8997472e3333f40986c8c","date":1560293762,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"86968c6cf51846df861b8f29bd85b6d9a7c9f19c","date":1591481497,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!Overseer.isLegacy(zkStateReader)) {\n      if (!skipCreateReplicaInClusterState) {\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n            ZkStateReader.COLLECTION_PROP, collectionName,\n            ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n            ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n            ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n            ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n            ZkStateReader.NODE_NAME_PROP, createReplica.node,\n            ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n        if (createReplica.coreNodeName != null) {\n          props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n        }\n        try {\n          ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n        } catch (Exception e) {\n          throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n        }\n      }\n      params.set(CoreAdminParams.CORE_NODE_NAME,\n          ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n    }\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","deea3439de4f487ae553317e50d5d641ca386374"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c526352db87264a72a7a9ad68c1b769b81e54305","date":1598780188,"type":5,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,CloudConfig,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, cloudConfig, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b17e79a71117668ecbf8d3417c876e41396565","date":1598973672,"type":1,"author":"Ilan Ginzburg","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/api/collections/AddReplicaCmd#getReplicaParams(ClusterState,CloudConfig,ZkNodeProps,NamedList,String,DocCollection,boolean,String,ShardHandler,CreateReplica).mjava","sourceNew":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","sourceOld":"  private ModifiableSolrParams getReplicaParams(ClusterState clusterState, CloudConfig cloudConfig, ZkNodeProps message, @SuppressWarnings({\"rawtypes\"})NamedList results, String collectionName, DocCollection coll, boolean skipCreateReplicaInClusterState, String asyncId, ShardHandler shardHandler, CreateReplica createReplica) throws IOException, InterruptedException, KeeperException {\n    if (coll.getStr(WITH_COLLECTION) != null) {\n      String withCollectionName = coll.getStr(WITH_COLLECTION);\n      DocCollection withCollection = clusterState.getCollection(withCollectionName);\n      if (withCollection.getActiveSlices().size() > 1)  {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"The `withCollection` must have only one shard, found: \" + withCollection.getActiveSlices().size());\n      }\n      String withCollectionShard = withCollection.getActiveSlices().iterator().next().getName();\n\n      List<Replica> replicas = withCollection.getReplicas(createReplica.node);\n      if (replicas == null || replicas.isEmpty()) {\n        // create a replica of withCollection on the identified node before proceeding further\n        ZkNodeProps props = new ZkNodeProps(\n            Overseer.QUEUE_OPERATION, ADDREPLICA.toString(),\n            ZkStateReader.COLLECTION_PROP, withCollectionName,\n            ZkStateReader.SHARD_ID_PROP, withCollectionShard,\n            \"node\", createReplica.node,\n            // since we already computed node assignments (which include assigning a node for this withCollection replica) we want to skip the assignment step\n            CollectionAdminParams.SKIP_NODE_ASSIGNMENT, \"true\",\n            CommonAdminParams.WAIT_FOR_FINAL_STATE, Boolean.TRUE.toString()); // set to true because we want `withCollection` to be ready after this collection is created\n        addReplica(clusterState, cloudConfig, props, results, null);\n      }\n    }\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    if (!skipCreateReplicaInClusterState) {\n      ZkNodeProps props = new ZkNodeProps(\n          Overseer.QUEUE_OPERATION, ADDREPLICA.toLower(),\n          ZkStateReader.COLLECTION_PROP, collectionName,\n          ZkStateReader.SHARD_ID_PROP, createReplica.sliceName,\n          ZkStateReader.CORE_NAME_PROP, createReplica.coreName,\n          ZkStateReader.STATE_PROP, Replica.State.DOWN.toString(),\n          ZkStateReader.BASE_URL_PROP, zkStateReader.getBaseUrlForNodeName(createReplica.node),\n          ZkStateReader.NODE_NAME_PROP, createReplica.node,\n          ZkStateReader.REPLICA_TYPE, createReplica.replicaType.name());\n      if (createReplica.coreNodeName != null) {\n        props = props.plus(ZkStateReader.CORE_NODE_NAME_PROP, createReplica.coreNodeName);\n      }\n      try {\n        ocmh.overseer.offerStateUpdate(Utils.toJSON(props));\n      } catch (Exception e) {\n        throw new SolrException(SolrException.ErrorCode.SERVER_ERROR, \"Exception updating Overseer state queue\", e);\n      }\n    }\n    params.set(CoreAdminParams.CORE_NODE_NAME,\n        ocmh.waitToSeeReplicasInState(collectionName, Collections.singletonList(createReplica.coreName)).get(createReplica.coreName).getName());\n\n    String configName = zkStateReader.readConfigName(collectionName);\n    String routeKey = message.getStr(ShardParams._ROUTE_);\n    String dataDir = message.getStr(CoreAdminParams.DATA_DIR);\n    String ulogDir = message.getStr(CoreAdminParams.ULOG_DIR);\n    String instanceDir = message.getStr(CoreAdminParams.INSTANCE_DIR);\n\n    params.set(CoreAdminParams.ACTION, CoreAdminParams.CoreAdminAction.CREATE.toString());\n    params.set(CoreAdminParams.NAME, createReplica.coreName);\n    params.set(COLL_CONF, configName);\n    params.set(CoreAdminParams.COLLECTION, collectionName);\n    params.set(CoreAdminParams.REPLICA_TYPE, createReplica.replicaType.name());\n    if (createReplica.sliceName != null) {\n      params.set(CoreAdminParams.SHARD, createReplica.sliceName);\n    } else if (routeKey != null) {\n      Collection<Slice> slices = coll.getRouter().getSearchSlicesSingle(routeKey, null, coll);\n      if (slices.isEmpty()) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"No active shard serving _route_=\" + routeKey + \" found\");\n      } else {\n        params.set(CoreAdminParams.SHARD, slices.iterator().next().getName());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Specify either 'shard' or _route_ param\");\n    }\n    if (dataDir != null) {\n      params.set(CoreAdminParams.DATA_DIR, dataDir);\n    }\n    if (ulogDir != null) {\n      params.set(CoreAdminParams.ULOG_DIR, ulogDir);\n    }\n    if (instanceDir != null) {\n      params.set(CoreAdminParams.INSTANCE_DIR, instanceDir);\n    }\n    if (createReplica.coreNodeName != null) {\n      params.set(CoreAdminParams.CORE_NODE_NAME, createReplica.coreNodeName);\n    }\n    ocmh.addPropertyParams(message, params);\n\n    return params;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e7b17e79a71117668ecbf8d3417c876e41396565":["c526352db87264a72a7a9ad68c1b769b81e54305"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["4949836c6e83246ddba8997472e3333f40986c8c"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","deea3439de4f487ae553317e50d5d641ca386374"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"deea3439de4f487ae553317e50d5d641ca386374":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"4949836c6e83246ddba8997472e3333f40986c8c":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e7b17e79a71117668ecbf8d3417c876e41396565"]},"commit2Childs":{"e7b17e79a71117668ecbf8d3417c876e41396565":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"c526352db87264a72a7a9ad68c1b769b81e54305":["e7b17e79a71117668ecbf8d3417c876e41396565"],"86968c6cf51846df861b8f29bd85b6d9a7c9f19c":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["4949836c6e83246ddba8997472e3333f40986c8c"],"e9f71a1c6c905e9489b4d25c83c8d628d978a8ea":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"f1fec8b37cbb6884a64d39565e9dd7b4522a0598":["e9f71a1c6c905e9489b4d25c83c8d628d978a8ea"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598","deea3439de4f487ae553317e50d5d641ca386374"],"deea3439de4f487ae553317e50d5d641ca386374":["f1fec8b37cbb6884a64d39565e9dd7b4522a0598"],"4949836c6e83246ddba8997472e3333f40986c8c":["86968c6cf51846df861b8f29bd85b6d9a7c9f19c"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["c526352db87264a72a7a9ad68c1b769b81e54305"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}