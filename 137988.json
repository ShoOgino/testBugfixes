{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7ab99e8c71442b92c320e218141dee04a9b91ce8","date":1269203801,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe8474c4e5a03f0ca187f99c062af83e092717f3","date":1269253267,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4b4e97a5e8ab5b96cc56c561131d720c756756b","date":1269362401,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n          synced.addAll(segmentInfos.files(directory, true));\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n\n        // We assume that this segments_N was previously\n        // properly sync'd:\n        synced.addAll(segmentInfos.files(directory, true));\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"955c32f886db6f6356c9fcdea6b1f1cb4effda24","date":1270581567,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9","date":1270985469,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10","date":1270996866,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":null,"bugIntro":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4","date":1271167458,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        boolean doCommit;\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n          doCommit = false;\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n          doCommit = true;\n        }\n\n        if (doCommit) {\n          // Only commit if there is no segments file in\n          // this dir already.\n          segmentInfos.commit(directory);\n        } else {\n          // Record that we have a change (zero out all\n          // segments) pending:\n          changeCount++;\n        }\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"bugIntro":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5e92e41f8d7626ca1ac96bc757f15ab985e6890","date":1274803503,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n    } catch (IOException e) {\n      writeLock.release();\n      writeLock = null;\n      throw e;\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"bugIntro":["0fcdcf196523675146a4df3193e91413533857ab","adde4ed7da03e734626803a3802e6cf88b77a2e7","076af493bb24818bc23f634456a5d89f6c1bd3fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b832cbed6eb3d54a8bb9339296bdda8eeb53014","date":1279708040,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf);\n      // nocommit\n      //docWriter.setInfoStream(infoStream);\n      //docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"334c1175813aea771a71728cd2c4ee4754fd0603","date":1279710173,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf);\n      // nocommit\n      //docWriter.setInfoStream(infoStream);\n      //docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fe956d65251358d755c56f14fe8380644790e47","date":1279711318,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf);\n      // nocommit\n      //docWriter.setInfoStream(infoStream);\n      //docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ef87af8c7bd0f8429622b83aa74202383f2e757","date":1280262785,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    this.readerPool = new IndexReaderPool(this, directory, config);\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf);\n      // nocommit\n      //docWriter.setInfoStream(infoStream);\n      //docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf);\n      // nocommit\n      //docWriter.setInfoStream(infoStream);\n      //docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9f84b05faae427842a2b42b53c66eb7ecfcf98c8","date":1286096876,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2100714e7e90fc106e6bbbbc39ede8bb8051ce97","date":1287828400,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b12d3e81e0f95a4527b5703953c503f71120ffcc","date":1288080933,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6","date":1288888250,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["2100714e7e90fc106e6bbbbc39ede8bb8051ce97","84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4e8cc373c801e54cec75daf9f52792cb4b17f536","date":1291116159,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["adde4ed7da03e734626803a3802e6cf88b77a2e7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"385cc8c7649bbc88df61ace8ef058a7b9376e95f","date":1291200406,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5947ccd7ba3770dcba5a0713dbd5496678256d9","date":1291744634,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8"],"bugIntro":["3af8c90c5e965a1a8011e827ab59de734c7dfb79"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","date":1291778725,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"44fcbde6fb2ac44ee3b45e013e54a42911e689ff","date":1292065621,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5","date":1292695408,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["f7719bda090a2ae5bab940a27ba7bb9054b29818"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos());\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    setMessageID(defaultInfoStream);\n    termIndexInterval = conf.getTermIndexInterval();\n    writeLockTimeout = conf.getWriteLockTimeout();\n    similarity = conf.getSimilarity();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    poolReaders = conf.getReaderPooling();\n\n    this.readerPool = new IndexReaderPool(this, directory, config);\n    \n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    if (create) {\n      // Clear the write lock in case it's leftover:\n      directory.clearLock(WRITE_LOCK_NAME);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(writeLockTimeout)) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf);\n      // nocommit\n      //docWriter.setInfoStream(infoStream);\n      //docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, docWriter, this.codecs);\n\n      if (deleter.startingCommitDeleted)\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n\n      docWriter.setMaxBufferedDeleteTerms(conf.getMaxBufferedDeleteTerms());\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c2047784e704fe141e0ff36affac8a7cb6c7bbec","date":1295352100,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e79a6d080bdd5b2a8f56342cf571b5476de04180","date":1295638686,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","date":1295759448,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["076af493bb24818bc23f634456a5d89f6c1bd3fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7235f072992928845d8cfd2dfc1c90362360e1e","date":1296426876,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    maxFieldLength = conf.getMaxFieldLength();\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // TODO: we should check whether this index is too old,\n    // and throw an IndexFormatTooOldExc up front, here,\n    // instead of later when merge, applyDeletes, getReader\n    // is attempted.  I think to do this we should store the\n    // oldest segment's version in segments_N.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n      docWriter.setMaxFieldLength(maxFieldLength);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0c7a8f7304b75b1528814c5820fa23a96816c27","date":1298314239,"type":3,"author":"Michael Busch","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      fieldInfos = getCurrentFieldInfos();\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(),\n          fieldInfos.newFieldInfosWithGlobalFieldNumberMap(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      fieldInfos = getCurrentFieldInfos();\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(),\n          fieldInfos.newFieldInfosWithGlobalFieldNumberMap(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initalized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletes = new BufferedDeletes(messageID);\n    bufferedDeletes.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(), getCurrentFieldInfos(), bufferedDeletes);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"14ec33385f6fbb6ce172882d14605790418a5d31","date":1298910796,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      fieldInfos = getCurrentFieldInfos();\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(),\n          fieldInfos.newFieldInfosWithGlobalFieldNumberMap(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"00b21520fafb9860ce0318d7be5ea84619c185ad","date":1300444600,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(config, directory, this, getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["4ce24aa081e44190692bbebc8aead342ad7060e8"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1224a4027481acce15495b03bce9b48b93b42722","date":1300792329,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(config, directory, this, getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e92442af786151ee55bc283eb472f629e3c7b52b","date":1301070252,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(SegmentCodecsBuilder.create(codecs)), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d619839baa8ce5503e496b94a9e42ad6f079293f","date":1301309428,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(SegmentCodecsBuilder.create(codecs)), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getMaxThreadStates(), getCurrentFieldInfos(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c0ef0193974807e4bddf5432a6b0287fe4d6c9df","date":1301476645,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is cloned and thus making\n   * changes to it after IndexWriter has been instantiated will not affect\n   * IndexWriter. Additionally, calling {@link #getConfig()} and changing the\n   * parameters does not affect that IndexWriter instance.\n   * <p>\n   * <b>NOTE:</b> by default, {@link IndexWriterConfig#getMaxFieldLength()}\n   * returns {@link IndexWriterConfig#UNLIMITED_FIELD_LENGTH}. Pay attention to\n   * whether this setting fits your application.\n   *\n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    termIndexInterval = conf.getTermIndexInterval();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    mergedSegmentWarmer = conf.getMergedSegmentWarmer();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      fieldInfos = getCurrentFieldInfos();\n      docWriter = new DocumentsWriter(directory, this, conf.getIndexingChain(), conf.getIndexerThreadPool(),\n          fieldInfos.newFieldInfosWithGlobalFieldNumberMap(), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      docWriter.setRAMBufferSizeMB(conf.getRAMBufferSizeMB());\n      docWriter.setMaxBufferedDocs(conf.getMaxBufferedDocs());\n      pushMaxBufferedDocs();\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b3e06be49006ecac364d39d12b9c9f74882f9b9f","date":1304289513,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(SegmentCodecsBuilder.create(codecs)), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(SegmentCodecsBuilder.create(codecs)), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"786a4d25ca958a1f315a9d6a74f0441fdafcd522","date":1305734256,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3a8a449466c1ff7ce2274fe73dab487256964b4","date":1305735867,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n    \n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      setRollbackSegmentInfos(segmentInfos);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, conf.getIndexingChain(),\n          globalFieldNumberMap.newFieldInfos(SegmentCodecsBuilder.create(codecs)), bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"adde4ed7da03e734626803a3802e6cf88b77a2e7","date":1312961672,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","c5e92e41f8d7626ca1ac96bc757f15ab985e6890","4e8cc373c801e54cec75daf9f52792cb4b17f536"],"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7719bda090a2ae5bab940a27ba7bb9054b29818","date":1315503197,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream,\n                                       codecs, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      deleter = new IndexFileDeleter(directory,\n                                     conf.getIndexDeletionPolicy(),\n                                     segmentInfos, infoStream, codecs);\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b91922b55d15444d554721b352861d028eb8278","date":1320421415,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codecs = conf.getCodecProvider();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos(codecs);\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory, codecs);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory, codecs);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos(codecs);\n          oldInfos.read(directory, commit.getSegmentsFileName(), codecs);\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream,\n                                       codecs, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1","076af493bb24818bc23f634456a5d89f6c1bd3fc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"06584e6e98d592b34e1329b384182f368d2025e8","date":1320850353,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = defaultInfoStream;\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(messageID);\n    bufferedDeletesStream.setInfoStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            message(\"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n      docWriter.setInfoStream(infoStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        message(\"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          message(\"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"319624eb66a10b717d3e66af448543e7dc5c479d","date":1322741556,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap(directory);\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58c6bbc222f074c844e736e6fb23647e3db9cfe3","date":1322743940,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\"))\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream != null)\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream != null) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream != null) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\"))\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\"))\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"076af493bb24818bc23f634456a5d89f6c1bd3fc","date":1324575384,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !IndexReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    OpenMode mode = conf.getOpenMode();\n    boolean create;\n    if (mode == OpenMode.CREATE) {\n      create = true;\n    } else if (mode == OpenMode.APPEND) {\n      create = false;\n    } else {\n      // CREATE_OR_APPEND - create only if an index does not exist\n      create = !IndexReader.indexExists(directory);\n    }\n    boolean success = false;\n\n    // If index is too old, reading the segments will throw\n    // IndexFormatTooOldException.\n    segmentInfos = new SegmentInfos();\n    try {\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":["84080a7d7dbdaa3e6a4a1c9f1bb6221be40f47e8","7b91922b55d15444d554721b352861d028eb8278","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6","c5e92e41f8d7626ca1ac96bc757f15ab985e6890"],"bugIntro":["0791b41f65aecff2e75db0c1ebf95d745a5ab1b1"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"893d07555f01912f57b453a320e4d46363a31b50","date":1327312526,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !IndexReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5cab9a86bd67202d20b6adc463008c8e982b070a","date":1327966443,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !IndexReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#IndexWriter(Directory,IndexWriterConfig).mjava","sourceNew":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Constructs a new IndexWriter per the settings given in <code>conf</code>.\n   * Note that the passed in {@link IndexWriterConfig} is\n   * privately cloned; if you need to make subsequent \"live\"\n   * changes to the configuration use {@link #getConfig}.\n   * <p>\n   * \n   * @param d\n   *          the index directory. The index is either created or appended\n   *          according <code>conf.getOpenMode()</code>.\n   * @param conf\n   *          the configuration settings according to which IndexWriter should\n   *          be initialized.\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws LockObtainFailedException\n   *           if another writer has this index open (<code>write.lock</code>\n   *           could not be obtained)\n   * @throws IOException\n   *           if the directory cannot be read/written to, or if it does not\n   *           exist and <code>conf.getOpenMode()</code> is\n   *           <code>OpenMode.APPEND</code> or if there is any other low-level\n   *           IO error\n   */\n  public IndexWriter(Directory d, IndexWriterConfig conf)\n      throws CorruptIndexException, LockObtainFailedException, IOException {\n    config = (IndexWriterConfig) conf.clone();\n    directory = d;\n    analyzer = conf.getAnalyzer();\n    infoStream = conf.getInfoStream();\n    mergePolicy = conf.getMergePolicy();\n    mergePolicy.setIndexWriter(this);\n    mergeScheduler = conf.getMergeScheduler();\n    codec = conf.getCodec();\n\n    bufferedDeletesStream = new BufferedDeletesStream(infoStream);\n    poolReaders = conf.getReaderPooling();\n\n    writeLock = directory.makeLock(WRITE_LOCK_NAME);\n\n    if (!writeLock.obtain(conf.getWriteLockTimeout())) // obtain write lock\n      throw new LockObtainFailedException(\"Index locked for write: \" + writeLock);\n\n    boolean success = false;\n    try {\n      OpenMode mode = conf.getOpenMode();\n      boolean create;\n      if (mode == OpenMode.CREATE) {\n        create = true;\n      } else if (mode == OpenMode.APPEND) {\n        create = false;\n      } else {\n        // CREATE_OR_APPEND - create only if an index does not exist\n        create = !DirectoryReader.indexExists(directory);\n      }\n\n      // If index is too old, reading the segments will throw\n      // IndexFormatTooOldException.\n      segmentInfos = new SegmentInfos();\n\n      if (create) {\n        // Try to read first.  This is to allow create\n        // against an index that's currently open for\n        // searching.  In this case we write the next\n        // segments_N file with no segments:\n        try {\n          segmentInfos.read(directory);\n          segmentInfos.clear();\n        } catch (IOException e) {\n          // Likely this means it's a fresh directory\n        }\n\n        // Record that we have a change (zero out all\n        // segments) pending:\n        changeCount++;\n        segmentInfos.changed();\n      } else {\n        segmentInfos.read(directory);\n\n        IndexCommit commit = conf.getIndexCommit();\n        if (commit != null) {\n          // Swap out all segments, but, keep metadata in\n          // SegmentInfos, like version & generation, to\n          // preserve write-once.  This is important if\n          // readers are open against the future commit\n          // points.\n          if (commit.getDirectory() != directory)\n            throw new IllegalArgumentException(\"IndexCommit's directory doesn't match my directory\");\n          SegmentInfos oldInfos = new SegmentInfos();\n          oldInfos.read(directory, commit.getSegmentsFileName());\n          segmentInfos.replace(oldInfos);\n          changeCount++;\n          segmentInfos.changed();\n          if (infoStream.isEnabled(\"IW\")) {\n            infoStream.message(\"IW\", \"init: loaded commit \\\"\" + commit.getSegmentsFileName() + \"\\\"\");\n          }\n        }\n      }\n\n      rollbackSegments = segmentInfos.createBackupSegmentInfos(true);\n\n      // start with previous field numbers, but new FieldInfos\n      globalFieldNumberMap = segmentInfos.getOrLoadGlobalFieldNumberMap();\n      docWriter = new DocumentsWriter(codec, config, directory, this, globalFieldNumberMap, bufferedDeletesStream);\n\n      // Default deleter (for backwards compatibility) is\n      // KeepOnlyLastCommitDeleter:\n      synchronized(this) {\n        deleter = new IndexFileDeleter(directory,\n                                       conf.getIndexDeletionPolicy(),\n                                       segmentInfos, infoStream, this);\n      }\n\n      if (deleter.startingCommitDeleted) {\n        // Deletion policy deleted the \"head\" commit point.\n        // We have to mark ourself as changed so that if we\n        // are closed w/o any further changes we write a new\n        // segments_N file.\n        changeCount++;\n        segmentInfos.changed();\n      }\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"init: create=\" + create);\n        messageState();\n      }\n\n      success = true;\n\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"init: hit exception on init; releasing write lock\");\n        }\n        try {\n          writeLock.release();\n        } catch (Throwable t) {\n          // don't mask the original exception\n        }\n        writeLock = null;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["c5947ccd7ba3770dcba5a0713dbd5496678256d9"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5ef87af8c7bd0f8429622b83aa74202383f2e757","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"c19f985e36a65cc969e8e564fe337a0d41512075":["b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"385cc8c7649bbc88df61ace8ef058a7b9376e95f":["4e8cc373c801e54cec75daf9f52792cb4b17f536"],"14ec33385f6fbb6ce172882d14605790418a5d31":["b0c7a8f7304b75b1528814c5820fa23a96816c27"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["3bb13258feba31ab676502787ab2e1779f129b7a"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","c7235f072992928845d8cfd2dfc1c90362360e1e"],"076af493bb24818bc23f634456a5d89f6c1bd3fc":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"893d07555f01912f57b453a320e4d46363a31b50":["076af493bb24818bc23f634456a5d89f6c1bd3fc"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"adde4ed7da03e734626803a3802e6cf88b77a2e7":["786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"c5947ccd7ba3770dcba5a0713dbd5496678256d9":["385cc8c7649bbc88df61ace8ef058a7b9376e95f"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"06584e6e98d592b34e1329b384182f368d2025e8":["7b91922b55d15444d554721b352861d028eb8278"],"00b21520fafb9860ce0318d7be5ea84619c185ad":["14ec33385f6fbb6ce172882d14605790418a5d31"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["c5e92e41f8d7626ca1ac96bc757f15ab985e6890"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c2047784e704fe141e0ff36affac8a7cb6c7bbec"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["29ef99d61cda9641b6250bf9567329a6e65f901d","e92442af786151ee55bc283eb472f629e3c7b52b"],"a3776dccca01c11e7046323cfad46a3b4a471233":["e92442af786151ee55bc283eb472f629e3c7b52b","786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6":["2100714e7e90fc106e6bbbbc39ede8bb8051ce97"],"e4b4e97a5e8ab5b96cc56c561131d720c756756b":["fe8474c4e5a03f0ca187f99c062af83e092717f3"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["319624eb66a10b717d3e66af448543e7dc5c479d"],"2100714e7e90fc106e6bbbbc39ede8bb8051ce97":["9f84b05faae427842a2b42b53c66eb7ecfcf98c8"],"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["58c6bbc222f074c844e736e6fb23647e3db9cfe3","c5df35ab57c223ea11aec64b53bf611904f3dced"],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["e4b4e97a5e8ab5b96cc56c561131d720c756756b"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["e79a6d080bdd5b2a8f56342cf571b5476de04180","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"e92442af786151ee55bc283eb472f629e3c7b52b":["1224a4027481acce15495b03bce9b48b93b42722"],"c2047784e704fe141e0ff36affac8a7cb6c7bbec":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["bde51b089eb7f86171eb3406e38a274743f9b7ac","e92442af786151ee55bc283eb472f629e3c7b52b"],"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"9f84b05faae427842a2b42b53c66eb7ecfcf98c8":["334c1175813aea771a71728cd2c4ee4754fd0603"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5ef87af8c7bd0f8429622b83aa74202383f2e757":["8fe956d65251358d755c56f14fe8380644790e47"],"319624eb66a10b717d3e66af448543e7dc5c479d":["06584e6e98d592b34e1329b384182f368d2025e8"],"c5e92e41f8d7626ca1ac96bc757f15ab985e6890":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"1224a4027481acce15495b03bce9b48b93b42722":["00b21520fafb9860ce0318d7be5ea84619c185ad"],"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["c2047784e704fe141e0ff36affac8a7cb6c7bbec"],"fe8474c4e5a03f0ca187f99c062af83e092717f3":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"85a883878c0af761245ab048babc63d099f835f3":["b12d3e81e0f95a4527b5703953c503f71120ffcc","2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["d619839baa8ce5503e496b94a9e42ad6f079293f","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["e92442af786151ee55bc283eb472f629e3c7b52b","c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["9f84b05faae427842a2b42b53c66eb7ecfcf98c8","2100714e7e90fc106e6bbbbc39ede8bb8051ce97"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b","4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"334c1175813aea771a71728cd2c4ee4754fd0603":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["076af493bb24818bc23f634456a5d89f6c1bd3fc","893d07555f01912f57b453a320e4d46363a31b50"],"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10":["b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9"],"7b91922b55d15444d554721b352861d028eb8278":["f7719bda090a2ae5bab940a27ba7bb9054b29818"],"f7719bda090a2ae5bab940a27ba7bb9054b29818":["adde4ed7da03e734626803a3802e6cf88b77a2e7"],"786a4d25ca958a1f315a9d6a74f0441fdafcd522":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":["135621f3a0670a9394eb563224a3b76cc4dddc0f","786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["c7235f072992928845d8cfd2dfc1c90362360e1e"],"8fe956d65251358d755c56f14fe8380644790e47":["c5e92e41f8d7626ca1ac96bc757f15ab985e6890"],"c7235f072992928845d8cfd2dfc1c90362360e1e":["c19f985e36a65cc969e8e564fe337a0d41512075"],"3bb13258feba31ab676502787ab2e1779f129b7a":["85a883878c0af761245ab048babc63d099f835f3","385cc8c7649bbc88df61ace8ef058a7b9376e95f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4e8cc373c801e54cec75daf9f52792cb4b17f536":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["076af493bb24818bc23f634456a5d89f6c1bd3fc","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"44fcbde6fb2ac44ee3b45e013e54a42911e689ff":["4948bc5d29211f0c9b5ccc31b2632cdd27066ea5"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["e79a6d080bdd5b2a8f56342cf571b5476de04180"],"c19f985e36a65cc969e8e564fe337a0d41512075":["c7235f072992928845d8cfd2dfc1c90362360e1e"],"385cc8c7649bbc88df61ace8ef058a7b9376e95f":["c5947ccd7ba3770dcba5a0713dbd5496678256d9","3bb13258feba31ab676502787ab2e1779f129b7a"],"14ec33385f6fbb6ce172882d14605790418a5d31":["00b21520fafb9860ce0318d7be5ea84619c185ad"],"4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["d619839baa8ce5503e496b94a9e42ad6f079293f"],"076af493bb24818bc23f634456a5d89f6c1bd3fc":["893d07555f01912f57b453a320e4d46363a31b50","5cab9a86bd67202d20b6adc463008c8e982b070a"],"893d07555f01912f57b453a320e4d46363a31b50":["5cab9a86bd67202d20b6adc463008c8e982b070a"],"4948bc5d29211f0c9b5ccc31b2632cdd27066ea5":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c2047784e704fe141e0ff36affac8a7cb6c7bbec","ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["c0ef0193974807e4bddf5432a6b0287fe4d6c9df"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7ab99e8c71442b92c320e218141dee04a9b91ce8"],"c5947ccd7ba3770dcba5a0713dbd5496678256d9":["44fcbde6fb2ac44ee3b45e013e54a42911e689ff"],"adde4ed7da03e734626803a3802e6cf88b77a2e7":["f7719bda090a2ae5bab940a27ba7bb9054b29818"],"7ab99e8c71442b92c320e218141dee04a9b91ce8":["fe8474c4e5a03f0ca187f99c062af83e092717f3"],"06584e6e98d592b34e1329b384182f368d2025e8":["319624eb66a10b717d3e66af448543e7dc5c479d"],"00b21520fafb9860ce0318d7be5ea84619c185ad":["1224a4027481acce15495b03bce9b48b93b42722"],"9b832cbed6eb3d54a8bb9339296bdda8eeb53014":["334c1175813aea771a71728cd2c4ee4754fd0603"],"e79a6d080bdd5b2a8f56342cf571b5476de04180":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"d619839baa8ce5503e496b94a9e42ad6f079293f":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6":["85a883878c0af761245ab048babc63d099f835f3","4e8cc373c801e54cec75daf9f52792cb4b17f536"],"e4b4e97a5e8ab5b96cc56c561131d720c756756b":["955c32f886db6f6356c9fcdea6b1f1cb4effda24"],"58c6bbc222f074c844e736e6fb23647e3db9cfe3":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"2100714e7e90fc106e6bbbbc39ede8bb8051ce97":["2248ea99d1f1e5ae6d67d1547acfe3e29576b8a6","b12d3e81e0f95a4527b5703953c503f71120ffcc"],"b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9":["d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"955c32f886db6f6356c9fcdea6b1f1cb4effda24":["b48e4082e2f39f1eb6f935ea9a1203c5e8d830a9"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"c2047784e704fe141e0ff36affac8a7cb6c7bbec":["e79a6d080bdd5b2a8f56342cf571b5476de04180","b9dc373b96fc96e6300e2f5af947f6998e6aa6a6"],"e92442af786151ee55bc283eb472f629e3c7b52b":["d619839baa8ce5503e496b94a9e42ad6f079293f","a3776dccca01c11e7046323cfad46a3b4a471233","c0ef0193974807e4bddf5432a6b0287fe4d6c9df","b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"c0ef0193974807e4bddf5432a6b0287fe4d6c9df":["b3e06be49006ecac364d39d12b9c9f74882f9b9f"],"69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4":["c5e92e41f8d7626ca1ac96bc757f15ab985e6890"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9f84b05faae427842a2b42b53c66eb7ecfcf98c8":["2100714e7e90fc106e6bbbbc39ede8bb8051ce97","b12d3e81e0f95a4527b5703953c503f71120ffcc"],"5ef87af8c7bd0f8429622b83aa74202383f2e757":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"319624eb66a10b717d3e66af448543e7dc5c479d":["58c6bbc222f074c844e736e6fb23647e3db9cfe3"],"c5e92e41f8d7626ca1ac96bc757f15ab985e6890":["9b832cbed6eb3d54a8bb9339296bdda8eeb53014","8fe956d65251358d755c56f14fe8380644790e47"],"1224a4027481acce15495b03bce9b48b93b42722":["e92442af786151ee55bc283eb472f629e3c7b52b"],"b9dc373b96fc96e6300e2f5af947f6998e6aa6a6":["c19f985e36a65cc969e8e564fe337a0d41512075","bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"fe8474c4e5a03f0ca187f99c062af83e092717f3":["e4b4e97a5e8ab5b96cc56c561131d720c756756b"],"85a883878c0af761245ab048babc63d099f835f3":["3bb13258feba31ab676502787ab2e1779f129b7a"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c3a8a449466c1ff7ce2274fe73dab487256964b4"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"b12d3e81e0f95a4527b5703953c503f71120ffcc":["85a883878c0af761245ab048babc63d099f835f3"],"b3e06be49006ecac364d39d12b9c9f74882f9b9f":["135621f3a0670a9394eb563224a3b76cc4dddc0f","786a4d25ca958a1f315a9d6a74f0441fdafcd522"],"334c1175813aea771a71728cd2c4ee4754fd0603":["9f84b05faae427842a2b42b53c66eb7ecfcf98c8"],"5cab9a86bd67202d20b6adc463008c8e982b070a":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"d8d3f45cdd3ff689aaf7a3aab99e2df31305ac10":["69a923a22517eb7ff0bad9c6d1a7d45cc0696bd4"],"7b91922b55d15444d554721b352861d028eb8278":["06584e6e98d592b34e1329b384182f368d2025e8"],"786a4d25ca958a1f315a9d6a74f0441fdafcd522":["adde4ed7da03e734626803a3802e6cf88b77a2e7","a3776dccca01c11e7046323cfad46a3b4a471233","c3a8a449466c1ff7ce2274fe73dab487256964b4"],"f7719bda090a2ae5bab940a27ba7bb9054b29818":["7b91922b55d15444d554721b352861d028eb8278"],"c3a8a449466c1ff7ce2274fe73dab487256964b4":[],"b0c7a8f7304b75b1528814c5820fa23a96816c27":["14ec33385f6fbb6ce172882d14605790418a5d31","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"8fe956d65251358d755c56f14fe8380644790e47":["5ef87af8c7bd0f8429622b83aa74202383f2e757"],"c7235f072992928845d8cfd2dfc1c90362360e1e":["29ef99d61cda9641b6250bf9567329a6e65f901d","b0c7a8f7304b75b1528814c5820fa23a96816c27"],"3bb13258feba31ab676502787ab2e1779f129b7a":["4bd5d0a5ac72666f0bcbd50b535d2cc70dbf584b"],"4e8cc373c801e54cec75daf9f52792cb4b17f536":["385cc8c7649bbc88df61ace8ef058a7b9376e95f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a3776dccca01c11e7046323cfad46a3b4a471233","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","c3a8a449466c1ff7ce2274fe73dab487256964b4","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}