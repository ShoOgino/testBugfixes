{"path":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#[TO-extends-Throwable,TW-extends-Throwable]_expectThrowsAnyOf(LinkedHashMap[Class[#-extends-TO],List[Class[#-extends-TW]]],ThrowingRunnable).mjava","commits":[{"id":"3def6097490d483908343e95c16631f2580e2489","date":1533005389,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#[TO-extends-Throwable,TW-extends-Throwable]_expectThrowsAnyOf(LinkedHashMap[Class[#-extends-TO],List[Class[#-extends-TW]]],ThrowingRunnable).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Checks that one of the specified wrapped and outer exception classes are thrown\n   * by the given runnable, and returns the outer exception.\n   * \n   * This method accepts outer exceptions with no wrapped exception;\n   * an empty list of expected wrapped exception types indicates no wrapped exception.\n   */\n  public static <TO extends Throwable, TW extends Throwable> TO expectThrowsAnyOf\n  (LinkedHashMap<Class<? extends TO>,List<Class<? extends TW>>> expectedOuterToWrappedTypes, ThrowingRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Throwable e) {\n      for (Map.Entry<Class<? extends TO>, List<Class<? extends TW>>> entry : expectedOuterToWrappedTypes.entrySet()) {\n        Class<? extends TO> expectedOuterType = entry.getKey();\n        List<Class<? extends TW>> expectedWrappedTypes = entry.getValue();\n        Throwable cause = e.getCause();\n        if (expectedOuterType.isInstance(e)) {\n          if (expectedWrappedTypes.isEmpty()) {\n            return null; // no wrapped exception\n          } else {\n            for (Class<? extends TW> expectedWrappedType : expectedWrappedTypes) {\n              if (expectedWrappedType.isInstance(cause)) {\n                return expectedOuterType.cast(e);\n              }\n            }\n            List<String> wrappedTypes = expectedWrappedTypes.stream().map(Class::getSimpleName).collect(Collectors.toList());\n            AssertionFailedError assertion = new AssertionFailedError\n                (\"Unexpected wrapped exception type, expected one of \" + wrappedTypes + \" but got: \" + cause);\n            assertion.initCause(e);\n            throw assertion;\n          }\n        }\n      }\n      List<String> outerTypes = expectedOuterToWrappedTypes.keySet().stream().map(Class::getSimpleName).collect(Collectors.toList());\n      AssertionFailedError assertion = new AssertionFailedError\n          (\"Unexpected outer exception type, expected one of \" + outerTypes + \" but got: \" + e);\n      assertion.initCause(e);\n      throw assertion;\n    }\n    List<String> outerTypes = expectedOuterToWrappedTypes.keySet().stream().map(Class::getSimpleName).collect(Collectors.toList());\n    throw new AssertionFailedError(\"Expected any of the following outer exception types: \" + outerTypes\n        + \" but no exception was thrown.\");\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d592ac9e6400869a47757802651c715b4e88219","date":1570470117,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#[TO-extends-Throwable,TW-extends-Throwable]_expectThrowsAnyOf(LinkedHashMap[Class[#-extends-TO],List[Class[#-extends-TW]]],ThrowingRunnable).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#[TO-extends-Throwable,TW-extends-Throwable]_expectThrowsAnyOf(LinkedHashMap[Class[#-extends-TO],List[Class[#-extends-TW]]],ThrowingRunnable).mjava","sourceNew":"  /**\n   * Checks that one of the specified wrapped and outer exception classes are thrown\n   * by the given runnable, and returns the outer exception.\n   * \n   * This method accepts outer exceptions with no wrapped exception;\n   * an empty list of expected wrapped exception types indicates no wrapped exception.\n   */\n  public static <TO extends Throwable, TW extends Throwable> TO expectThrowsAnyOf\n  (LinkedHashMap<Class<? extends TO>,List<Class<? extends TW>>> expectedOuterToWrappedTypes, ThrowingRunnable runnable) {\n    final List<Class<? extends TO>> outerClasses = expectedOuterToWrappedTypes.keySet().stream().collect(Collectors.toList());\n    final Throwable thrown = _expectThrows(outerClasses, runnable);\n    \n    if (null == thrown) {\n      List<String> outerTypes = outerClasses.stream().map(Class::getSimpleName).collect(Collectors.toList());\n      throw new AssertionFailedError(\"Expected any of the following outer exception types: \" + outerTypes\n                                     + \" but no exception was thrown.\");\n    }\n    for (Map.Entry<Class<? extends TO>, List<Class<? extends TW>>> entry : expectedOuterToWrappedTypes.entrySet()) {\n      Class<? extends TO> expectedOuterType = entry.getKey();\n      List<Class<? extends TW>> expectedWrappedTypes = entry.getValue();\n      Throwable cause = thrown.getCause();\n      if (expectedOuterType.isInstance(thrown)) {\n        if (expectedWrappedTypes.isEmpty()) {\n          return null; // no wrapped exception\n        } else {\n          for (Class<? extends TW> expectedWrappedType : expectedWrappedTypes) {\n            if (expectedWrappedType.isInstance(cause)) {\n              return expectedOuterType.cast(thrown);\n            }\n          }\n          List<String> wrappedTypes = expectedWrappedTypes.stream().map(Class::getSimpleName).collect(Collectors.toList());\n          AssertionFailedError assertion = new AssertionFailedError\n            (\"Unexpected wrapped exception type, expected one of \" + wrappedTypes + \" but got: \" + cause);\n          assertion.initCause(thrown);\n          throw assertion;\n        }\n      }\n    }\n    List<String> outerTypes = outerClasses.stream().map(Class::getSimpleName).collect(Collectors.toList());\n    AssertionFailedError assertion = new AssertionFailedError\n      (\"Unexpected outer exception type, expected one of \" + outerTypes + \" but got: \" + thrown);\n    assertion.initCause(thrown);\n    throw assertion;\n  }\n\n","sourceOld":"  /**\n   * Checks that one of the specified wrapped and outer exception classes are thrown\n   * by the given runnable, and returns the outer exception.\n   * \n   * This method accepts outer exceptions with no wrapped exception;\n   * an empty list of expected wrapped exception types indicates no wrapped exception.\n   */\n  public static <TO extends Throwable, TW extends Throwable> TO expectThrowsAnyOf\n  (LinkedHashMap<Class<? extends TO>,List<Class<? extends TW>>> expectedOuterToWrappedTypes, ThrowingRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Throwable e) {\n      for (Map.Entry<Class<? extends TO>, List<Class<? extends TW>>> entry : expectedOuterToWrappedTypes.entrySet()) {\n        Class<? extends TO> expectedOuterType = entry.getKey();\n        List<Class<? extends TW>> expectedWrappedTypes = entry.getValue();\n        Throwable cause = e.getCause();\n        if (expectedOuterType.isInstance(e)) {\n          if (expectedWrappedTypes.isEmpty()) {\n            return null; // no wrapped exception\n          } else {\n            for (Class<? extends TW> expectedWrappedType : expectedWrappedTypes) {\n              if (expectedWrappedType.isInstance(cause)) {\n                return expectedOuterType.cast(e);\n              }\n            }\n            List<String> wrappedTypes = expectedWrappedTypes.stream().map(Class::getSimpleName).collect(Collectors.toList());\n            AssertionFailedError assertion = new AssertionFailedError\n                (\"Unexpected wrapped exception type, expected one of \" + wrappedTypes + \" but got: \" + cause);\n            assertion.initCause(e);\n            throw assertion;\n          }\n        }\n      }\n      List<String> outerTypes = expectedOuterToWrappedTypes.keySet().stream().map(Class::getSimpleName).collect(Collectors.toList());\n      AssertionFailedError assertion = new AssertionFailedError\n          (\"Unexpected outer exception type, expected one of \" + outerTypes + \" but got: \" + e);\n      assertion.initCause(e);\n      throw assertion;\n    }\n    List<String> outerTypes = expectedOuterToWrappedTypes.keySet().stream().map(Class::getSimpleName).collect(Collectors.toList());\n    throw new AssertionFailedError(\"Expected any of the following outer exception types: \" + outerTypes\n        + \" but no exception was thrown.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#[TO-extends-Throwable,TW-extends-Throwable]_expectThrowsAnyOf(LinkedHashMap[Class[#-extends-TO],List[Class[#-extends-TW]]],ThrowingRunnable).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/util/LuceneTestCase#[TO-extends-Throwable,TW-extends-Throwable]_expectThrowsAnyOf(LinkedHashMap[Class[#-extends-TO],List[Class[#-extends-TW]]],ThrowingRunnable).mjava","sourceNew":"  /**\n   * Checks that one of the specified wrapped and outer exception classes are thrown\n   * by the given runnable, and returns the outer exception.\n   * \n   * This method accepts outer exceptions with no wrapped exception;\n   * an empty list of expected wrapped exception types indicates no wrapped exception.\n   */\n  public static <TO extends Throwable, TW extends Throwable> TO expectThrowsAnyOf\n  (LinkedHashMap<Class<? extends TO>,List<Class<? extends TW>>> expectedOuterToWrappedTypes, ThrowingRunnable runnable) {\n    final List<Class<? extends TO>> outerClasses = expectedOuterToWrappedTypes.keySet().stream().collect(Collectors.toList());\n    final Throwable thrown = _expectThrows(outerClasses, runnable);\n    \n    if (null == thrown) {\n      List<String> outerTypes = outerClasses.stream().map(Class::getSimpleName).collect(Collectors.toList());\n      throw new AssertionFailedError(\"Expected any of the following outer exception types: \" + outerTypes\n                                     + \" but no exception was thrown.\");\n    }\n    for (Map.Entry<Class<? extends TO>, List<Class<? extends TW>>> entry : expectedOuterToWrappedTypes.entrySet()) {\n      Class<? extends TO> expectedOuterType = entry.getKey();\n      List<Class<? extends TW>> expectedWrappedTypes = entry.getValue();\n      Throwable cause = thrown.getCause();\n      if (expectedOuterType.isInstance(thrown)) {\n        if (expectedWrappedTypes.isEmpty()) {\n          return null; // no wrapped exception\n        } else {\n          for (Class<? extends TW> expectedWrappedType : expectedWrappedTypes) {\n            if (expectedWrappedType.isInstance(cause)) {\n              return expectedOuterType.cast(thrown);\n            }\n          }\n          List<String> wrappedTypes = expectedWrappedTypes.stream().map(Class::getSimpleName).collect(Collectors.toList());\n          AssertionFailedError assertion = new AssertionFailedError\n            (\"Unexpected wrapped exception type, expected one of \" + wrappedTypes + \" but got: \" + cause);\n          assertion.initCause(thrown);\n          throw assertion;\n        }\n      }\n    }\n    List<String> outerTypes = outerClasses.stream().map(Class::getSimpleName).collect(Collectors.toList());\n    AssertionFailedError assertion = new AssertionFailedError\n      (\"Unexpected outer exception type, expected one of \" + outerTypes + \" but got: \" + thrown);\n    assertion.initCause(thrown);\n    throw assertion;\n  }\n\n","sourceOld":"  /**\n   * Checks that one of the specified wrapped and outer exception classes are thrown\n   * by the given runnable, and returns the outer exception.\n   * \n   * This method accepts outer exceptions with no wrapped exception;\n   * an empty list of expected wrapped exception types indicates no wrapped exception.\n   */\n  public static <TO extends Throwable, TW extends Throwable> TO expectThrowsAnyOf\n  (LinkedHashMap<Class<? extends TO>,List<Class<? extends TW>>> expectedOuterToWrappedTypes, ThrowingRunnable runnable) {\n    try {\n      runnable.run();\n    } catch (Throwable e) {\n      for (Map.Entry<Class<? extends TO>, List<Class<? extends TW>>> entry : expectedOuterToWrappedTypes.entrySet()) {\n        Class<? extends TO> expectedOuterType = entry.getKey();\n        List<Class<? extends TW>> expectedWrappedTypes = entry.getValue();\n        Throwable cause = e.getCause();\n        if (expectedOuterType.isInstance(e)) {\n          if (expectedWrappedTypes.isEmpty()) {\n            return null; // no wrapped exception\n          } else {\n            for (Class<? extends TW> expectedWrappedType : expectedWrappedTypes) {\n              if (expectedWrappedType.isInstance(cause)) {\n                return expectedOuterType.cast(e);\n              }\n            }\n            List<String> wrappedTypes = expectedWrappedTypes.stream().map(Class::getSimpleName).collect(Collectors.toList());\n            AssertionFailedError assertion = new AssertionFailedError\n                (\"Unexpected wrapped exception type, expected one of \" + wrappedTypes + \" but got: \" + cause);\n            assertion.initCause(e);\n            throw assertion;\n          }\n        }\n      }\n      List<String> outerTypes = expectedOuterToWrappedTypes.keySet().stream().map(Class::getSimpleName).collect(Collectors.toList());\n      AssertionFailedError assertion = new AssertionFailedError\n          (\"Unexpected outer exception type, expected one of \" + outerTypes + \" but got: \" + e);\n      assertion.initCause(e);\n      throw assertion;\n    }\n    List<String> outerTypes = expectedOuterToWrappedTypes.keySet().stream().map(Class::getSimpleName).collect(Collectors.toList());\n    throw new AssertionFailedError(\"Expected any of the following outer exception types: \" + outerTypes\n        + \" but no exception was thrown.\");\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8d592ac9e6400869a47757802651c715b4e88219":["3def6097490d483908343e95c16631f2580e2489"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8d592ac9e6400869a47757802651c715b4e88219"],"3def6097490d483908343e95c16631f2580e2489":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b0b597c65628ca9e73913a07e81691f8229bae35":["3def6097490d483908343e95c16631f2580e2489","8d592ac9e6400869a47757802651c715b4e88219"]},"commit2Childs":{"8d592ac9e6400869a47757802651c715b4e88219":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3def6097490d483908343e95c16631f2580e2489"],"3def6097490d483908343e95c16631f2580e2489":["8d592ac9e6400869a47757802651c715b4e88219","b0b597c65628ca9e73913a07e81691f8229bae35"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}