{"path":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","commits":[{"id":"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76","date":1204055227,"type":0,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(\"ids\");\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList();\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(\"isShard\",false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["d72e3710bede9618eb9b2b5c6936369f3d3f9579","c3da65606b2cf2b2357063f779126d1521733034"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da0acfe5ceed804451d76c8f887855b3d060e132","date":1208287358,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(\"ids\");\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(\"isShard\",false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(\"ids\");\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList();\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(\"isShard\",false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c","date":1208435858,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(\"ids\");\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.size());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(\"isShard\",false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(\"ids\");\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(\"isShard\",false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":["03ddf64cbf9c9db0ae0594799381bba32114f682"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a6c6e4e06160d2ad231072e8743988a623ab14c9","date":1213500516,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.size());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(\"ids\");\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.size());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(\"isShard\",false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db25c1f61b5ae826f10777da6551a832703967d5","date":1215306972,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.size());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    if( rb.isNeedDocSet() ) {\n      rb.setResults( searcher.getDocListAndSet(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() ) );\n    }\n    else {\n      DocListAndSet results = new DocListAndSet();\n      results.docList = searcher.getDocList(\n          rb.getQuery(), rb.getFilters(), rb.getSortSpec().getSort(),\n          rb.getSortSpec().getOffset(), rb.getSortSpec().getCount(),\n          rb.getFieldFlags() );\n      rb.setResults( results );\n    }\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.size());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"03ddf64cbf9c9db0ae0594799381bba32114f682","date":1221163234,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.size());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc51dee911981d59e003ffa7442c4f68d9947083","date":1231674881,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":["c7e0383a0a3421b9f6f61002dd4f6fb39bf71285","c7e0383a0a3421b9f6f61002dd4f6fb39bf71285","c7e0383a0a3421b9f6f61002dd4f6fb39bf71285"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"46ff2158529ec1ebfba0b572e330456204f7ef5a","date":1234277721,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrIndexSearcher searcher = req.getSearcher();\n    SolrParams params = req.getParams();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d72e3710bede9618eb9b2b5c6936369f3d3f9579","date":1239534189,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      StringFieldable field = new StringFieldable();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.val = (String)val;\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9c4ed8b555b728a98390ef8546612f6b94f9987f","date":1240848313,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname, sortField.getParser());\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname, sortField.getParser());\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname, sortField.getParser());\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname, sortField.getParser());\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname);\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname);\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname);\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname);\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"10845c160c29e7e480692d2e9d7dad15a6de2630","date":1242326245,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      if (readers.length==1) readers=null;\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        ScoreDocComparator comparators[] = (readers==null) ? null : new ScoreDocComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        SolrIndexReader subReader = reader;\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(sd.doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = getComparator(subReader, sortField);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          sd.doc -= offset;  // adjust for what segment this is in\n          Object val = comparator.sortValue(sd);\n          \n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        IndexReader reader = searcher.getReader();\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n\n        switch (type) {\n          case SortField.INT:\n            comparator = comparatorInt (reader, fieldname, sortField.getParser());\n            break;\n          case SortField.FLOAT:\n            comparator = comparatorFloat (reader, fieldname, sortField.getParser());\n            break;\n          case SortField.LONG:\n            comparator = comparatorLong(reader, fieldname, sortField.getParser());\n            break;\n          case SortField.DOUBLE:\n            comparator = comparatorDouble(reader, fieldname, sortField.getParser());\n            break;\n          case SortField.STRING:\n            if (sortField.getLocale() != null) comparator = comparatorStringLocale (reader, fieldname, sortField.getLocale());\n            else comparator = comparatorString (reader, fieldname);\n            break;\n          case SortField.CUSTOM:\n            comparator = sortField.getFactory().newComparator (reader, fieldname);\n            break;\n          default:\n            throw new RuntimeException (\"unknown field type: \"+type);\n        }\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          Object val = comparator.sortValue(sd);\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":["c3da65606b2cf2b2357063f779126d1521733034"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bc86800ce70a9f858b1dd304f3ac8eaaf163b926","date":1247775863,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      SolrIndexReader subReader = reader;\n      if (readers.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        subReader = readers[0];\n        readers=null;\n      }\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        ScoreDocComparator comparators[] = (readers==null) ? null : new ScoreDocComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(sd.doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = getComparator(subReader, sortField);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          sd.doc -= offset;  // adjust for what segment this is in\n          Object val = comparator.sortValue(sd);\n          \n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      if (readers.length==1) readers=null;\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        ScoreDocComparator comparators[] = (readers==null) ? null : new ScoreDocComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n        SolrIndexReader subReader = reader;\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(sd.doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = getComparator(subReader, sortField);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          sd.doc -= offset;  // adjust for what segment this is in\n          Object val = comparator.sortValue(sd);\n          \n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c3da65606b2cf2b2357063f779126d1521733034","date":1249401214,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      SolrIndexReader subReader = reader;\n      if (readers.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        subReader = readers[0];\n        readers=null;\n      }\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (readers==null) ? null : new FieldComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0,sortField.getReverse());\n            comparator.setNextReader(subReader, offset, 0);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= offset;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      ScoreDoc sd = new ScoreDoc(0,1.0f); // won't work for comparators that look at the score\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      SolrIndexReader subReader = reader;\n      if (readers.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        subReader = readers[0];\n        readers=null;\n      }\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        ScoreDocComparator comparator = null;\n        ScoreDocComparator comparators[] = (readers==null) ? null : new ScoreDocComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          sd.doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(sd.doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = getComparator(subReader, sortField);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          sd.doc -= offset;  // adjust for what segment this is in\n          Object val = comparator.sortValue(sd);\n          \n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":["10845c160c29e7e480692d2e9d7dad15a6de2630","5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c20f931a6f10b153366015604398a5eb7a4d17fa","date":1249615266,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      SolrIndexReader subReader = reader;\n      if (readers.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        subReader = readers[0];\n        readers=null;\n      }\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (readers==null) ? null : new FieldComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator.setNextReader(subReader, offset);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= offset;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      SolrIndexReader subReader = reader;\n      if (readers.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        subReader = readers[0];\n        readers=null;\n      }\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (readers==null) ? null : new FieldComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0,sortField.getReverse());\n            comparator.setNextReader(subReader, offset, 0);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= offset;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9b240c33c89713e9821af46e867f4710eb811864","date":1261647570,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    doFieldSortValues(rb, searcher);\n    doPrefetch(rb);\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n\n    // The query cache doesn't currently store sort field values, and SolrIndexSearcher doesn't\n    // currently have an option to return sort field values.  Because of this, we\n    // take the documents given and re-derive the sort values.\n    boolean fsv = req.getParams().getBool(ResponseBuilder.FIELD_SORT_VALUES,false);\n    if(fsv){\n      Sort sort = rb.getSortSpec().getSort();\n      SortField[] sortFields = sort==null ? new SortField[]{SortField.FIELD_SCORE} : sort.getSort();\n      NamedList sortVals = new NamedList(); // order is important for the sort fields\n      Field field = new Field(\"dummy\", \"\", Field.Store.YES, Field.Index.NO); // a dummy Field\n\n      SolrIndexReader reader = searcher.getReader();\n      SolrIndexReader[] readers = reader.getLeafReaders();\n      SolrIndexReader subReader = reader;\n      if (readers.length==1) {\n        // if there is a single segment, use that subReader and avoid looking up each time\n        subReader = readers[0];\n        readers=null;\n      }\n      int[] offsets = reader.getLeafOffsets();\n\n      for (SortField sortField: sortFields) {\n        int type = sortField.getType();\n        if (type==SortField.SCORE || type==SortField.DOC) continue;\n\n        FieldComparator comparator = null;\n        FieldComparator comparators[] = (readers==null) ? null : new FieldComparator[readers.length];\n\n        String fieldname = sortField.getField();\n        FieldType ft = fieldname==null ? null : req.getSchema().getFieldTypeNoEx(fieldname);\n\n        DocList docList = rb.getResults().docList;\n        ArrayList<Object> vals = new ArrayList<Object>(docList.size());\n        DocIterator it = rb.getResults().docList.iterator();\n\n        int offset = 0;\n        int idx = 0;\n\n        while(it.hasNext()) {\n          int doc = it.nextDoc();\n          if (readers != null) {\n            idx = SolrIndexReader.readerIndex(doc, offsets);\n            subReader = readers[idx];\n            offset = offsets[idx];\n            comparator = comparators[idx];\n          }\n\n          if (comparator == null) {\n            comparator = sortField.getComparator(1,0);\n            comparator.setNextReader(subReader, offset);\n            if (comparators != null)\n              comparators[idx] = comparator;\n          }\n\n          doc -= offset;  // adjust for what segment this is in\n          comparator.copy(0, doc);\n          Object val = comparator.value(0);\n\n          // Sortable float, double, int, long types all just use a string\n          // comparator. For these, we need to put the type into a readable\n          // format.  One reason for this is that XML can't represent all\n          // string values (or even all unicode code points).\n          // indexedToReadable() should be a no-op and should\n          // thus be harmless anyway (for all current ways anyway)\n          if (val instanceof String) {\n            field.setValue((String)val);\n            val = ft.toObject(field);\n          }\n\n          vals.add(val);\n        }\n\n        sortVals.add(fieldname, vals);\n      }\n\n      rsp.add(\"sort_values\", sortVals);\n    }\n\n    //pre-fetch returned documents\n    if (!req.getParams().getBool(ShardParams.IS_SHARD,false) && rb.getResults().docList != null && rb.getResults().docList.size()<=50) {\n      // TODO: this may depend on the highlighter component (or other components?)\n      SolrPluginUtils.optimizePreFetchDocs(rb.getResults().docList, rb.getQuery(), req, rsp);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryComponent#process(ResponseBuilder).mjava","sourceNew":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    doFieldSortValues(rb, searcher);\n    doPrefetch(rb);\n  }\n\n","sourceOld":"  /**\n   * Actually run the query\n   */\n  @Override\n  public void process(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrQueryResponse rsp = rb.rsp;\n    SolrParams params = req.getParams();\n    if (!params.getBool(COMPONENT_NAME, true)) {\n      return;\n    }\n    SolrIndexSearcher searcher = req.getSearcher();\n\n    if (rb.getQueryCommand().getOffset() < 0) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"'start' parameter cannot be negative\");\n    }\n\n    // -1 as flag if not set.\n    long timeAllowed = (long)params.getInt( CommonParams.TIME_ALLOWED, -1 );\n\n    // Optional: This could also be implemented by the top-level searcher sending\n    // a filter that lists the ids... that would be transparent to\n    // the request handler, but would be more expensive (and would preserve score\n    // too if desired).\n    String ids = params.get(ShardParams.IDS);\n    if (ids != null) {\n      SchemaField idField = req.getSchema().getUniqueKeyField();\n      List<String> idArr = StrUtils.splitSmart(ids, \",\", true);\n      int[] luceneIds = new int[idArr.size()];\n      int docs = 0;\n      for (int i=0; i<idArr.size(); i++) {\n        int id = req.getSearcher().getFirstMatch(\n                new Term(idField.getName(), idField.getType().toInternal(idArr.get(i))));\n        if (id >= 0)\n          luceneIds[docs++] = id;\n      }\n\n      DocListAndSet res = new DocListAndSet();\n      res.docList = new DocSlice(0, docs, luceneIds, null, docs, 0);\n      if (rb.isNeedDocSet()) {\n        List<Query> queries = new ArrayList<Query>();\n        queries.add(rb.getQuery());\n        List<Query> filters = rb.getFilters();\n        if (filters != null) queries.addAll(filters);\n        res.docSet = searcher.getDocSet(queries);\n      }\n      rb.setResults(res);\n      rsp.add(\"response\",rb.getResults().docList);\n      return;\n    }\n\n    SolrIndexSearcher.QueryCommand cmd = rb.getQueryCommand();\n    cmd.setTimeAllowed(timeAllowed);\n    SolrIndexSearcher.QueryResult result = new SolrIndexSearcher.QueryResult();\n    searcher.search(result,cmd);\n    rb.setResult( result );\n\n    rsp.add(\"response\",rb.getResults().docList);\n    rsp.getToLog().add(\"hits\", rb.getResults().docList.matches());\n\n    doFieldSortValues(rb, searcher);\n    doPrefetch(rb);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"10845c160c29e7e480692d2e9d7dad15a6de2630":["9c4ed8b555b728a98390ef8546612f6b94f9987f"],"a6c6e4e06160d2ad231072e8743988a623ab14c9":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"d72e3710bede9618eb9b2b5c6936369f3d3f9579":["46ff2158529ec1ebfba0b572e330456204f7ef5a"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"03ddf64cbf9c9db0ae0594799381bba32114f682":["db25c1f61b5ae826f10777da6551a832703967d5"],"46ff2158529ec1ebfba0b572e330456204f7ef5a":["bc51dee911981d59e003ffa7442c4f68d9947083"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"c20f931a6f10b153366015604398a5eb7a4d17fa":["c3da65606b2cf2b2357063f779126d1521733034"],"9c4ed8b555b728a98390ef8546612f6b94f9987f":["d72e3710bede9618eb9b2b5c6936369f3d3f9579"],"da0acfe5ceed804451d76c8f887855b3d060e132":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["da0acfe5ceed804451d76c8f887855b3d060e132"],"bc51dee911981d59e003ffa7442c4f68d9947083":["03ddf64cbf9c9db0ae0594799381bba32114f682"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"db25c1f61b5ae826f10777da6551a832703967d5":["a6c6e4e06160d2ad231072e8743988a623ab14c9"],"ad94625fb8d088209f46650c8097196fec67f00c":["9b240c33c89713e9821af46e867f4710eb811864"],"bc86800ce70a9f858b1dd304f3ac8eaaf163b926":["10845c160c29e7e480692d2e9d7dad15a6de2630"],"9b240c33c89713e9821af46e867f4710eb811864":["c20f931a6f10b153366015604398a5eb7a4d17fa"],"c3da65606b2cf2b2357063f779126d1521733034":["bc86800ce70a9f858b1dd304f3ac8eaaf163b926"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"10845c160c29e7e480692d2e9d7dad15a6de2630":["bc86800ce70a9f858b1dd304f3ac8eaaf163b926"],"a6c6e4e06160d2ad231072e8743988a623ab14c9":["db25c1f61b5ae826f10777da6551a832703967d5"],"d72e3710bede9618eb9b2b5c6936369f3d3f9579":["9c4ed8b555b728a98390ef8546612f6b94f9987f"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76"],"03ddf64cbf9c9db0ae0594799381bba32114f682":["bc51dee911981d59e003ffa7442c4f68d9947083"],"46ff2158529ec1ebfba0b572e330456204f7ef5a":["d72e3710bede9618eb9b2b5c6936369f3d3f9579"],"5bb29c260c4bbaf4ce8a95d362844ebf77ec1f76":["da0acfe5ceed804451d76c8f887855b3d060e132"],"c20f931a6f10b153366015604398a5eb7a4d17fa":["9b240c33c89713e9821af46e867f4710eb811864"],"9c4ed8b555b728a98390ef8546612f6b94f9987f":["10845c160c29e7e480692d2e9d7dad15a6de2630"],"da0acfe5ceed804451d76c8f887855b3d060e132":["ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c"],"ae248910a22eb7d1b6bd9ade7f9a33dfc0506f0c":["a6c6e4e06160d2ad231072e8743988a623ab14c9"],"bc51dee911981d59e003ffa7442c4f68d9947083":["46ff2158529ec1ebfba0b572e330456204f7ef5a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"db25c1f61b5ae826f10777da6551a832703967d5":["03ddf64cbf9c9db0ae0594799381bba32114f682"],"ad94625fb8d088209f46650c8097196fec67f00c":[],"bc86800ce70a9f858b1dd304f3ac8eaaf163b926":["c3da65606b2cf2b2357063f779126d1521733034"],"c3da65606b2cf2b2357063f779126d1521733034":["c20f931a6f10b153366015604398a5eb7a4d17fa"],"9b240c33c89713e9821af46e867f4710eb811864":["ad94625fb8d088209f46650c8097196fec67f00c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ad94625fb8d088209f46650c8097196fec67f00c","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}