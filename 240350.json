{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","commits":[{"id":"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5","date":1556572478,"type":1,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        Map<String, Object> reqMap = new HashMap<>();\n        ((V2Request)req).toMap(reqMap);\n        String path = (String)reqMap.get(\"path\");\n        if (!path.startsWith(\"/c/\") || path.length() < 4) {\n          throw new UnsupportedOperationException(\"Unsupported V2 request path: \" + reqMap);\n        }\n        Map<String, Object> cmd = (Map<String, Object>)reqMap.get(\"command\");\n        if (cmd.size() != 1) {\n          throw new UnsupportedOperationException(\"Unsupported multi-command V2 request: \" + reqMap);\n        }\n        a = cmd.keySet().iterator().next();\n        params = new ModifiableSolrParams();\n        ((ModifiableSolrParams)params).add(CollectionAdminParams.COLLECTION, path.substring(3));\n        if (req.getParams() != null) {\n          ((ModifiableSolrParams)params).add(req.getParams());\n        }\n        Map<String, Object> reqParams = (Map<String, Object>)cmd.get(a);\n        for (Map.Entry<String, Object> e : reqParams.entrySet()) {\n          ((ModifiableSolrParams)params).add(e.getKey(), e.getValue().toString());\n        }\n        // re-map from v2 to v1 action\n        a = v2v1Mapping.get(a);\n        if (a == null) {\n          throw new UnsupportedOperationException(\"Unsupported V2 request: \" + reqMap);\n        }\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams().toQueryString() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    if (!(req instanceof CollectionAdminRequest)) {\n      throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName());\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    SolrParams params = req.getParams();\n    String a = params.get(CoreAdminParams.ACTION);\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), req.getParams().toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = req.getParams().get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = req.getParams().get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(req.getParams().get(CommonParams.NAME),\n                req.getParams().get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (req.getParams().get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, req.getParams().get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(req.getParams().get(\"node\"), \"nodeRole\", req.getParams().get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(req.getParams().toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + req.getParams());\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + req.getParams());\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"edf5b262a72d10530eb2f01dc8f19060355b213e","date":1557765866,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        Map<String, Object> reqMap = new HashMap<>();\n        ((V2Request)req).toMap(reqMap);\n        String path = (String)reqMap.get(\"path\");\n        if (!path.startsWith(\"/c/\") || path.length() < 4) {\n          throw new UnsupportedOperationException(\"Unsupported V2 request path: \" + reqMap);\n        }\n        Map<String, Object> cmd = (Map<String, Object>)reqMap.get(\"command\");\n        if (cmd.size() != 1) {\n          throw new UnsupportedOperationException(\"Unsupported multi-command V2 request: \" + reqMap);\n        }\n        a = cmd.keySet().iterator().next();\n        params = new ModifiableSolrParams();\n        ((ModifiableSolrParams)params).add(CollectionAdminParams.COLLECTION, path.substring(3));\n        if (req.getParams() != null) {\n          ((ModifiableSolrParams)params).add(req.getParams());\n        }\n        Map<String, Object> reqParams = (Map<String, Object>)cmd.get(a);\n        for (Map.Entry<String, Object> e : reqParams.entrySet()) {\n          ((ModifiableSolrParams)params).add(e.getKey(), e.getValue().toString());\n        }\n        // re-map from v2 to v1 action\n        a = v2v1Mapping.get(a);\n        if (a == null) {\n          throw new UnsupportedOperationException(\"Unsupported V2 request: \" + reqMap);\n        }\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d","date":1571856490,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e35f2dde06b35aa9904949a3a93fabd090371077","date":1587906921,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    if (log.isTraceEnabled()) {\n      log.trace(\"--- got SolrRequest: {} {} {}\", req.getMethod(), req.getPath(),\n          (req.getParams() != null ? \" \" + req.getParams() : \"\")); // logOk\n    }\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- exception handling request\", queryResponse.getException());\n          }\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      if (log.isTraceEnabled()) {\n        log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      }\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    log.trace(\"--- got SolrRequest: \" + req.getMethod() + \" \" + req.getPath() +\n        (req.getParams() != null ? \" \" + req.getParams() : \"\"));\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          log.debug(\"-- exception handling request\", queryResponse.getException());\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e6e01fcbda8c04bde654f99836a2f8813f9444f3","date":1589564391,"type":3,"author":"erick","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    if (log.isTraceEnabled()) {\n      log.trace(\"--- got SolrRequest: {} {} {}\", req.getMethod(), req.getPath(),\n          (req.getParams() != null ? \" \" + req.getParams() : \"\")); // logOk\n    }\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- exception handling request\", queryResponse.getException());\n          }\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      if (log.isTraceEnabled()) {\n        log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      }\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    if (log.isTraceEnabled()) {\n      log.trace(\"--- got SolrRequest: {} {} {}\", req.getMethod(), req.getPath(),\n          (req.getParams() != null ? \" \" + req.getParams() : \"\")); // logOk\n    }\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- exception handling request\", queryResponse.getException());\n          }\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      if (log.isTraceEnabled()) {\n        log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      }\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    if (log.isTraceEnabled()) {\n      log.trace(\"--- got SolrRequest: {} {} {}\", req.getMethod(), req.getPath(),\n          (req.getParams() != null ? \" \" + req.getParams() : \"\")); // logOk\n    }\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- exception handling request\", queryResponse.getException());\n          }\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      if (log.isTraceEnabled()) {\n        log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    if (log.isTraceEnabled()) {\n      log.trace(\"--- got SolrRequest: {} {} {}\", req.getMethod(), req.getPath(),\n          (req.getParams() != null ? \" \" + req.getParams() : \"\")); // logOk\n    }\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- exception handling request\", queryResponse.getException());\n          }\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      if (log.isTraceEnabled()) {\n        log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      }\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimCloudManager#simHandleSolrRequest(SolrRequest).mjava","sourceNew":null,"sourceOld":"  /**\n   * Handler method for autoscaling requests. NOTE: only a specific subset of autoscaling requests is\n   * supported!\n   * @param req autoscaling request\n   * @return results\n   */\n\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public SolrResponse simHandleSolrRequest(SolrRequest req) throws IOException, InterruptedException {\n    // pay the penalty for remote request, at least 5 ms\n    timeSource.sleep(5);\n\n    if (log.isTraceEnabled()) {\n      log.trace(\"--- got SolrRequest: {} {} {}\", req.getMethod(), req.getPath(),\n          (req.getParams() != null ? \" \" + req.getParams() : \"\")); // logOk\n    }\n    if (req.getPath() != null) {\n      if (req.getPath().startsWith(\"/admin/autoscaling\") ||\n          req.getPath().startsWith(\"/cluster/autoscaling\") ||\n          req.getPath().startsWith(\"/admin/metrics\") ||\n          req.getPath().startsWith(\"/cluster/metrics\")\n          ) {\n        metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n        boolean autoscaling = req.getPath().contains(\"autoscaling\");\n        boolean history = req.getPath().contains(\"history\");\n        if (autoscaling) {\n          incrementCount(\"autoscaling\");\n        } else if (history) {\n          incrementCount(\"metricsHistory\");\n        } else {\n          incrementCount(\"metrics\");\n        }\n        ModifiableSolrParams params = new ModifiableSolrParams(req.getParams());\n        params.set(CommonParams.PATH, req.getPath());\n        LocalSolrQueryRequest queryRequest = new LocalSolrQueryRequest(null, params);\n        if (autoscaling) {\n          RequestWriter.ContentWriter cw = req.getContentWriter(\"application/json\");\n          if (null != cw) {\n            ByteArrayOutputStream baos = new ByteArrayOutputStream();\n            cw.write(baos);\n            String payload = baos.toString(\"UTF-8\");\n            log.trace(\"-- payload: {}\", payload);\n            queryRequest.setContentStreams(Collections.singletonList(new ContentStreamBase.StringStream(payload)));\n          }\n        }\n        queryRequest.getContext().put(\"httpMethod\", req.getMethod().toString());\n        SolrQueryResponse queryResponse = new SolrQueryResponse();\n        queryResponse.addResponseHeader(new SimpleOrderedMap<>());\n        if (autoscaling) {\n          autoScalingHandler.handleRequest(queryRequest, queryResponse);\n        } else {\n          if (history) {\n            if (metricsHistoryHandler != null) {\n              metricsHistoryHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          } else {\n            if (metricsHandler != null) {\n              metricsHandler.handleRequest(queryRequest, queryResponse);\n            } else {\n              queryRequest.close();\n              throw new UnsupportedOperationException(\"must add at least 1 node first\");\n            }\n          }\n        }\n        if (queryResponse.getException() != null) {\n          if (log.isDebugEnabled()) {\n            log.debug(\"-- exception handling request\", queryResponse.getException());\n          }\n          throw new IOException(queryResponse.getException());\n        }\n        SolrResponse rsp = new SolrResponseBase();\n        rsp.setResponse(queryResponse.getValues());\n        log.trace(\"-- response: {}\", rsp);\n        return rsp;\n      } else if (req instanceof QueryRequest) {\n        incrementCount(\"query\");\n        return clusterStateProvider.simQuery((QueryRequest)req);\n      }\n    }\n    if (req instanceof UpdateRequest) {\n      incrementCount(\"update\");\n      UpdateRequest ureq = (UpdateRequest)req;\n      String collection = ureq.getCollection();\n      UpdateResponse rsp = clusterStateProvider.simUpdate(ureq);\n      if (collection == null || collection.equals(CollectionAdminParams.SYSTEM_COLL)) {\n        List<SolrInputDocument> docs = ureq.getDocuments();\n        if (docs != null) {\n          if (useSystemCollection) {\n            systemColl.addAll(docs);\n          }\n          for (SolrInputDocument d : docs) {\n            if (!\"autoscaling_event\".equals(d.getFieldValue(\"type\"))) {\n              continue;\n            }\n            eventCounts.computeIfAbsent((String)d.getFieldValue(\"event.source_s\"), s -> new ConcurrentHashMap<>())\n                .computeIfAbsent((String)d.getFieldValue(\"stage_s\"), s -> new AtomicInteger())\n                .incrementAndGet();\n          }\n        }\n        return new UpdateResponse();\n      } else {\n        return rsp;\n      }\n    }\n    // support only a specific subset of collection admin ops\n    SolrParams params = req.getParams();\n    String a = params != null ? params.get(CoreAdminParams.ACTION) : null;\n    SolrResponse rsp = new SolrResponseBase();\n    rsp.setResponse(new NamedList<>());\n    String path = params != null ? params.get(\"path\") : null;\n    if (!(req instanceof CollectionAdminRequest)) {\n      // maybe a V2Request?\n      if (req instanceof V2Request) {\n        params = SimUtils.v2AdminRequestToV1Params((V2Request)req);\n        a = params.get(CoreAdminParams.ACTION);\n      } else if (path != null && (path.startsWith(\"/admin/\") || path.startsWith(\"/cluster/\"))) {\n        // pass it through, it's likely a generic request containing admin params\n      } else {\n        throw new UnsupportedOperationException(\"Only some CollectionAdminRequest-s are supported: \" + req.getClass().getName() + \": \" + req.getPath() + \" \" + req.getParams());\n      }\n    }\n    metricManager.registry(\"solr.node\").counter(\"ADMIN.\" + req.getPath() + \".requests\").inc();\n    if (a != null) {\n      CollectionParams.CollectionAction action = CollectionParams.CollectionAction.get(a);\n      if (action == null) {\n        throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Unknown action: \" + a);\n      }\n      if (log.isTraceEnabled()) {\n        log.trace(\"Invoking Collection Action :{} with params {}\", action.toLower(), params.toQueryString());\n      }\n      @SuppressWarnings({\"rawtypes\"})\n      NamedList results = new NamedList();\n      rsp.setResponse(results);\n      incrementCount(action.name());\n      switch (action) {\n        case REQUESTSTATUS:\n          // we complete all async ops immediately\n          String requestId = params.get(REQUESTID);\n          SimpleOrderedMap<String> status = new SimpleOrderedMap<>();\n          status.add(\"state\", RequestStatusState.COMPLETED.getKey());\n          status.add(\"msg\", \"found [\" + requestId + \"] in completed tasks\");\n          results.add(\"status\", status);\n          results.add(\"success\", \"\");\n          // ExecutePlanAction expects a specific response class\n          rsp = new CollectionAdminRequest.RequestStatusResponse();\n          rsp.setResponse(results);\n          break;\n        case DELETESTATUS:\n          requestId = params.get(REQUESTID);\n          results.add(\"status\", \"successfully removed stored response for [\" + requestId + \"]\");\n          results.add(\"success\", \"\");\n          break;\n        case CREATE:\n          try {\n            clusterStateProvider.simCreateCollection(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETE:\n          try {\n            clusterStateProvider.simDeleteCollection(params.get(CommonParams.NAME),\n                params.get(CommonAdminParams.ASYNC), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case LIST:\n          results.add(\"collections\", clusterStateProvider.simListCollections());\n          break;\n        case ADDREPLICA:\n          try {\n            clusterStateProvider.simAddReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case MOVEREPLICA:\n          try {\n            clusterStateProvider.simMoveReplica(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case OVERSEERSTATUS:\n          if (params.get(CommonAdminParams.ASYNC) != null) {\n            results.add(REQUESTID, params.get(CommonAdminParams.ASYNC));\n          }\n          if (!liveNodesSet.get().isEmpty()) {\n            results.add(\"leader\", liveNodesSet.get().iterator().next());\n          }\n          results.add(\"overseer_queue_size\", 0);\n          results.add(\"overseer_work_queue_size\", 0);\n          results.add(\"overseer_collection_queue_size\", 0);\n          results.add(\"success\", \"\");\n          break;\n        case ADDROLE:\n          nodeStateProvider.simSetNodeValue(params.get(\"node\"), \"nodeRole\", params.get(\"role\"));\n          break;\n        case CREATESHARD:\n          try {\n            clusterStateProvider.simCreateShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case SPLITSHARD:\n          try {\n            clusterStateProvider.simSplitShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        case DELETESHARD:\n          try {\n            clusterStateProvider.simDeleteShard(new ZkNodeProps(params.toNamedList().asMap(10)), results);\n          } catch (Exception e) {\n            throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, e);\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\"Unsupported collection admin action=\" + action + \" in request: \" + params);\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"action is a required param in request: \" + params);\n    }\n    return rsp;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"e6e01fcbda8c04bde654f99836a2f8813f9444f3":["e35f2dde06b35aa9904949a3a93fabd090371077"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["e6e01fcbda8c04bde654f99836a2f8813f9444f3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"e35f2dde06b35aa9904949a3a93fabd090371077":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["edf5b262a72d10530eb2f01dc8f19060355b213e"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e6e01fcbda8c04bde654f99836a2f8813f9444f3":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5"],"e35f2dde06b35aa9904949a3a93fabd090371077":["e6e01fcbda8c04bde654f99836a2f8813f9444f3"],"edf5b262a72d10530eb2f01dc8f19060355b213e":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"9ef8d00dbfbeb534eba8a219a5df9d99b2de6ab5":["edf5b262a72d10530eb2f01dc8f19060355b213e"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["e35f2dde06b35aa9904949a3a93fabd090371077"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}