{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","commits":[{"id":"fa76b98015a97f0eca94f0f11fd1b6975838c3ee","date":1461000501,"type":1,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    \n    return true;\n  }\n\n","sourceOld":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  public static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>();\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          thirdPartInternal.set(2, true);\n          //System.out.println(\"Doing convex part...\");\n          if (buildPolygonShape(rval,\n            planetModel,\n            thirdPartPoints,\n            thirdPartInternal, \n            0,\n            1,\n            checkEdge.plane,\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done convex part.\");\n\n          // ??? check if we get the sense right\n          \n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    if (makeConcavePolygon(planetModel, rval, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    \n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fe5373303e11ed8f999dbf1e4017b39a551dd92","date":1521903795,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          try {\n            final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n            //System.out.println(\"convex part = \"+convexPart);\n            rval.addShape(convexPart);\n          } catch (IllegalArgumentException e) {\n            // Eat this exception, assuming that it means the triangle is coplanar, and look for\n            // other edges that will work instead.\n            break;\n          }\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new IllegalArgumentException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    return true;\n  }\n\n","sourceOld":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    \n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ef3779f3001aaf18181e07c9791e22c0adc6717","date":1521963968,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          if (Plane.arePointsCoplanar(checkEdge.startPoint, checkEdge.endPoint, thePoint)) {\n            // Can't build this particular tile because of colinearity, so advance to another that maybe we can build.\n            break;\n          }\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new IllegalArgumentException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          try {\n            final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n            //System.out.println(\"convex part = \"+convexPart);\n            rval.addShape(convexPart);\n          } catch (IllegalArgumentException e) {\n            // Eat this exception, assuming that it means the triangle is coplanar, and look for\n            // other edges that will work instead.\n            break;\n          }\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new IllegalArgumentException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c449a01f2d90df92e27093325d2b7095a97bd40c","date":1521964731,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          if (Plane.arePointsCoplanar(checkEdge.startPoint, checkEdge.endPoint, thePoint)) {\n            // Can't build this particular tile because of colinearity, so advance to another that maybe we can build.\n            continue;\n          }\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new IllegalArgumentException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          if (Plane.arePointsCoplanar(checkEdge.startPoint, checkEdge.endPoint, thePoint)) {\n            // Can't build this particular tile because of colinearity, so advance to another that maybe we can build.\n            break;\n          }\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new IllegalArgumentException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1452bbfea2334e79ba7ac6b6e1508344526145c","date":1521980228,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoPolygonFactory#buildPolygonShape(GeoCompositePolygon,MutableBoolean,PlanetModel,List[GeoPoint],BitSet,int,int,SidedPlane,List[GeoPolygon],GeoPoint).mjava","sourceNew":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) throws TileException {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          if (Plane.arePointsCoplanar(checkEdge.startPoint, checkEdge.endPoint, thePoint)) {\n            // Can't build this particular tile because of colinearity, so advance to another that maybe we can build.\n            continue;\n          }\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new TileException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    return true;\n  }\n\n","sourceOld":"  /** Build a GeoPolygon out of one concave part and multiple convex parts given points, starting edge, and whether starting edge is internal or not.\n   * @param rval is the composite polygon to add to.\n   * @param seenConcave is true if a concave polygon has been seen in this generation yet.\n   * @param planetModel is the planet model.\n   * @param pointsList is a list of the GeoPoints to build an arbitrary polygon out of.\n   * @param internalEdges specifies which edges are internal.\n   * @param startPointIndex is the first of the points, constituting the starting edge.\n   * @param startingEdge is the plane describing the starting edge.\n   * @param holes is the list of holes in the polygon, or null if none.\n   * @param testPoint is an (optional) test point, which will be used to determine if we are generating\n   *  a shape with the proper sidedness.  It is passed in only when the test point is supposed to be outside\n   *  of the generated polygon.  In this case, if the generated polygon is found to contain the point, the\n   *  method exits early with a null return value.\n   *  This only makes sense in the context of evaluating both possible choices and using logic to determine\n   *  which result to use.  If the test point is supposed to be within the shape, then it must be outside of the\n   *  complement shape.  If the test point is supposed to be outside the shape, then it must be outside of the\n   *  original shape.  Either way, we can figure out the right thing to use.\n   * @return false if what was specified\n   *  was inconsistent with what we generated.  Specifically, if we specify an exterior point that is\n   *  found in the interior of the shape we create here we return false, which is a signal that we chose\n   *  our initial plane sidedness backwards.\n   */\n  static boolean buildPolygonShape(\n    final GeoCompositePolygon rval,\n    final MutableBoolean seenConcave,\n    final PlanetModel planetModel,\n    final List<GeoPoint> pointsList,\n    final BitSet internalEdges,\n    final int startPointIndex,\n    final int endPointIndex,\n    final SidedPlane startingEdge,\n    final List<GeoPolygon> holes,\n    final GeoPoint testPoint) {\n\n    // It could be the case that we need a concave polygon.  So we need to try and look for that case\n    // as part of the general code for constructing complex polygons.\n\n    // Note that there can be only one concave polygon.  This code will enforce that condition and will return\n    // false if it is violated.\n              \n    // The code here must keep track of two lists of sided planes.  The first list contains the planes consistent with\n    // a concave polygon.  This list will grow and shrink.  The second list is built starting at the current edge that\n    // was last consistent with the concave polygon, and contains all edges consistent with a convex polygon.\n    // When that sequence of edges is done, then an internal edge is created and the identified points are converted to a\n    // convex polygon.  That internal edge is used to extend the list of edges in the concave polygon edge list.\n\n    // The edge buffer.\n    final EdgeBuffer edgeBuffer = new EdgeBuffer(pointsList, internalEdges, startPointIndex, endPointIndex, startingEdge);\n\n    /*\n    // Verify that the polygon does not self-intersect\n    // Now, look for non-adjacent edges that cross.\n    System.err.println(\"Looking for intersections...\");\n    System.err.println(\"Starting edge is: \"+startingEdge);\n    final Iterator<Edge> edgeIterator = edgeBuffer.iterator();\n    while (edgeIterator.hasNext()) {\n      final Edge edge = edgeIterator.next();\n      final Set<Edge> excludedEdges = new HashSet<>();\n      excludedEdges.add(edge);\n      Edge oneBoundary = edgeBuffer.getPrevious(edge);\n      while (oneBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(oneBoundary);\n        oneBoundary = edgeBuffer.getPrevious(oneBoundary);\n      }\n      excludedEdges.add(oneBoundary);\n      Edge otherBoundary = edgeBuffer.getNext(edge);\n      while (otherBoundary.plane.isNumericallyIdentical(edge.plane)) {\n        excludedEdges.add(otherBoundary);\n        otherBoundary = edgeBuffer.getNext(otherBoundary);\n      }\n      excludedEdges.add(otherBoundary);\n\n      // Now go through all other edges and rule out any intersections\n      final Iterator<Edge> compareIterator = edgeBuffer.iterator();\n      while (compareIterator.hasNext()) {\n        final Edge compareEdge = compareIterator.next();\n        if (!excludedEdges.contains(compareEdge)) {\n          // Found an edge we can compare with!\n          //System.err.println(\"Found a compare edge...\");\n          boolean nonOverlapping = true;\n          // We need the other boundaries though.\n          Edge oneCompareBoundary = edgeBuffer.getPrevious(compareEdge);\n          while (oneCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(oneCompareBoundary)) {\n              //System.err.println(\" excluded because oneCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            oneCompareBoundary = edgeBuffer.getPrevious(oneCompareBoundary);\n          }\n          Edge otherCompareBoundary = edgeBuffer.getNext(compareEdge);\n          while (otherCompareBoundary.plane.isNumericallyIdentical(compareEdge.plane)) {\n            if (excludedEdges.contains(otherCompareBoundary)) {\n              //System.err.println(\" excluded because otherCompareBoundary found to be in set\");\n              nonOverlapping = false;\n              break;\n            }\n            otherCompareBoundary = edgeBuffer.getNext(otherCompareBoundary);\n          }\n          if (nonOverlapping) {\n            //System.err.println(\"Preparing to call findIntersections...\");\n            // Finally do an intersection test\n            if (edge.plane.findIntersections(planetModel, compareEdge.plane, oneBoundary.plane, otherBoundary.plane, oneCompareBoundary.plane, otherCompareBoundary.plane).length > 0) {\n              throw new IllegalArgumentException(\"polygon has intersecting edges\");\n            }\n          }\n        }\n      }\n    }\n    */\n    \n    // Starting state:\n    // The stopping point\n    Edge stoppingPoint = edgeBuffer.pickOne();\n    // The current edge\n    Edge currentEdge = stoppingPoint;\n    \n    // Progressively look for convex sections.  If we find one, we emit it and replace it.\n    // Keep going until we have been around once and nothing needed to change, and then\n    // do the concave polygon, if necessary.\n    while (true) {\n\n      if (currentEdge == null) {\n        // We're done!\n        break;\n      }\n      \n      // Find convexity around the current edge, if any\n      final Boolean foundIt = findConvexPolygon(planetModel, currentEdge, rval, edgeBuffer, holes, testPoint);\n      if (foundIt == null) {\n        return false;\n      }\n      \n      if (foundIt) {\n        // New start point\n        stoppingPoint = edgeBuffer.pickOne();\n        currentEdge = stoppingPoint;\n        // back around\n        continue;\n      }\n      \n      // Otherwise, go on to the next\n      currentEdge = edgeBuffer.getNext(currentEdge);\n      if (currentEdge == stoppingPoint) {\n        break;\n      }\n    }\n    \n    // Look for any reason that the concave polygon cannot be created.\n    // This test is really the converse of the one for a convex polygon.\n    // Points on the edge of a convex polygon MUST be inside all the other\n    // edges.  For a concave polygon, this check is still the same, except we have\n    // to look at the reverse sided planes, not the forward ones.\n    \n    // If we find a point that is outside of the complementary edges, it means that\n    // the point is in fact able to form a convex polygon with the edge it is\n    // offending. \n    \n    // If what is left has any plane/point pair that is on the wrong side, we have to split using one of the plane endpoints and the \n    // point in question.  This is best structured as a recursion, if detected.\n    \n    // Note: Any edge that fails means (I think!!) that there's another edge that will also fail.\n    // This is because each point is included in two edges.\n    // So, when we look for a non-conforming edge, and we can find one (but can't use it), we\n    // also can find another edge that we might be able to use instead.\n    // If this is true, it means we should continue when we find a bad edge we can't use --\n    // but we need to keep track of this, and fail hard if we don't find a place to split.\n    boolean foundBadEdge = false;\n    final Iterator<Edge> checkIterator = edgeBuffer.iterator();\n    while (checkIterator.hasNext()) {\n      final Edge checkEdge = checkIterator.next();\n      final SidedPlane flippedPlane = new SidedPlane(checkEdge.plane);\n      // Now walk around again looking for points that fail.\n      final Iterator<Edge> confirmIterator = edgeBuffer.iterator();\n      while (confirmIterator.hasNext()) {\n        final Edge confirmEdge = confirmIterator.next();\n        if (confirmEdge == checkEdge) {\n          continue;\n        }\n        // Look for a point that is on the wrong side of the check edge.  This means that we can't build the polygon.\n        final GeoPoint thePoint;\n        if (checkEdge.startPoint != confirmEdge.startPoint && checkEdge.endPoint != confirmEdge.startPoint && !flippedPlane.isWithin(confirmEdge.startPoint)) {\n          thePoint = confirmEdge.startPoint;\n        } else if (checkEdge.startPoint != confirmEdge.endPoint && checkEdge.endPoint != confirmEdge.endPoint && !flippedPlane.isWithin(confirmEdge.endPoint)) {\n          thePoint = confirmEdge.endPoint;\n        } else {\n          thePoint = null;\n        }\n        if (thePoint != null) {\n          // Note that we found a problem.\n          foundBadEdge = true;\n          // thePoint is on the wrong side of the complementary plane.  That means we cannot build a concave polygon, because the complement would not\n          // be a legal convex polygon.\n          // But we can take advantage of the fact that the distance between the edge and thePoint is less than 180 degrees, and so we can split the\n          // would-be concave polygon into three segments.  The first segment includes the edge and thePoint, and uses the sense of the edge to determine the sense\n          // of the polygon.\n          \n          // This should be the only problematic part of the polygon.\n          // We know that thePoint is on the \"wrong\" side of the edge -- that is, it's on the side that the\n          // edge is pointing at.\n          \n          // The proposed tiling generates two new edges -- one from thePoint to the start point of the edge we found, and the other from thePoint\n          // to the end point of the edge.  We generate that as a triangle convex polygon, and tile the two remaining pieces.\n          if (Plane.arePointsCoplanar(checkEdge.startPoint, checkEdge.endPoint, thePoint)) {\n            // Can't build this particular tile because of colinearity, so advance to another that maybe we can build.\n            continue;\n          }\n          final List<GeoPoint> thirdPartPoints = new ArrayList<>(3);\n          final BitSet thirdPartInternal = new BitSet();\n          thirdPartPoints.add(checkEdge.startPoint);\n          thirdPartInternal.set(0, checkEdge.isInternal);\n          thirdPartPoints.add(checkEdge.endPoint);\n          thirdPartInternal.set(1, true);\n          thirdPartPoints.add(thePoint);\n          assert checkEdge.plane.isWithin(thePoint) : \"Point was on wrong side of complementary plane, so must be on the right side of the non-complementary plane!\";\n          // Check for illegal argument using try/catch rather than pre-emptive check, since it cuts down on building objects for a rare case\n          final GeoPolygon convexPart = new GeoConvexPolygon(planetModel, thirdPartPoints, holes, thirdPartInternal, true);\n          //System.out.println(\"convex part = \"+convexPart);\n          rval.addShape(convexPart);\n\n          // The part preceding the bad edge, back to thePoint, needs to be recursively\n          // processed.  So, assemble what we need, which is basically a list of edges.\n          Edge loopEdge = edgeBuffer.getPrevious(checkEdge);\n          final List<GeoPoint> firstPartPoints = new ArrayList<>();\n          final BitSet firstPartInternal = new BitSet();\n          int i = 0;\n          while (true) {\n            firstPartPoints.add(loopEdge.endPoint);\n            if (loopEdge.endPoint == thePoint) {\n              break;\n            }\n            firstPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getPrevious(loopEdge);\n          }\n          firstPartInternal.set(i, true);\n          //System.out.println(\"Doing first part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            firstPartPoints,\n            firstPartInternal, \n            firstPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.endPoint, false, checkEdge.startPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"...done first part.\");\n          \n          final List<GeoPoint> secondPartPoints = new ArrayList<>();\n          final BitSet secondPartInternal = new BitSet();\n          loopEdge = edgeBuffer.getNext(checkEdge);\n          i = 0;\n          while (true) {\n            secondPartPoints.add(loopEdge.startPoint);\n            if (loopEdge.startPoint == thePoint) {\n              break;\n            }\n            secondPartInternal.set(i++, loopEdge.isInternal);\n            loopEdge = edgeBuffer.getNext(loopEdge);\n          }\n          secondPartInternal.set(i, true);\n          //System.out.println(\"Doing second part...\");\n          if (buildPolygonShape(rval,\n            seenConcave,\n            planetModel,\n            secondPartPoints,\n            secondPartInternal, \n            secondPartPoints.size()-1,\n            0,\n            new SidedPlane(checkEdge.startPoint, false, checkEdge.endPoint, thePoint),\n            holes,\n            testPoint) == false) {\n            return false;\n          }\n          //System.out.println(\"... done second part\");\n          \n          return true;\n        }\n      }\n    }\n\n    if (foundBadEdge) {\n      // Unaddressed bad edge\n      throw new IllegalArgumentException(\"Could not tile polygon; found a pathological coplanarity that couldn't be addressed\");\n    }\n    \n    // No violations found: we know it's a legal concave polygon.\n    \n    // If there's anything left in the edge buffer, convert to concave polygon.\n    //System.out.println(\"adding concave part\");\n    if (makeConcavePolygon(planetModel, rval, seenConcave, edgeBuffer, holes, testPoint) == false) {\n      return false;\n    }\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c449a01f2d90df92e27093325d2b7095a97bd40c":["0ef3779f3001aaf18181e07c9791e22c0adc6717"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a1452bbfea2334e79ba7ac6b6e1508344526145c":["c449a01f2d90df92e27093325d2b7095a97bd40c"],"7fe5373303e11ed8f999dbf1e4017b39a551dd92":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"0ef3779f3001aaf18181e07c9791e22c0adc6717":["7fe5373303e11ed8f999dbf1e4017b39a551dd92"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a1452bbfea2334e79ba7ac6b6e1508344526145c"]},"commit2Childs":{"fa76b98015a97f0eca94f0f11fd1b6975838c3ee":["7fe5373303e11ed8f999dbf1e4017b39a551dd92"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["fa76b98015a97f0eca94f0f11fd1b6975838c3ee"],"c449a01f2d90df92e27093325d2b7095a97bd40c":["a1452bbfea2334e79ba7ac6b6e1508344526145c"],"a1452bbfea2334e79ba7ac6b6e1508344526145c":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7fe5373303e11ed8f999dbf1e4017b39a551dd92":["0ef3779f3001aaf18181e07c9791e22c0adc6717"],"0ef3779f3001aaf18181e07c9791e22c0adc6717":["c449a01f2d90df92e27093325d2b7095a97bd40c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}