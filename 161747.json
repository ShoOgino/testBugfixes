{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {\t\t\t  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<String>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {\t\t\t  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<String>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<String>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {\t\t\t  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<String>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<String>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd4e13d997cf4fb810398a20a299c2c5a9f6b796","date":1395594336,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      if (directory.fileExists(fileName)) {\n\n        // Some operating systems (e.g. Windows) don't\n        // permit a file to be deleted while it is opened\n        // for read (e.g. by another process or thread). So\n        // we assume that when a delete fails it is because\n        // the file is open in another process, and queue\n        // the file for subsequent deletion.\n\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n        }\n        if (deletable == null) {\n          deletable = new ArrayList<>();\n        }\n        deletable.add(fileName);                  // add to deletable\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c","date":1396634612,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"15e323346eac5e4685c0a9f2df85eb96b4239bbb","date":1396688577,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7599427f762eb1b4265584fd6e96521e4a1a4f3c","date":1413100083,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new HashSet<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"55980207f1977bd1463465de1659b821347e2fa8","date":1413336386,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  void deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new HashSet<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName)\n       throws IOException {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new ArrayList<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"950882a2bd2a5f9dc16a154871584eaa643d882a","date":1436366563,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      assert e instanceof NoSuchFileException == false: \"file=\" + fileName;\n      assert e instanceof FileNotFoundException == false: \"file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","sourceOld":"  void deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n    } catch (IOException e) {  // if delete fails\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      if (deletable == null) {\n        deletable = new HashSet<>();\n      }\n      deletable.add(fileName);                  // add to deletable\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a3e0383956f06bd282a3e3aa2b353326e159802","date":1436383320,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      assert e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      assert e instanceof NoSuchFileException == false: \"file=\" + fileName;\n      assert e instanceof FileNotFoundException == false: \"file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"609beaebbd985152a9285cb621655acb0ffd830e","date":1440927343,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      assert Constants.WINDOWS || e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert Constants.WINDOWS || e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","sourceOld":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      assert e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":4,"author":"Mike McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":null,"sourceOld":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      assert Constants.WINDOWS || e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert Constants.WINDOWS || e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":null,"sourceOld":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      assert Constants.WINDOWS || e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert Constants.WINDOWS || e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":4,"author":"Mike McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":null,"sourceOld":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      assert Constants.WINDOWS || e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert Constants.WINDOWS || e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":4,"author":"Erick Erickson","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","sourceNew":null,"sourceOld":"  /** Returns true if the delete succeeded. Otherwise, the fileName is\n   *  added to the deletable set so we will retry the delete later, and\n   *  we return false. */\n  private boolean deleteFile(String fileName) {\n    assert locked();\n    ensureOpen();\n    try {\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"delete \\\"\" + fileName + \"\\\"\");\n      }\n      directory.deleteFile(fileName);\n      deletable.remove(fileName);\n      return true;\n    } catch (IOException e) {  // if delete fails\n\n      // IndexWriter should only ask us to delete files it knows it wrote, so if we hit this, something is wrong!\n      // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state:\n      assert Constants.WINDOWS || e instanceof NoSuchFileException == false: \"hit unexpected NoSuchFileException: file=\" + fileName;\n      assert Constants.WINDOWS || e instanceof FileNotFoundException == false: \"hit unexpected FileNotFoundException: file=\" + fileName;\n\n      // Some operating systems (e.g. Windows) don't\n      // permit a file to be deleted while it is opened\n      // for read (e.g. by another process or thread). So\n      // we assume that when a delete fails it is because\n      // the file is open in another process, and queue\n      // the file for subsequent deletion.\n\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"unable to remove file \\\"\" + fileName + \"\\\": \" + e.toString() + \"; Will re-try later.\");\n      }\n      deletable.add(fileName);\n      return false;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4f0befec2c0666a2f1879aaa34f396573a0216c4","date":1454957645,"type":0,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#deleteFile(String).mjava","pathOld":"/dev/null","sourceNew":"  private void deleteFile(String fileName) throws IOException {\n    try {\n      directory.deleteFile(fileName);\n    } catch (NoSuchFileException | FileNotFoundException e) {\n      if (Constants.WINDOWS) {\n        // TODO: can we remove this OS-specific hacky logic?  If windows deleteFile is buggy, we should instead contain this workaround in\n        // a WindowsFSDirectory ...\n        // LUCENE-6684: we suppress this assert for Windows, since a file could be in a confusing \"pending delete\" state, where we already\n        // deleted it once, yet it still shows up in directory listings, and if you try to delete it again you'll hit NSFE/FNFE:\n      } else {\n        throw e;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7599427f762eb1b4265584fd6e96521e4a1a4f3c":["bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"55980207f1977bd1463465de1659b821347e2fa8":["bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c","7599427f762eb1b4265584fd6e96521e4a1a4f3c"],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5a207d19eac354d649c3f0e2cce070017c78125e":["609beaebbd985152a9285cb621655acb0ffd830e","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["609beaebbd985152a9285cb621655acb0ffd830e","b470f36a9372c97283360b1304eacbde22df6c0d"],"4f0befec2c0666a2f1879aaa34f396573a0216c4":["5a207d19eac354d649c3f0e2cce070017c78125e"],"bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"609beaebbd985152a9285cb621655acb0ffd830e":["3a3e0383956f06bd282a3e3aa2b353326e159802"],"3a3e0383956f06bd282a3e3aa2b353326e159802":["950882a2bd2a5f9dc16a154871584eaa643d882a"],"b470f36a9372c97283360b1304eacbde22df6c0d":["609beaebbd985152a9285cb621655acb0ffd830e","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796","bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"950882a2bd2a5f9dc16a154871584eaa643d882a":["7599427f762eb1b4265584fd6e96521e4a1a4f3c"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["609beaebbd985152a9285cb621655acb0ffd830e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["4f0befec2c0666a2f1879aaa34f396573a0216c4"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"7599427f762eb1b4265584fd6e96521e4a1a4f3c":["55980207f1977bd1463465de1659b821347e2fa8","950882a2bd2a5f9dc16a154871584eaa643d882a"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["cd4e13d997cf4fb810398a20a299c2c5a9f6b796"],"55980207f1977bd1463465de1659b821347e2fa8":[],"cd4e13d997cf4fb810398a20a299c2c5a9f6b796":["bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"5a207d19eac354d649c3f0e2cce070017c78125e":["4f0befec2c0666a2f1879aaa34f396573a0216c4"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"4f0befec2c0666a2f1879aaa34f396573a0216c4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bda0fc5c3d9b2f54f3539261daa7fe9c789bac5c":["7599427f762eb1b4265584fd6e96521e4a1a4f3c","55980207f1977bd1463465de1659b821347e2fa8","15e323346eac5e4685c0a9f2df85eb96b4239bbb"],"609beaebbd985152a9285cb621655acb0ffd830e":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"3a3e0383956f06bd282a3e3aa2b353326e159802":["609beaebbd985152a9285cb621655acb0ffd830e"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"15e323346eac5e4685c0a9f2df85eb96b4239bbb":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"950882a2bd2a5f9dc16a154871584eaa643d882a":["3a3e0383956f06bd282a3e3aa2b353326e159802"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["55980207f1977bd1463465de1659b821347e2fa8","1e6acbaae7af722f17204ceccf0f7db5753eccf3","15e323346eac5e4685c0a9f2df85eb96b4239bbb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}