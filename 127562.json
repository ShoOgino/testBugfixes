{"path":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","commits":[{"id":"2c007e7c4cf8c55bc2a5884e315123afaaeec87f","date":1327520966,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","date":1327523564,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d22ac6a4146774c1bc8400160fc0b6150294e92","date":1327528604,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"/dev/null","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1bea3922196318026c4274f2013416acb60c691e","date":1336496433,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3d7c0c8a97beb56d2e168604f9928de17981eabe","date":1357257676,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplay = (cmd.getFlags() & UpdateCommand.REPLAY) != 0;\n    boolean leaderLogic = isLeader && !isReplay;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f","date":1369845628,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.REPLAY)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da888af1ab894358122a22229051215f58cf4d54","date":1384408702,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3333dd7044501b4f20231ea55ab64e688285d153","date":1384785078,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(\"distrib.from.collection\") != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6c94d2661bc1c14426980ec7882e951fdcff08d0","date":1427167177,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86290366cefc1b9d4eced13b430858c4a4c0421d","date":1432321109,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  private boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","date":1471849333,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","date":1472163016,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"be320990bdc77e643388fa801e75017f19289c42","date":1489477067,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f996f8177b9204bdc92f7164460c6cefad9ac99a","date":1489482690,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ab68488225b6a6c357dda72ed11dedca9914a192","date":1490013111,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"61c45e99cf6676da48f19d7511c73712ad39402b","date":1495508331,"type":3,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (onlyLeaderIndexes && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"defa11d88d50ec356d5e7428f1ebc89623e840ac","date":1527653148,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = Hash.murmurhash3_x86_32(idBytes.bytes, idBytes.offset, idBytes.length, 0);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ffc8d70d9f57a62a24c3dd15b66e353de935054","date":1533178472,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d65446e37ead9e278d9fd19ba6ac154a512916ea","date":1544107016,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate);  // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate==0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n\n      synchronized (bucket) {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ( (signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0) || (signedVersionOnUpdate == 1 && foundVersion > 0) ) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\" + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update.  we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered.  We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      }  // end synchronized (bucket)\n\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a","date":1550036130,"type":3,"author":"Bruno P. Kinoshita","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occured.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9b3824fcbd3256db359391630ae05b3917ab369a","date":1556656304,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","pathOld":"solr/core/src/java/org/apache/solr/update/processor/DistributedUpdateProcessor#versionDelete(DeleteUpdateCommand).mjava","sourceNew":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    try {\n      long finalVersionOnUpdate = versionOnUpdate;\n      return bucket.runWithLock(vinfo.getVersionBucketLockTimeoutMs(), () -> doVersionDelete(cmd, finalVersionOnUpdate, signedVersionOnUpdate, isReplayOrPeersync, leaderLogic,\n          forwardedFromCollection, bucket));\n    } finally {\n      vinfo.unlockForUpdate();\n    }\n  }\n\n","sourceOld":"  protected boolean versionDelete(DeleteUpdateCommand cmd) throws IOException {\n\n    BytesRef idBytes = cmd.getIndexedId();\n\n    if (vinfo == null || idBytes == null) {\n      super.processDelete(cmd);\n      return false;\n    }\n\n    // This is only the hash for the bucket, and must be based only on the uniqueKey (i.e. do not use a pluggable hash\n    // here)\n    int bucketHash = bucketHash(idBytes);\n\n    // at this point, there is an update we need to try and apply.\n    // we may or may not be the leader.\n\n    // Find the version\n    long versionOnUpdate = cmd.getVersion();\n    if (versionOnUpdate == 0) {\n      String versionOnUpdateS = req.getParams().get(CommonParams.VERSION_FIELD);\n      versionOnUpdate = versionOnUpdateS == null ? 0 : Long.parseLong(versionOnUpdateS);\n    }\n    long signedVersionOnUpdate = versionOnUpdate;\n    versionOnUpdate = Math.abs(versionOnUpdate); // normalize to positive version\n\n    boolean isReplayOrPeersync = (cmd.getFlags() & (UpdateCommand.REPLAY | UpdateCommand.PEER_SYNC)) != 0;\n    boolean leaderLogic = isLeader && !isReplayOrPeersync;\n    boolean forwardedFromCollection = cmd.getReq().getParams().get(DISTRIB_FROM_COLLECTION) != null;\n\n    if (!leaderLogic && versionOnUpdate == 0) {\n      throw new SolrException(ErrorCode.BAD_REQUEST, \"missing _version_ on update from leader\");\n    }\n\n    VersionBucket bucket = vinfo.bucket(bucketHash);\n\n    vinfo.lockForUpdate();\n    if (bucket.tryLock()) {\n      try {\n        if (versionsStored) {\n          long bucketVersion = bucket.highest;\n\n          if (leaderLogic) {\n\n            if (forwardedFromCollection && ulog.getState() == UpdateLog.State.ACTIVE) {\n              // forwarded from a collection but we are not buffering so strip original version and apply our own\n              // see SOLR-5308\n              log.info(\"Removing version field from doc: \" + cmd.getId());\n              versionOnUpdate = signedVersionOnUpdate = 0;\n            }\n\n            // leaders can also be in buffering state during \"migrate\" API call, see SOLR-5308\n            if (forwardedFromCollection && ulog.getState() != UpdateLog.State.ACTIVE\n                && !isReplayOrPeersync) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              log.info(\"Leader logic applied but update log is buffering: \" + cmd.getId());\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            if (signedVersionOnUpdate != 0) {\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              long foundVersion = lastVersion == null ? -1 : lastVersion;\n              if ((signedVersionOnUpdate == foundVersion) || (signedVersionOnUpdate < 0 && foundVersion < 0)\n                  || (signedVersionOnUpdate == 1 && foundVersion > 0)) {\n                // we're ok if versions match, or if both are negative (all missing docs are equal), or if cmd\n                // specified it must exist (versionOnUpdate==1) and it does.\n              } else {\n                throw new SolrException(ErrorCode.CONFLICT, \"version conflict for \" + cmd.getId() + \" expected=\"\n                    + signedVersionOnUpdate + \" actual=\" + foundVersion);\n              }\n            }\n\n            long version = vinfo.getNewClock();\n            cmd.setVersion(-version);\n            bucket.updateHighest(version);\n          } else {\n            cmd.setVersion(-versionOnUpdate);\n\n            if (ulog.getState() != UpdateLog.State.ACTIVE && isReplayOrPeersync == false) {\n              // we're not in an active state, and this update isn't from a replay, so buffer it.\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.BUFFERING);\n              ulog.delete(cmd);\n              return true;\n            }\n\n            // if we aren't the leader, then we need to check that updates were not re-ordered\n            if (bucketVersion != 0 && bucketVersion < versionOnUpdate) {\n              // we're OK... this update has a version higher than anything we've seen\n              // in this bucket so far, so we know that no reordering has yet occurred.\n              bucket.updateHighest(versionOnUpdate);\n            } else {\n              // there have been updates higher than the current update. we need to check\n              // the specific version for this id.\n              Long lastVersion = vinfo.lookupVersion(cmd.getIndexedId());\n              if (lastVersion != null && Math.abs(lastVersion) >= versionOnUpdate) {\n                // This update is a repeat, or was reordered. We need to drop this update.\n                log.debug(\"Dropping delete update due to version {}\", idBytes.utf8ToString());\n                return true;\n              }\n            }\n\n            if (!isSubShardLeader && replicaType == Replica.Type.TLOG && (cmd.getFlags() & UpdateCommand.REPLAY) == 0) {\n              cmd.setFlags(cmd.getFlags() | UpdateCommand.IGNORE_INDEXWRITER);\n            }\n          }\n        }\n\n        doLocalDelete(cmd);\n        return false;\n      } finally {\n        bucket.unlock();\n        vinfo.unlockForUpdate();\n      }\n    } else {\n      throw new SolrException(SolrException.ErrorCode.SERVER_ERROR,\n          \"Unable to get version bucket lock in \" + bucket.getLockTimeoutMs() + \" ms\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["1bea3922196318026c4274f2013416acb60c691e","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"9b3824fcbd3256db359391630ae05b3917ab369a":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["3333dd7044501b4f20231ea55ab64e688285d153"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["1bea3922196318026c4274f2013416acb60c691e"],"1bea3922196318026c4274f2013416acb60c691e":["2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"e9017cf144952056066919f1ebc7897ff9bd71b1":["e5fa6615014cd2288fe930f8c8bb726f9504961d","61c45e99cf6676da48f19d7511c73712ad39402b"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["3333dd7044501b4f20231ea55ab64e688285d153","6c94d2661bc1c14426980ec7882e951fdcff08d0"],"0d22ac6a4146774c1bc8400160fc0b6150294e92":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["d65446e37ead9e278d9fd19ba6ac154a512916ea"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["86290366cefc1b9d4eced13b430858c4a4c0421d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"be320990bdc77e643388fa801e75017f19289c42":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["86290366cefc1b9d4eced13b430858c4a4c0421d","4c835cc1a7b07477a469cdb1bf6c67bc05b85c07"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["61c45e99cf6676da48f19d7511c73712ad39402b"],"61c45e99cf6676da48f19d7511c73712ad39402b":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["be320990bdc77e643388fa801e75017f19289c42"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"d65446e37ead9e278d9fd19ba6ac154a512916ea":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["86290366cefc1b9d4eced13b430858c4a4c0421d","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"da888af1ab894358122a22229051215f58cf4d54":["8a2f1187198fd8201881b815eea2fa3ba7b8ec5f"],"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f":["3d7c0c8a97beb56d2e168604f9928de17981eabe"],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["ab68488225b6a6c357dda72ed11dedca9914a192"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["6c94d2661bc1c14426980ec7882e951fdcff08d0"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["da888af1ab894358122a22229051215f58cf4d54","3333dd7044501b4f20231ea55ab64e688285d153"],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["defa11d88d50ec356d5e7428f1ebc89623e840ac"],"3333dd7044501b4f20231ea55ab64e688285d153":["da888af1ab894358122a22229051215f58cf4d54"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9b3824fcbd3256db359391630ae05b3917ab369a"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"9b3824fcbd3256db359391630ae05b3917ab369a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6c94d2661bc1c14426980ec7882e951fdcff08d0":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","86290366cefc1b9d4eced13b430858c4a4c0421d"],"3d7c0c8a97beb56d2e168604f9928de17981eabe":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","8a2f1187198fd8201881b815eea2fa3ba7b8ec5f"],"1bea3922196318026c4274f2013416acb60c691e":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","3d7c0c8a97beb56d2e168604f9928de17981eabe"],"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"0d22ac6a4146774c1bc8400160fc0b6150294e92":[],"d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a":["9b3824fcbd3256db359391630ae05b3917ab369a"],"4c835cc1a7b07477a469cdb1bf6c67bc05b85c07":["e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","2c007e7c4cf8c55bc2a5884e315123afaaeec87f"],"be320990bdc77e643388fa801e75017f19289c42":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"ab68488225b6a6c357dda72ed11dedca9914a192":["e5fa6615014cd2288fe930f8c8bb726f9504961d"],"e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a":["be320990bdc77e643388fa801e75017f19289c42","ab68488225b6a6c357dda72ed11dedca9914a192","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f996f8177b9204bdc92f7164460c6cefad9ac99a"],"61c45e99cf6676da48f19d7511c73712ad39402b":["e9017cf144952056066919f1ebc7897ff9bd71b1","defa11d88d50ec356d5e7428f1ebc89623e840ac"],"defa11d88d50ec356d5e7428f1ebc89623e840ac":["2ffc8d70d9f57a62a24c3dd15b66e353de935054"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["61c45e99cf6676da48f19d7511c73712ad39402b"],"a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d":[],"d65446e37ead9e278d9fd19ba6ac154a512916ea":["d669cb2b7fbc6ceb7f966e63a1c625e6400c7d2a"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"e5fa6615014cd2288fe930f8c8bb726f9504961d":["e9017cf144952056066919f1ebc7897ff9bd71b1"],"da888af1ab894358122a22229051215f58cf4d54":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","3333dd7044501b4f20231ea55ab64e688285d153"],"8a2f1187198fd8201881b815eea2fa3ba7b8ec5f":["da888af1ab894358122a22229051215f58cf4d54"],"86290366cefc1b9d4eced13b430858c4a4c0421d":["4c835cc1a7b07477a469cdb1bf6c67bc05b85c07","e1c5f7ce544a129550a8515f7f0eb5f1c0f4472a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"f996f8177b9204bdc92f7164460c6cefad9ac99a":["ab68488225b6a6c357dda72ed11dedca9914a192"],"2c007e7c4cf8c55bc2a5884e315123afaaeec87f":["1bea3922196318026c4274f2013416acb60c691e","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"2ffc8d70d9f57a62a24c3dd15b66e353de935054":["d65446e37ead9e278d9fd19ba6ac154a512916ea"],"3333dd7044501b4f20231ea55ab64e688285d153":["6c94d2661bc1c14426980ec7882e951fdcff08d0","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","e9017cf144952056066919f1ebc7897ff9bd71b1","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","0d22ac6a4146774c1bc8400160fc0b6150294e92","a3c68e20c73359a10cf3eb4a35c9fa7ab1f3c30d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}