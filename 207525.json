{"path":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxOverlapRatioValueSource#score(Rectangle,Explanation).mjava","commits":[{"id":"1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018","date":1404828935,"type":0,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxOverlapRatioValueSource#score(Rectangle,Explanation).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  protected double score(Rectangle target, Explanation exp) {\n    // calculate \"height\": the intersection height between two boxes.\n    double top = Math.min(queryExtent.getMaxY(), target.getMaxY());\n    double bottom = Math.max(queryExtent.getMinY(), target.getMinY());\n    double height = top - bottom;\n    if (height < 0)\n      return 0;//no intersection\n\n    // calculate \"width\": the intersection width between two boxes.\n    double width = 0;\n    {\n      Rectangle a = queryExtent;\n      Rectangle b = target;\n      if (a.getCrossesDateLine() == b.getCrossesDateLine()) {\n        //both either cross or don't\n        double left = Math.max(a.getMinX(), b.getMinX());\n        double right = Math.min(a.getMaxX(), b.getMaxX());\n        if (!a.getCrossesDateLine()) {//both don't\n          if (left <= right) {\n            width = right - left;\n          } else if (isGeo && (Math.abs(a.getMinX()) == 180 || Math.abs(a.getMaxX()) == 180)\n              && (Math.abs(b.getMinX()) == 180 || Math.abs(b.getMaxX()) == 180)) {\n            width = 0;//both adjacent to dateline\n          } else {\n            return 0;//no intersection\n          }\n        } else {//both cross\n          width = right - left + 360;\n        }\n      } else {\n        if (!a.getCrossesDateLine()) {//then flip\n          a = target;\n          b = queryExtent;\n        }\n        //a crosses, b doesn't\n        double qryWestLeft = Math.max(a.getMinX(), b.getMinX());\n        double qryWestRight = b.getMaxX();\n        if (qryWestLeft < qryWestRight)\n          width += qryWestRight - qryWestLeft;\n\n        double qryEastLeft = b.getMinX();\n        double qryEastRight = Math.min(a.getMaxX(), b.getMaxX());\n        if (qryEastLeft < qryEastRight)\n          width += qryEastRight - qryEastLeft;\n\n        if (qryWestLeft > qryWestRight && qryEastLeft > qryEastRight)\n          return 0;//no intersection\n      }\n    }\n\n    // calculate queryRatio and targetRatio\n    double intersectionArea = calcArea(width, height);\n    double queryRatio;\n    if (queryArea > 0) {\n      queryRatio = intersectionArea / queryArea;\n    } else if (queryExtent.getHeight() > 0) {//vert line\n      queryRatio = height / queryExtent.getHeight();\n    } else if (queryExtent.getWidth() > 0) {//horiz line\n      queryRatio = width / queryExtent.getWidth();\n    } else {\n      queryRatio = queryExtent.relate(target).intersects() ? 1 : 0;//could be optimized\n    }\n\n    double targetArea = calcArea(target.getWidth(), target.getHeight());\n    assert targetArea >= 0;\n    double targetRatio;\n    if (targetArea > 0) {\n      targetRatio = intersectionArea / targetArea;\n    } else if (target.getHeight() > 0) {//vert line\n      targetRatio = height / target.getHeight();\n    } else if (target.getWidth() > 0) {//horiz line\n      targetRatio = width / target.getWidth();\n    } else {\n      targetRatio = target.relate(queryExtent).intersects() ? 1 : 0;//could be optimized\n    }\n    assert queryRatio >= 0 && queryRatio <= 1 : queryRatio;\n    assert targetRatio >= 0 && targetRatio <= 1 : targetRatio;\n\n    // combine ratios into a score\n\n    double queryFactor = queryRatio * queryTargetProportion;\n    double targetFactor = targetRatio * (1.0 - queryTargetProportion);\n    double score = queryFactor + targetFactor;\n\n    if (exp!=null) {\n      exp.setValue((float)score);\n      exp.setDescription(this.getClass().getSimpleName()+\": queryFactor + targetFactor\");\n\n      Explanation e;//tmp\n\n      String minSideDesc = minSideLength > 0.0 ? \" (minSide=\"+minSideLength+\")\" : \"\";\n\n      exp.addDetail( e = new Explanation((float)intersectionArea, \"IntersectionArea\" + minSideDesc));\n      e.addDetail(new Explanation((float)width,  \"width\"));\n      e.addDetail(new Explanation((float)height, \"height\"));\n      e.addDetail(new Explanation((float)queryTargetProportion, \"queryTargetProportion\"));\n\n      exp.addDetail( e = new Explanation((float)queryFactor, \"queryFactor\"));\n      e.addDetail(new Explanation((float)queryRatio, \"ratio\"));\n      e.addDetail(new Explanation((float)queryArea,  \"area of \" + queryExtent + minSideDesc));\n\n      exp.addDetail( e = new Explanation((float)targetFactor, \"targetFactor\"));\n      e.addDetail(new Explanation((float)targetRatio, \"ratio\"));\n      e.addDetail(new Explanation((float)targetArea,  \"area of \" + target + minSideDesc));\n    }\n\n    return score;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91","date":1429620941,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxOverlapRatioValueSource#score(Rectangle,AtomicReference[Explanation]).mjava","pathOld":"lucene/spatial/src/java/org/apache/lucene/spatial/bbox/BBoxOverlapRatioValueSource#score(Rectangle,Explanation).mjava","sourceNew":"  @Override\n  protected double score(Rectangle target, AtomicReference<Explanation> exp) {\n    // calculate \"height\": the intersection height between two boxes.\n    double top = Math.min(queryExtent.getMaxY(), target.getMaxY());\n    double bottom = Math.max(queryExtent.getMinY(), target.getMinY());\n    double height = top - bottom;\n    if (height < 0)\n      return 0;//no intersection\n\n    // calculate \"width\": the intersection width between two boxes.\n    double width = 0;\n    {\n      Rectangle a = queryExtent;\n      Rectangle b = target;\n      if (a.getCrossesDateLine() == b.getCrossesDateLine()) {\n        //both either cross or don't\n        double left = Math.max(a.getMinX(), b.getMinX());\n        double right = Math.min(a.getMaxX(), b.getMaxX());\n        if (!a.getCrossesDateLine()) {//both don't\n          if (left <= right) {\n            width = right - left;\n          } else if (isGeo && (Math.abs(a.getMinX()) == 180 || Math.abs(a.getMaxX()) == 180)\n              && (Math.abs(b.getMinX()) == 180 || Math.abs(b.getMaxX()) == 180)) {\n            width = 0;//both adjacent to dateline\n          } else {\n            return 0;//no intersection\n          }\n        } else {//both cross\n          width = right - left + 360;\n        }\n      } else {\n        if (!a.getCrossesDateLine()) {//then flip\n          a = target;\n          b = queryExtent;\n        }\n        //a crosses, b doesn't\n        double qryWestLeft = Math.max(a.getMinX(), b.getMinX());\n        double qryWestRight = b.getMaxX();\n        if (qryWestLeft < qryWestRight)\n          width += qryWestRight - qryWestLeft;\n\n        double qryEastLeft = b.getMinX();\n        double qryEastRight = Math.min(a.getMaxX(), b.getMaxX());\n        if (qryEastLeft < qryEastRight)\n          width += qryEastRight - qryEastLeft;\n\n        if (qryWestLeft > qryWestRight && qryEastLeft > qryEastRight)\n          return 0;//no intersection\n      }\n    }\n\n    // calculate queryRatio and targetRatio\n    double intersectionArea = calcArea(width, height);\n    double queryRatio;\n    if (queryArea > 0) {\n      queryRatio = intersectionArea / queryArea;\n    } else if (queryExtent.getHeight() > 0) {//vert line\n      queryRatio = height / queryExtent.getHeight();\n    } else if (queryExtent.getWidth() > 0) {//horiz line\n      queryRatio = width / queryExtent.getWidth();\n    } else {\n      queryRatio = queryExtent.relate(target).intersects() ? 1 : 0;//could be optimized\n    }\n\n    double targetArea = calcArea(target.getWidth(), target.getHeight());\n    assert targetArea >= 0;\n    double targetRatio;\n    if (targetArea > 0) {\n      targetRatio = intersectionArea / targetArea;\n    } else if (target.getHeight() > 0) {//vert line\n      targetRatio = height / target.getHeight();\n    } else if (target.getWidth() > 0) {//horiz line\n      targetRatio = width / target.getWidth();\n    } else {\n      targetRatio = target.relate(queryExtent).intersects() ? 1 : 0;//could be optimized\n    }\n    assert queryRatio >= 0 && queryRatio <= 1 : queryRatio;\n    assert targetRatio >= 0 && targetRatio <= 1 : targetRatio;\n\n    // combine ratios into a score\n\n    double queryFactor = queryRatio * queryTargetProportion;\n    double targetFactor = targetRatio * (1.0 - queryTargetProportion);\n    double score = queryFactor + targetFactor;\n\n    if (exp!=null) {\n      String minSideDesc = minSideLength > 0.0 ? \" (minSide=\"+minSideLength+\")\" : \"\";\n      exp.set(Explanation.match((float) score,\n          this.getClass().getSimpleName()+\": queryFactor + targetFactor\",\n          Explanation.match((float)intersectionArea, \"IntersectionArea\" + minSideDesc,\n              Explanation.match((float)width, \"width\"),\n              Explanation.match((float)height, \"height\"),\n              Explanation.match((float)queryTargetProportion, \"queryTargetProportion\")),\n          Explanation.match((float)queryFactor, \"queryFactor\",\n              Explanation.match((float)targetRatio, \"ratio\"),\n              Explanation.match((float)queryArea,  \"area of \" + queryExtent + minSideDesc)),\n          Explanation.match((float)targetFactor, \"targetFactor\",\n              Explanation.match((float)targetRatio, \"ratio\"),\n              Explanation.match((float)targetArea,  \"area of \" + target + minSideDesc))));\n    }\n\n    return score;\n  }\n\n","sourceOld":"  @Override\n  protected double score(Rectangle target, Explanation exp) {\n    // calculate \"height\": the intersection height between two boxes.\n    double top = Math.min(queryExtent.getMaxY(), target.getMaxY());\n    double bottom = Math.max(queryExtent.getMinY(), target.getMinY());\n    double height = top - bottom;\n    if (height < 0)\n      return 0;//no intersection\n\n    // calculate \"width\": the intersection width between two boxes.\n    double width = 0;\n    {\n      Rectangle a = queryExtent;\n      Rectangle b = target;\n      if (a.getCrossesDateLine() == b.getCrossesDateLine()) {\n        //both either cross or don't\n        double left = Math.max(a.getMinX(), b.getMinX());\n        double right = Math.min(a.getMaxX(), b.getMaxX());\n        if (!a.getCrossesDateLine()) {//both don't\n          if (left <= right) {\n            width = right - left;\n          } else if (isGeo && (Math.abs(a.getMinX()) == 180 || Math.abs(a.getMaxX()) == 180)\n              && (Math.abs(b.getMinX()) == 180 || Math.abs(b.getMaxX()) == 180)) {\n            width = 0;//both adjacent to dateline\n          } else {\n            return 0;//no intersection\n          }\n        } else {//both cross\n          width = right - left + 360;\n        }\n      } else {\n        if (!a.getCrossesDateLine()) {//then flip\n          a = target;\n          b = queryExtent;\n        }\n        //a crosses, b doesn't\n        double qryWestLeft = Math.max(a.getMinX(), b.getMinX());\n        double qryWestRight = b.getMaxX();\n        if (qryWestLeft < qryWestRight)\n          width += qryWestRight - qryWestLeft;\n\n        double qryEastLeft = b.getMinX();\n        double qryEastRight = Math.min(a.getMaxX(), b.getMaxX());\n        if (qryEastLeft < qryEastRight)\n          width += qryEastRight - qryEastLeft;\n\n        if (qryWestLeft > qryWestRight && qryEastLeft > qryEastRight)\n          return 0;//no intersection\n      }\n    }\n\n    // calculate queryRatio and targetRatio\n    double intersectionArea = calcArea(width, height);\n    double queryRatio;\n    if (queryArea > 0) {\n      queryRatio = intersectionArea / queryArea;\n    } else if (queryExtent.getHeight() > 0) {//vert line\n      queryRatio = height / queryExtent.getHeight();\n    } else if (queryExtent.getWidth() > 0) {//horiz line\n      queryRatio = width / queryExtent.getWidth();\n    } else {\n      queryRatio = queryExtent.relate(target).intersects() ? 1 : 0;//could be optimized\n    }\n\n    double targetArea = calcArea(target.getWidth(), target.getHeight());\n    assert targetArea >= 0;\n    double targetRatio;\n    if (targetArea > 0) {\n      targetRatio = intersectionArea / targetArea;\n    } else if (target.getHeight() > 0) {//vert line\n      targetRatio = height / target.getHeight();\n    } else if (target.getWidth() > 0) {//horiz line\n      targetRatio = width / target.getWidth();\n    } else {\n      targetRatio = target.relate(queryExtent).intersects() ? 1 : 0;//could be optimized\n    }\n    assert queryRatio >= 0 && queryRatio <= 1 : queryRatio;\n    assert targetRatio >= 0 && targetRatio <= 1 : targetRatio;\n\n    // combine ratios into a score\n\n    double queryFactor = queryRatio * queryTargetProportion;\n    double targetFactor = targetRatio * (1.0 - queryTargetProportion);\n    double score = queryFactor + targetFactor;\n\n    if (exp!=null) {\n      exp.setValue((float)score);\n      exp.setDescription(this.getClass().getSimpleName()+\": queryFactor + targetFactor\");\n\n      Explanation e;//tmp\n\n      String minSideDesc = minSideLength > 0.0 ? \" (minSide=\"+minSideLength+\")\" : \"\";\n\n      exp.addDetail( e = new Explanation((float)intersectionArea, \"IntersectionArea\" + minSideDesc));\n      e.addDetail(new Explanation((float)width,  \"width\"));\n      e.addDetail(new Explanation((float)height, \"height\"));\n      e.addDetail(new Explanation((float)queryTargetProportion, \"queryTargetProportion\"));\n\n      exp.addDetail( e = new Explanation((float)queryFactor, \"queryFactor\"));\n      e.addDetail(new Explanation((float)queryRatio, \"ratio\"));\n      e.addDetail(new Explanation((float)queryArea,  \"area of \" + queryExtent + minSideDesc));\n\n      exp.addDetail( e = new Explanation((float)targetFactor, \"targetFactor\"));\n      e.addDetail(new Explanation((float)targetRatio, \"ratio\"));\n      e.addDetail(new Explanation((float)targetArea,  \"area of \" + target + minSideDesc));\n    }\n\n    return score;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018"],"1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018"],"ff3285c7b2387faedef0ffb24db20c4cbbd9fd91":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1eb9cd4e9d9dc2a301efb4dc420fcb069a9dd018":["ff3285c7b2387faedef0ffb24db20c4cbbd9fd91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}