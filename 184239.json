{"path":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","commits":[{"id":"e87998750c1408b8af3248e55cff794d51d37166","date":1501426220,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"/dev/null","sourceNew":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n    solrClient.getZkStateReader().registerCore(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"/dev/null","sourceNew":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n    solrClient.getZkStateReader().registerCore(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4","date":1509452916,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","sourceNew":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n    solrClient.getZkStateReader().registerCore(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"751e212ed6f8a4a43b591e4d6cd4637d15a4219a","date":1530638837,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","sourceNew":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","sourceNew":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","sourceNew":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(SolrRequest.METHOD.POST, \"/config\", addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","sourceNew":"  @Test\n  public void testPeersyncFailureReplicationSuccess() throws Exception {\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName()).setMaxShardsPerNode(2);\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    \n    cluster.waitForJettyToStop(oldNode);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":"  public void testPeersyncFailureReplicationSuccess() throws Exception {\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","bugFix":["e87998750c1408b8af3248e55cff794d51d37166"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e","date":1594223844,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/TestCloudSearcherWarming#testPeersyncFailureReplicationSuccess().mjava","sourceNew":"  @Test\n  public void testPeersyncFailureReplicationSuccess() throws Exception {\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName());\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    \n    cluster.waitForJettyToStop(oldNode);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","sourceOld":"  @Test\n  public void testPeersyncFailureReplicationSuccess() throws Exception {\n\n    CloudSolrClient solrClient = cluster.getSolrClient();\n\n    String collectionName = \"testPeersyncFailureReplicationSuccess\";\n    CollectionAdminRequest.Create create = CollectionAdminRequest.createCollection(collectionName, 1, 1)\n        .setCreateNodeSet(cluster.getJettySolrRunner(0).getNodeName()).setMaxShardsPerNode(2);\n    create.process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n\n    solrClient.setDefaultCollection(collectionName);\n\n    String addListenerCommand = \"{\" +\n        \"'add-listener' : {'name':'newSearcherListener','event':'newSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"'add-listener' : {'name':'firstSearcherListener','event':'firstSearcher', 'class':'\" + SleepingSolrEventListener.class.getName() + \"'}\" +\n        \"}\";\n\n    ConfigRequest request = new ConfigRequest(addListenerCommand);\n    solrClient.request(request);\n\n    solrClient.add(new SolrInputDocument(\"id\", \"1\"));\n    solrClient.commit();\n\n    AtomicInteger expectedDocs = new AtomicInteger(1);\n    AtomicReference<String> failingCoreNodeName = new AtomicReference<>();\n\n    QueryResponse response = solrClient.query(new SolrQuery(\"*:*\"));\n    assertEquals(1, response.getResults().getNumFound());\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    CollectionStateWatcher stateWatcher = createActiveReplicaSearcherWatcher(expectedDocs, failingCoreNodeName);\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n\n    JettySolrRunner newNode = cluster.startJettySolrRunner();\n    cluster.waitForAllNodes(30);\n    CollectionAdminRequest.addReplicaToShard(collectionName, \"shard1\")\n        .setNode(newNode.getNodeName())\n        .process(solrClient);\n\n    waitForState(\"The collection should have 1 shard and 2 replica\", collectionName, clusterShape(1, 2));\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    // stop the old node\n    log.info(\"Stopping old node 1\");\n    AtomicReference<String> oldNodeName = new AtomicReference<>(cluster.getJettySolrRunner(0).getNodeName());\n    JettySolrRunner oldNode = cluster.stopJettySolrRunner(0);\n    \n    cluster.waitForJettyToStop(oldNode);\n    // the newly created replica should become leader\n    waitForState(\"The collection should have 1 shard and 1 replica\", collectionName, clusterShape(1, 1));\n    // the above call is not enough because we want to assert that the down'ed replica is not active\n    // but clusterShape will also return true if replica is not live -- which we don't want\n    CollectionStatePredicate collectionStatePredicate = (liveNodes, collectionState) -> {\n      for (Replica r : collectionState.getReplicas()) {\n        if (r.getNodeName().equals(oldNodeName.get())) {\n          return r.getState() == Replica.State.DOWN;\n        }\n      }\n      return false;\n    };\n    waitForState(\"\", collectionName, collectionStatePredicate);\n    assertNotNull(solrClient.getZkStateReader().getLeaderRetry(collectionName, \"shard1\"));\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(5000);\n\n    // inject wrong signature output\n    TestInjection.wrongIndexFingerprint = \"true:100\";\n    // now lets restart the old node\n    log.info(\"Starting old node 1\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n\n    oldNodeName.set(cluster.getJettySolrRunner(1).getNodeName());\n    assertSame(oldNode, cluster.stopJettySolrRunner(1)); // old node is now at 1\n    log.info(\"Stopping old node 2\");\n    waitForState(\"\", collectionName, clusterShape(1, 1));\n    waitForState(\"\", collectionName, collectionStatePredicate);\n\n    // reset\n    coreNameRef.set(null);\n    coreNodeNameRef.set(null);\n    failingCoreNodeName.set(null);\n    sleepTime.set(14000);  // has to be higher than the twice the recovery wait pause between attempts plus some margin\n\n    // inject failure\n    TestInjection.failIndexFingerprintRequests = \"true:100\";\n    // now lets restart the old node again\n    log.info(\"Starting old node 2\");\n    cluster.startJettySolrRunner(oldNode);\n    waitForState(\"\", collectionName, clusterShape(1, 2));\n    // invoke statewatcher explicitly to avoid race condition where the assert happens before the state watcher is invoked by ZkStateReader\n    cluster.getSolrClient().getZkStateReader().registerCollectionStateWatcher(collectionName, stateWatcher);\n    assertNull(\"No replica should have been active without registering a searcher, found: \" + failingCoreNodeName.get(), failingCoreNodeName.get());\n    cluster.getSolrClient().getZkStateReader().removeCollectionStateWatcher(collectionName, stateWatcher);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4","751e212ed6f8a4a43b591e4d6cd4637d15a4219a"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e87998750c1408b8af3248e55cff794d51d37166"],"751e212ed6f8a4a43b591e4d6cd4637d15a4219a":["06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["751e212ed6f8a4a43b591e4d6cd4637d15a4219a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4":["e87998750c1408b8af3248e55cff794d51d37166"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"e87998750c1408b8af3248e55cff794d51d37166":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4","751e212ed6f8a4a43b591e4d6cd4637d15a4219a"]},"commit2Childs":{"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"751e212ed6f8a4a43b591e4d6cd4637d15a4219a":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["e46a76bb135597b8bf35930cfdb3702bdd1cbe6e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","e87998750c1408b8af3248e55cff794d51d37166"],"06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","751e212ed6f8a4a43b591e4d6cd4637d15a4219a","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e46a76bb135597b8bf35930cfdb3702bdd1cbe6e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e87998750c1408b8af3248e55cff794d51d37166":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","06a8aa646edc93b6f7e76ded12e41f1e6c04e7c4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}