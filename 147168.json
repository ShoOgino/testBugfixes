{"path":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","commits":[{"id":"1b73cddaec09172a09da82e758d0014ab8810ffa","date":1506898255,"type":0,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","pathOld":"/dev/null","sourceNew":"  public static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    LOOP_OVER_CELLS: while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          for (int d = 0, offset = 0; d < visitor.dims; ++d, offset += Float.BYTES) {\n            float cellMaxAtDim = FloatPoint.decodeDimension(cell.maxPacked, offset);\n            float cellMinAtDim = FloatPoint.decodeDimension(cell.minPacked, offset);\n            if (cellMaxAtDim < visitor.min[d] || cellMinAtDim > visitor.max[d]) {\n              // this cell is outside our search radius; don't bother exploring any more\n\n              // if (cellMaxAtDim < visitor.min[d]) {\n              //   System.out.println(\"  skipped because cell max at \" + d + \" (\" + cellMaxAtDim + \") < visitor.min[\" + d + \"] (\" + visitor.min[d] + \")\");\n              // } else {\n              //   System.out.println(\"  skipped because cell min at \" + d + \" (\" + cellMinAtDim + \") > visitor.max[\" + d + \"] (\" + visitor.max[d] + \")\");\n              // }\n\n              continue LOOP_OVER_CELLS;\n            }\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b3aee87d499a8cb069ff95d7798e4914cd9ed18","date":1506955171,"type":3,"author":"Steve Rowe","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","sourceNew":"  private static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    LOOP_OVER_CELLS: while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          for (int d = 0, offset = 0; d < visitor.dims; ++d, offset += Float.BYTES) {\n            float cellMaxAtDim = FloatPoint.decodeDimension(cell.maxPacked, offset);\n            float cellMinAtDim = FloatPoint.decodeDimension(cell.minPacked, offset);\n            if (cellMaxAtDim < visitor.min[d] || cellMinAtDim > visitor.max[d]) {\n              // this cell is outside our search radius; don't bother exploring any more\n\n              // if (cellMaxAtDim < visitor.min[d]) {\n              //   System.out.println(\"  skipped because cell max at \" + d + \" (\" + cellMaxAtDim + \") < visitor.min[\" + d + \"] (\" + visitor.min[d] + \")\");\n              // } else {\n              //   System.out.println(\"  skipped because cell min at \" + d + \" (\" + cellMinAtDim + \") > visitor.max[\" + d + \"] (\" + visitor.max[d] + \")\");\n              // }\n\n              continue LOOP_OVER_CELLS;\n            }\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","sourceOld":"  public static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    LOOP_OVER_CELLS: while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          for (int d = 0, offset = 0; d < visitor.dims; ++d, offset += Float.BYTES) {\n            float cellMaxAtDim = FloatPoint.decodeDimension(cell.maxPacked, offset);\n            float cellMinAtDim = FloatPoint.decodeDimension(cell.minPacked, offset);\n            if (cellMaxAtDim < visitor.min[d] || cellMinAtDim > visitor.max[d]) {\n              // this cell is outside our search radius; don't bother exploring any more\n\n              // if (cellMaxAtDim < visitor.min[d]) {\n              //   System.out.println(\"  skipped because cell max at \" + d + \" (\" + cellMaxAtDim + \") < visitor.min[\" + d + \"] (\" + visitor.min[d] + \")\");\n              // } else {\n              //   System.out.println(\"  skipped because cell min at \" + d + \" (\" + cellMinAtDim + \") > visitor.max[\" + d + \"] (\" + visitor.max[d] + \")\");\n              // }\n\n              continue LOOP_OVER_CELLS;\n            }\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6240b74b884c5587f2a4062dd27d6c32bf228889","date":1507037235,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","pathOld":"/dev/null","sourceNew":"  private static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    LOOP_OVER_CELLS: while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          for (int d = 0, offset = 0; d < visitor.dims; ++d, offset += Float.BYTES) {\n            float cellMaxAtDim = FloatPoint.decodeDimension(cell.maxPacked, offset);\n            float cellMinAtDim = FloatPoint.decodeDimension(cell.minPacked, offset);\n            if (cellMaxAtDim < visitor.min[d] || cellMinAtDim > visitor.max[d]) {\n              // this cell is outside our search radius; don't bother exploring any more\n\n              // if (cellMaxAtDim < visitor.min[d]) {\n              //   System.out.println(\"  skipped because cell max at \" + d + \" (\" + cellMaxAtDim + \") < visitor.min[\" + d + \"] (\" + visitor.min[d] + \")\");\n              // } else {\n              //   System.out.println(\"  skipped because cell min at \" + d + \" (\" + cellMinAtDim + \") > visitor.max[\" + d + \"] (\" + visitor.max[d] + \")\");\n              // }\n\n              continue LOOP_OVER_CELLS;\n            }\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c02a05a5f298f87e1dbbb280827b9d165b796f55","date":1563365657,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","sourceNew":"  private static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          if (visitor.compare(cell.minPacked, cell.maxPacked) == PointValues.Relation.CELL_OUTSIDE_QUERY) {\n            // this cell is outside our search radius; don't bother exploring any more\n            continue;\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","sourceOld":"  private static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    LOOP_OVER_CELLS: while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          for (int d = 0, offset = 0; d < visitor.dims; ++d, offset += Float.BYTES) {\n            float cellMaxAtDim = FloatPoint.decodeDimension(cell.maxPacked, offset);\n            float cellMinAtDim = FloatPoint.decodeDimension(cell.minPacked, offset);\n            if (cellMaxAtDim < visitor.min[d] || cellMinAtDim > visitor.max[d]) {\n              // this cell is outside our search radius; don't bother exploring any more\n\n              // if (cellMaxAtDim < visitor.min[d]) {\n              //   System.out.println(\"  skipped because cell max at \" + d + \" (\" + cellMaxAtDim + \") < visitor.min[\" + d + \"] (\" + visitor.min[d] + \")\");\n              // } else {\n              //   System.out.println(\"  skipped because cell min at \" + d + \" (\" + cellMinAtDim + \") > visitor.max[\" + d + \"] (\" + visitor.max[d] + \")\");\n              // }\n\n              continue LOOP_OVER_CELLS;\n            }\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"097748fa4ff327a26994476115f52d1a899b549f","date":1568267320,"type":3,"author":"Ignacio Vera","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/document/FloatPointNearestNeighbor#nearest(List[BKDReader],List[Bits],List[Integer],int,float[]).mjava","sourceNew":"  private static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          pointToRectangleDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      if (cell.distanceSquared > visitor.bottomNearestDistanceSquared) {\n        break;\n      }\n\n      BKDReader reader = readers.get(cell.readerIndex);\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n\n        //assert hitQueue.peek().distanceSquared >= cell.distanceSquared;\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        double distanceLeft = pointToRectangleDistanceSquared(cell.minPacked, splitPackedValue, origin);\n        if (distanceLeft <= visitor.bottomNearestDistanceSquared) {\n          cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue, distanceLeft));\n        }\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        double distanceRight = pointToRectangleDistanceSquared(splitPackedValue, cell.maxPacked, origin);\n        if (distanceRight <= visitor.bottomNearestDistanceSquared) {\n          cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked, distanceRight));\n        }\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    //System.out.println(visitor.comp);\n    return hits;\n  }\n\n","sourceOld":"  private static NearestHit[] nearest(List<BKDReader> readers, List<Bits> liveDocs, List<Integer> docBases, final int topN, float[] origin) throws IOException {\n\n    // System.out.println(\"NEAREST: readers=\" + readers + \" liveDocs=\" + liveDocs + \" origin: \" + Arrays.toString(origin));\n\n    // Holds closest collected points seen so far:\n    // TODO: if we used lucene's PQ we could just updateTop instead of poll/offer:\n    final PriorityQueue<NearestHit> hitQueue = new PriorityQueue<>(topN, (a, b) -> {\n      // sort by opposite distance natural order\n      int cmp = Double.compare(a.distanceSquared, b.distanceSquared);\n      return cmp != 0 ? -cmp : b.docID - a.docID; // tie-break by higher docID\n    });\n\n    // Holds all cells, sorted by closest to the point:\n    PriorityQueue<Cell> cellQueue = new PriorityQueue<>();\n\n    NearestVisitor visitor = new NearestVisitor(hitQueue, topN, origin);\n    List<BKDReader.IntersectState> states = new ArrayList<>();\n\n    // Add root cell for each reader into the queue:\n    int bytesPerDim = -1;\n\n    for (int i = 0 ; i < readers.size() ; ++i) {\n      BKDReader reader = readers.get(i);\n      if (bytesPerDim == -1) {\n        bytesPerDim = reader.getBytesPerDimension();\n      } else if (bytesPerDim != reader.getBytesPerDimension()) {\n        throw new IllegalStateException(\"bytesPerDim changed from \" + bytesPerDim\n            + \" to \" + reader.getBytesPerDimension() + \" across readers\");\n      }\n      byte[] minPackedValue = reader.getMinPackedValue();\n      byte[] maxPackedValue = reader.getMaxPackedValue();\n      BKDReader.IntersectState state = reader.getIntersectState(visitor);\n      states.add(state);\n\n      cellQueue.offer(new Cell(state.index, i, reader.getMinPackedValue(), reader.getMaxPackedValue(),\n          approxBestDistanceSquared(minPackedValue, maxPackedValue, origin)));\n    }\n\n    while (cellQueue.size() > 0) {\n      Cell cell = cellQueue.poll();\n      // System.out.println(\"  visit \" + cell);\n\n      // TODO: if we replace approxBestDistance with actualBestDistance, we can put an opto here to break once this \"best\" cell is fully outside of the hitQueue bottom's radius:\n      BKDReader reader = readers.get(cell.readerIndex);\n\n      if (cell.index.isLeafNode()) {\n        // System.out.println(\"    leaf\");\n        // Leaf block: visit all points and possibly collect them:\n        visitor.curDocBase = docBases.get(cell.readerIndex);\n        visitor.curLiveDocs = liveDocs.get(cell.readerIndex);\n        reader.visitLeafBlockValues(cell.index, states.get(cell.readerIndex));\n        // System.out.println(\"    now \" + hitQueue.size() + \" hits\");\n      } else {\n        // System.out.println(\"    non-leaf\");\n        // Non-leaf block: split into two cells and put them back into the queue:\n\n        if (hitQueue.size() == topN) {\n          if (visitor.compare(cell.minPacked, cell.maxPacked) == PointValues.Relation.CELL_OUTSIDE_QUERY) {\n            // this cell is outside our search radius; don't bother exploring any more\n            continue;\n          }\n        }\n        BytesRef splitValue = BytesRef.deepCopyOf(cell.index.getSplitDimValue());\n        int splitDim = cell.index.getSplitDim();\n\n        // we must clone the index so that we we can recurse left and right \"concurrently\":\n        BKDReader.IndexTree newIndex = cell.index.clone();\n        byte[] splitPackedValue = cell.maxPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        cell.index.pushLeft();\n        cellQueue.offer(new Cell(cell.index, cell.readerIndex, cell.minPacked, splitPackedValue,\n            approxBestDistanceSquared(cell.minPacked, splitPackedValue, origin)));\n\n        splitPackedValue = cell.minPacked.clone();\n        System.arraycopy(splitValue.bytes, splitValue.offset, splitPackedValue, splitDim * bytesPerDim, bytesPerDim);\n\n        newIndex.pushRight();\n        cellQueue.offer(new Cell(newIndex, cell.readerIndex, splitPackedValue, cell.maxPacked,\n            approxBestDistanceSquared(splitPackedValue, cell.maxPacked, origin)));\n      }\n    }\n\n    NearestHit[] hits = new NearestHit[hitQueue.size()];\n    int downTo = hitQueue.size()-1;\n    while (hitQueue.size() != 0) {\n      hits[downTo] = hitQueue.poll();\n      downTo--;\n    }\n    return hits;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6b3aee87d499a8cb069ff95d7798e4914cd9ed18":["1b73cddaec09172a09da82e758d0014ab8810ffa"],"1b73cddaec09172a09da82e758d0014ab8810ffa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6240b74b884c5587f2a4062dd27d6c32bf228889":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6b3aee87d499a8cb069ff95d7798e4914cd9ed18"],"097748fa4ff327a26994476115f52d1a899b549f":["c02a05a5f298f87e1dbbb280827b9d165b796f55"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["097748fa4ff327a26994476115f52d1a899b549f"],"c02a05a5f298f87e1dbbb280827b9d165b796f55":["6b3aee87d499a8cb069ff95d7798e4914cd9ed18"]},"commit2Childs":{"6b3aee87d499a8cb069ff95d7798e4914cd9ed18":["6240b74b884c5587f2a4062dd27d6c32bf228889","c02a05a5f298f87e1dbbb280827b9d165b796f55"],"1b73cddaec09172a09da82e758d0014ab8810ffa":["6b3aee87d499a8cb069ff95d7798e4914cd9ed18"],"6240b74b884c5587f2a4062dd27d6c32bf228889":[],"097748fa4ff327a26994476115f52d1a899b549f":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1b73cddaec09172a09da82e758d0014ab8810ffa","6240b74b884c5587f2a4062dd27d6c32bf228889"],"c02a05a5f298f87e1dbbb280827b9d165b796f55":["097748fa4ff327a26994476115f52d1a899b549f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["6240b74b884c5587f2a4062dd27d6c32bf228889","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}