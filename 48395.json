{"path":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","commits":[{"id":"03d1c7f08294f7d7e9ecf082aa1459f38d77f277","date":1493688929,"type":0,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","pathOld":"/dev/null","sourceNew":"  public static PayloadDecoder getPayloadDecoder(FieldType fieldType) {\n    PayloadDecoder decoder = Similarity.SimScorer::computePayloadFactor;  // default to SimScorer's\n\n    String encoder = getPayloadEncoder(fieldType);\n\n    if (\"integer\".equals(encoder)) {\n      decoder = (Similarity.SimScorer simScorer, int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeInt(payload.bytes, payload.offset);\n    }\n    if (\"float\".equals(encoder)) {\n      decoder = (Similarity.SimScorer simScorer, int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeFloat(payload.bytes, payload.offset);\n    }\n    // encoder could be \"identity\" at this point, in the case of DelimitedTokenFilterFactory encoder=\"identity\"\n\n    // TODO: support pluggable payload decoders?\n\n    return decoder;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23c0f0de44c893e0d072b4c26fc99206ce26687c","date":1493725812,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","sourceNew":"  public static PayloadDecoder getPayloadDecoder(FieldType fieldType) {\n    PayloadDecoder decoder = null;\n\n    String encoder = getPayloadEncoder(fieldType);\n\n    if (\"integer\".equals(encoder)) {\n      decoder = (int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeInt(payload.bytes, payload.offset);\n    }\n    if (\"float\".equals(encoder)) {\n      decoder = (int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeFloat(payload.bytes, payload.offset);\n    }\n    // encoder could be \"identity\" at this point, in the case of DelimitedTokenFilterFactory encoder=\"identity\"\n\n    // TODO: support pluggable payload decoders?\n\n    return decoder;\n  }\n\n","sourceOld":"  public static PayloadDecoder getPayloadDecoder(FieldType fieldType) {\n    PayloadDecoder decoder = Similarity.SimScorer::computePayloadFactor;  // default to SimScorer's\n\n    String encoder = getPayloadEncoder(fieldType);\n\n    if (\"integer\".equals(encoder)) {\n      decoder = (Similarity.SimScorer simScorer, int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeInt(payload.bytes, payload.offset);\n    }\n    if (\"float\".equals(encoder)) {\n      decoder = (Similarity.SimScorer simScorer, int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeFloat(payload.bytes, payload.offset);\n    }\n    // encoder could be \"identity\" at this point, in the case of DelimitedTokenFilterFactory encoder=\"identity\"\n\n    // TODO: support pluggable payload decoders?\n\n    return decoder;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9017cf144952056066919f1ebc7897ff9bd71b1","date":1496757600,"type":0,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","pathOld":"/dev/null","sourceNew":"  public static PayloadDecoder getPayloadDecoder(FieldType fieldType) {\n    PayloadDecoder decoder = null;\n\n    String encoder = getPayloadEncoder(fieldType);\n\n    if (\"integer\".equals(encoder)) {\n      decoder = (int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeInt(payload.bytes, payload.offset);\n    }\n    if (\"float\".equals(encoder)) {\n      decoder = (int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeFloat(payload.bytes, payload.offset);\n    }\n    // encoder could be \"identity\" at this point, in the case of DelimitedTokenFilterFactory encoder=\"identity\"\n\n    // TODO: support pluggable payload decoders?\n\n    return decoder;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"340d2a56d051f2e4d6d9c707e2d5614d3d81adf8","date":1510236334,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","pathOld":"solr/core/src/java/org/apache/solr/util/PayloadUtils#getPayloadDecoder(FieldType).mjava","sourceNew":"  public static PayloadDecoder getPayloadDecoder(FieldType fieldType) {\n    PayloadDecoder decoder = null;\n\n    String encoder = getPayloadEncoder(fieldType);\n\n    if (\"integer\".equals(encoder)) {\n      decoder = (BytesRef payload) -> payload == null ? 1 : PayloadHelper.decodeInt(payload.bytes, payload.offset);\n    }\n    if (\"float\".equals(encoder)) {\n      decoder = (BytesRef payload) -> payload == null ? 1 : PayloadHelper.decodeFloat(payload.bytes, payload.offset);\n    }\n    // encoder could be \"identity\" at this point, in the case of DelimitedTokenFilterFactory encoder=\"identity\"\n\n    // TODO: support pluggable payload decoders?\n\n    return decoder;\n  }\n\n","sourceOld":"  public static PayloadDecoder getPayloadDecoder(FieldType fieldType) {\n    PayloadDecoder decoder = null;\n\n    String encoder = getPayloadEncoder(fieldType);\n\n    if (\"integer\".equals(encoder)) {\n      decoder = (int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeInt(payload.bytes, payload.offset);\n    }\n    if (\"float\".equals(encoder)) {\n      decoder = (int doc, int start, int end, BytesRef payload) -> PayloadHelper.decodeFloat(payload.bytes, payload.offset);\n    }\n    // encoder could be \"identity\" at this point, in the case of DelimitedTokenFilterFactory encoder=\"identity\"\n\n    // TODO: support pluggable payload decoders?\n\n    return decoder;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e9017cf144952056066919f1ebc7897ff9bd71b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","23c0f0de44c893e0d072b4c26fc99206ce26687c"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"340d2a56d051f2e4d6d9c707e2d5614d3d81adf8":["23c0f0de44c893e0d072b4c26fc99206ce26687c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["340d2a56d051f2e4d6d9c707e2d5614d3d81adf8"],"23c0f0de44c893e0d072b4c26fc99206ce26687c":["03d1c7f08294f7d7e9ecf082aa1459f38d77f277"],"03d1c7f08294f7d7e9ecf082aa1459f38d77f277":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"e9017cf144952056066919f1ebc7897ff9bd71b1":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e9017cf144952056066919f1ebc7897ff9bd71b1","03d1c7f08294f7d7e9ecf082aa1459f38d77f277"],"340d2a56d051f2e4d6d9c707e2d5614d3d81adf8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"23c0f0de44c893e0d072b4c26fc99206ce26687c":["e9017cf144952056066919f1ebc7897ff9bd71b1","340d2a56d051f2e4d6d9c707e2d5614d3d81adf8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"03d1c7f08294f7d7e9ecf082aa1459f38d77f277":["23c0f0de44c893e0d072b4c26fc99206ce26687c"]},"heads":["e9017cf144952056066919f1ebc7897ff9bd71b1","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}