{"path":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#dontProxyFor(String).mjava","commits":[{"id":"bc6055f4a2e8e9f9caaec2297010c9502480ed69","date":1050060580,"type":0,"author":"cmarschner","isMerge":false,"pathNew":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#dontProxyFor(String).mjava","pathOld":"/dev/null","sourceNew":"    /**\n     * Add <var>host</var> to the list of hosts which should be accessed\n     * directly, not via any proxy set by <code>setProxyServer()</code>. <P>\n     *\n     * The <var>host</var> may be any of:\n     * <UL>\n     *   <LI> a complete host name (e.g. \"www.disney.com\")\n     *   <LI> a domain name; domain names must begin with a dot (e.g.\n     *   \".disney.com\")\n     *   <LI> an IP-address (e.g. \"12.34.56.78\")\n     *   <LI> an IP-subnet, specified as an IP-address and a netmask separated\n     *   by a \"/\" (e.g. \"34.56.78/255.255.255.192\"); a 0 bit in the netmask\n     *   means that that bit won't be used in the comparison (i.e. the addresses\n     *   are AND'ed with the netmask before comparison).\n     * </UL>\n     * <P>\n     *\n     * The two properties <var>HTTPClient.nonProxyHosts</var> and <var>\n     * http.nonProxyHosts</var> are used when this class is loaded to initialize\n     * the list of non-proxy hosts. The second property is only read if the\n     * first one is not set; the second property is also used the JDK's\n     * URLConnection. These properties must contain a \"|\" separated list of\n     * entries which conform to the above rules for the <var>host</var>\n     * parameter (e.g. \"11.22.33.44|.disney.com\").\n     *\n     * @param host                a host name, domain name, IP-address or\n     *      IP-subnet.\n     * @exception ParseException  if the length of the netmask does not match\n     *      the length of the IP-address\n     */\n    public static void dontProxyFor(String host)\n        throws ParseException\n    {\n        host = host.trim().toLowerCase();\n\n        // check for domain name\n\n        if (host.charAt(0) == '.')\n        {\n            if (!non_proxy_dom_list.contains(host))\n            {\n                non_proxy_dom_list.addElement(host);\n            }\n            return;\n        }\n\n        // check for host name\n\n        for (int idx = 0; idx < host.length(); idx++)\n        {\n            if (!Character.isDigit(host.charAt(idx)) &&\n                    host.charAt(idx) != '.' && host.charAt(idx) != '/')\n            {\n                non_proxy_host_list.put(host, \"\");\n                return;\n            }\n        }\n\n        // must be an IP-address\n\n        byte[] ip_addr;\n        byte[] ip_mask;\n        int slash;\n        if ((slash = host.indexOf('/')) != -1)\n        {\n            // IP subnet\n\n            ip_addr = string2arr(host.substring(0, slash));\n            ip_mask = string2arr(host.substring(slash + 1));\n            if (ip_addr.length != ip_mask.length)\n            {\n                throw new ParseException(\"length of IP-address (\" +\n                        ip_addr.length + \") != length of netmask (\" +\n                        ip_mask.length + \")\");\n            }\n        }\n        else\n        {\n            ip_addr = string2arr(host);\n            ip_mask = new byte[ip_addr.length];\n            for (int idx = 0; idx < ip_mask.length; idx++)\n            {\n                ip_mask[idx] = (byte) 255;\n            }\n        }\n\n        // check if addr or subnet already exists\n\n        ip_loop :\n        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)\n        {\n            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);\n            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);\n            if (addr.length != ip_addr.length)\n            {\n                continue;\n            }\n\n            for (int idx2 = 0; idx2 < addr.length; idx2++)\n            {\n                if ((ip_addr[idx2] & mask[idx2]) != (addr[idx2] & mask[idx2]) ||\n                        (mask[idx2] != ip_mask[idx2]))\n                {\n                    continue ip_loop;\n                }\n            }\n\n            return;\n            // already exists\n        }\n        non_proxy_addr_list.addElement(ip_addr);\n        non_proxy_mask_list.addElement(ip_mask);\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"afc16d717d9ed1a8e45371668ca6de674164d624","date":1103345442,"type":4,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"/dev/null","pathOld":"sandbox/contributions/webcrawler-LARM/libs/HTTPClient-patch/HTTPClient/HTTPConnection#dontProxyFor(String).mjava","sourceNew":null,"sourceOld":"    /**\n     * Add <var>host</var> to the list of hosts which should be accessed\n     * directly, not via any proxy set by <code>setProxyServer()</code>. <P>\n     *\n     * The <var>host</var> may be any of:\n     * <UL>\n     *   <LI> a complete host name (e.g. \"www.disney.com\")\n     *   <LI> a domain name; domain names must begin with a dot (e.g.\n     *   \".disney.com\")\n     *   <LI> an IP-address (e.g. \"12.34.56.78\")\n     *   <LI> an IP-subnet, specified as an IP-address and a netmask separated\n     *   by a \"/\" (e.g. \"34.56.78/255.255.255.192\"); a 0 bit in the netmask\n     *   means that that bit won't be used in the comparison (i.e. the addresses\n     *   are AND'ed with the netmask before comparison).\n     * </UL>\n     * <P>\n     *\n     * The two properties <var>HTTPClient.nonProxyHosts</var> and <var>\n     * http.nonProxyHosts</var> are used when this class is loaded to initialize\n     * the list of non-proxy hosts. The second property is only read if the\n     * first one is not set; the second property is also used the JDK's\n     * URLConnection. These properties must contain a \"|\" separated list of\n     * entries which conform to the above rules for the <var>host</var>\n     * parameter (e.g. \"11.22.33.44|.disney.com\").\n     *\n     * @param host                a host name, domain name, IP-address or\n     *      IP-subnet.\n     * @exception ParseException  if the length of the netmask does not match\n     *      the length of the IP-address\n     */\n    public static void dontProxyFor(String host)\n        throws ParseException\n    {\n        host = host.trim().toLowerCase();\n\n        // check for domain name\n\n        if (host.charAt(0) == '.')\n        {\n            if (!non_proxy_dom_list.contains(host))\n            {\n                non_proxy_dom_list.addElement(host);\n            }\n            return;\n        }\n\n        // check for host name\n\n        for (int idx = 0; idx < host.length(); idx++)\n        {\n            if (!Character.isDigit(host.charAt(idx)) &&\n                    host.charAt(idx) != '.' && host.charAt(idx) != '/')\n            {\n                non_proxy_host_list.put(host, \"\");\n                return;\n            }\n        }\n\n        // must be an IP-address\n\n        byte[] ip_addr;\n        byte[] ip_mask;\n        int slash;\n        if ((slash = host.indexOf('/')) != -1)\n        {\n            // IP subnet\n\n            ip_addr = string2arr(host.substring(0, slash));\n            ip_mask = string2arr(host.substring(slash + 1));\n            if (ip_addr.length != ip_mask.length)\n            {\n                throw new ParseException(\"length of IP-address (\" +\n                        ip_addr.length + \") != length of netmask (\" +\n                        ip_mask.length + \")\");\n            }\n        }\n        else\n        {\n            ip_addr = string2arr(host);\n            ip_mask = new byte[ip_addr.length];\n            for (int idx = 0; idx < ip_mask.length; idx++)\n            {\n                ip_mask[idx] = (byte) 255;\n            }\n        }\n\n        // check if addr or subnet already exists\n\n        ip_loop :\n        for (int idx = 0; idx < non_proxy_addr_list.size(); idx++)\n        {\n            byte[] addr = (byte[]) non_proxy_addr_list.elementAt(idx);\n            byte[] mask = (byte[]) non_proxy_mask_list.elementAt(idx);\n            if (addr.length != ip_addr.length)\n            {\n                continue;\n            }\n\n            for (int idx2 = 0; idx2 < addr.length; idx2++)\n            {\n                if ((ip_addr[idx2] & mask[idx2]) != (addr[idx2] & mask[idx2]) ||\n                        (mask[idx2] != ip_mask[idx2]))\n                {\n                    continue ip_loop;\n                }\n            }\n\n            return;\n            // already exists\n        }\n        non_proxy_addr_list.addElement(ip_addr);\n        non_proxy_mask_list.addElement(ip_mask);\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"afc16d717d9ed1a8e45371668ca6de674164d624":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["afc16d717d9ed1a8e45371668ca6de674164d624"]},"commit2Childs":{"bc6055f4a2e8e9f9caaec2297010c9502480ed69":["afc16d717d9ed1a8e45371668ca6de674164d624"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bc6055f4a2e8e9f9caaec2297010c9502480ed69"],"afc16d717d9ed1a8e45371668ca6de674164d624":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}