{"path":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","commits":[{"id":"91d2c9ef44982358af4ac4600d8ac04f914c3ce4","date":1462431879,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"/dev/null","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7dc08f02757dd10637b16a5c65eaaef839a91a9a","date":1462455462,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"/dev/null","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7fe41964e49958f662028ea7ed8c224e0955edae","date":1462534610,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":0,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"/dev/null","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePoint, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePoint, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8b879b14da40ab73551b75835099a61e622a83d3","date":1522406622,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n        }\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, testPointInsidePlane, testPointInsidePlane.D);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, travelInsidePlane, travelInsidePlane.D);\n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3c9c955664ed32e2bf97b3da26467354673ea18","date":1522944427,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        final Plane travelAbovePlane = new Plane(travelPlane, true);\n        final Plane travelBelowPlane = new Plane(travelPlane, false);\n        \n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e872ee16caf3bf386b6a55f3654fabb2840d8fc9","date":1523529572,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a31f543c55a8dd122ed8676510a9c6d8000fa214","date":1524142014,"type":3,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        //System.out.println(\"Computing outside-outside intersection\");\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"039615f2ceafe5881c61222281f45a0631b90174","date":1524725949,"type":4,"author":"Karl Wright","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":null,"sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        //System.out.println(\"Computing outside-outside intersection\");\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e456381ade0a256838cbf558702284e345c8d3d6","date":1524920804,"type":0,"author":"Karl Wright","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"/dev/null","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        //System.out.println(\"Computing outside-outside intersection\");\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a","date":1583186777,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","pathOld":"lucene/spatial3d/src/java/org/apache/lucene/spatial3d/geom/GeoComplexPolygon.DualCrossingEdgeIterator#computeInsideOutside().mjava","sourceNew":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" xyScaling=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        //System.out.println(\"Computing outside-outside intersection\");\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","sourceOld":"    protected void computeInsideOutside() {\n      if (!computedInsideOutside) {\n        // Convert travel plane to a sided plane\n        final Membership intersectionBound1 = new SidedPlane(testPoint, travelPlane, travelPlane.D);\n        // Convert testPoint plane to a sided plane\n        final Membership intersectionBound2 = new SidedPlane(thePointX, thePointY, thePointZ, testPointPlane, testPointPlane.D);\n\n        assert intersectionBound1.isWithin(intersectionPoint) : \"intersection must be within intersectionBound1\";\n        assert intersectionBound2.isWithin(intersectionPoint) : \"intersection must be within intersectionBound2\";\n\n        // Figure out which of the above/below planes are inside vs. outside.  To do this,\n        // we look for the point that is within the bounds of the testPointPlane and travelPlane.  The two sides that intersected there are the inside\n        // borders.\n        // Each of these can generate two solutions.  We need to refine them to generate only one somehow -- the one in the same area of the world as intersectionPoint.\n        // Since the travel/testpoint planes have one fixed coordinate, and that is represented by the plane's D value, it should be possible to choose based on the\n        // point's coordinates. \n        final GeoPoint[] aboveAbove = travelAbovePlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert aboveAbove != null : \"Above + above should not be coplanar\";\n        final GeoPoint[] aboveBelow = travelAbovePlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert aboveBelow != null : \"Above + below should not be coplanar\";\n        final GeoPoint[] belowBelow = travelBelowPlane.findIntersections(planetModel, testPointBelowPlane, intersectionBound1, intersectionBound2);\n        assert belowBelow != null : \"Below + below should not be coplanar\";\n        final GeoPoint[] belowAbove = travelBelowPlane.findIntersections(planetModel, testPointAbovePlane, intersectionBound1, intersectionBound2);\n        assert belowAbove != null : \"Below + above should not be coplanar\";\n\n        assert ((aboveAbove.length > 0)?1:0) + ((aboveBelow.length > 0)?1:0) + ((belowBelow.length > 0)?1:0) + ((belowAbove.length > 0)?1:0) == 1 : \"Can be exactly one inside point, instead was: aa=\"+aboveAbove.length+\" ab=\" + aboveBelow.length+\" bb=\"+ belowBelow.length+\" ba=\" + belowAbove.length;\n        \n        final GeoPoint[] insideInsidePoints;\n        if (aboveAbove.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = aboveAbove;\n        } else if (aboveBelow.length > 0) {\n          travelInsidePlane = travelAbovePlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelBelowPlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = aboveBelow;\n        } else if (belowBelow.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointBelowPlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointAbovePlane;\n          insideInsidePoints = belowBelow;\n        } else if (belowAbove.length > 0) {\n          travelInsidePlane = travelBelowPlane;\n          testPointInsidePlane = testPointAbovePlane;\n          travelOutsidePlane = travelAbovePlane;\n          testPointOutsidePlane = testPointBelowPlane;\n          insideInsidePoints = belowAbove;\n        } else {\n          throw new IllegalStateException(\"Can't find traversal intersection among: \"+travelAbovePlane+\", \"+testPointAbovePlane+\", \"+travelBelowPlane+\", \"+testPointBelowPlane);\n        }\n        \n        // Get the inside-inside intersection point\n        // Picking which point, out of two, that corresponds to the already-selected intersectionPoint, is tricky, but it must be done.\n        // We expect the choice to be within a small delta of the intersection point in 2 of the dimensions, but not the third\n        final GeoPoint insideInsidePoint = pickProximate(insideInsidePoints);\n        \n        // Get the outside-outside intersection point\n        //System.out.println(\"Computing outside-outside intersection\");\n        final GeoPoint[] outsideOutsidePoints = testPointOutsidePlane.findIntersections(planetModel, travelOutsidePlane);  //these don't add anything: , checkPointCutoffPlane, testPointCutoffPlane);\n        final GeoPoint outsideOutsidePoint = pickProximate(outsideOutsidePoints);\n        \n        insideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, insideInsidePoint);\n        outsideTravelCutoffPlane = new SidedPlane(thePointX, thePointY, thePointZ, travelInsidePlane, outsideOutsidePoint);\n        insideTestPointCutoffPlane = new SidedPlane(testPoint, testPointInsidePlane, insideInsidePoint);\n        outsideTestPointCutoffPlane = new SidedPlane(testPoint, testPointOutsidePlane, outsideOutsidePoint);\n        \n        /*\n        System.out.println(\"insideTravelCutoffPlane = \"+insideTravelCutoffPlane);\n        System.out.println(\"outsideTravelCutoffPlane = \"+outsideTravelCutoffPlane);\n        System.out.println(\"insideTestPointCutoffPlane = \"+insideTestPointCutoffPlane);\n        System.out.println(\"outsideTestPointCutoffPlane = \"+outsideTestPointCutoffPlane);\n        */\n        \n        computedInsideOutside = true;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"8b879b14da40ab73551b75835099a61e622a83d3":["7fe41964e49958f662028ea7ed8c224e0955edae"],"e456381ade0a256838cbf558702284e345c8d3d6":["039615f2ceafe5881c61222281f45a0631b90174"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"a31f543c55a8dd122ed8676510a9c6d8000fa214":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["d3c9c955664ed32e2bf97b3da26467354673ea18"],"039615f2ceafe5881c61222281f45a0631b90174":["a31f543c55a8dd122ed8676510a9c6d8000fa214"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["e456381ade0a256838cbf558702284e345c8d3d6"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7fe41964e49958f662028ea7ed8c224e0955edae"],"d3c9c955664ed32e2bf97b3da26467354673ea18":["8b879b14da40ab73551b75835099a61e622a83d3"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7fe41964e49958f662028ea7ed8c224e0955edae"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"91d2c9ef44982358af4ac4600d8ac04f914c3ce4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7fe41964e49958f662028ea7ed8c224e0955edae":["91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"]},"commit2Childs":{"8b879b14da40ab73551b75835099a61e622a83d3":["d3c9c955664ed32e2bf97b3da26467354673ea18"],"e456381ade0a256838cbf558702284e345c8d3d6":["c33ed6824db1d3c54aaf0208e68c3df3fd43d93a"],"7dc08f02757dd10637b16a5c65eaaef839a91a9a":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a31f543c55a8dd122ed8676510a9c6d8000fa214":["039615f2ceafe5881c61222281f45a0631b90174"],"e872ee16caf3bf386b6a55f3654fabb2840d8fc9":["a31f543c55a8dd122ed8676510a9c6d8000fa214"],"039615f2ceafe5881c61222281f45a0631b90174":["e456381ade0a256838cbf558702284e345c8d3d6"],"c33ed6824db1d3c54aaf0208e68c3df3fd43d93a":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d3c9c955664ed32e2bf97b3da26467354673ea18":["e872ee16caf3bf386b6a55f3654fabb2840d8fc9"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","91d2c9ef44982358af4ac4600d8ac04f914c3ce4"],"91d2c9ef44982358af4ac4600d8ac04f914c3ce4":["7dc08f02757dd10637b16a5c65eaaef839a91a9a","7fe41964e49958f662028ea7ed8c224e0955edae"],"7fe41964e49958f662028ea7ed8c224e0955edae":["8b879b14da40ab73551b75835099a61e622a83d3","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}