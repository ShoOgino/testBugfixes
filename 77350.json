{"path":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","commits":[{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"modules/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args, fieldInfo), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args, fieldInfo), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ebd6f706eb59fe367493c820daeccd76587ec6bf","date":1340868972,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args, fieldInfo), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args, fieldInfo), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0415a016b37e58a017fed0a91234f733ab359971","date":1341458183,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args, fieldInfo), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"399d569d88e65d963440cdd3a3e2d5f7cdd1bd42","date":1341987627,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args, fieldInfo), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da956410d7a790f567af4e7e94584fb0930212f2","date":1346859431,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(new ShapeReadWriter(ctx).readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["9cb4b4651ba335fd70d51cf8448325add98f71c6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cb4b4651ba335fd70d51cf8448325add98f71c6","date":1348862946,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(new ShapeReadWriter(ctx).readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":["da956410d7a790f567af4e7e94584fb0930212f2"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e7b27dde701ae80df8bea8eb554d31e4e8bc6126","date":1354814363,"type":3,"author":"David Wayne Smiley","isMerge":false,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n      runTestQuery(concern, q);\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n      runTestQuery(concern, q);\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n\n      String msg = q.line; //\"Query: \" + q.args.toString(ctx);\n      SearchResults got = executeQuery(strategy.makeQuery(q.args), 100);\n      if (storeShape && got.numFound > 0) {\n        //check stored value is there & parses\n        assertNotNull(ctx.readShape(got.results.get(0).document.get(strategy.getFieldName())));\n      }\n      if (concern.orderIsImportant) {\n        Iterator<String> ids = q.ids.iterator();\n        for (SearchResult r : got.results) {\n          String id = r.document.get(\"id\");\n          if(!ids.hasNext()) {\n            Assert.fail(msg + \" :: Did not get enough results.  Expect\" + q.ids+\", got: \"+got.toDebugString());\n          }\n          Assert.assertEquals( \"out of order: \" + msg, ids.next(), id);\n        }\n        \n        if (ids.hasNext()) {\n          Assert.fail(msg + \" :: expect more results then we got: \" + ids.next());\n        }\n      } else {\n        // We are looking at how the results overlap\n        if( concern.resultsAreSuperset ) {\n          Set<String> found = new HashSet<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n          for( String s : q.ids ) {\n            if( !found.contains( s ) ) {\n              Assert.fail( \"Results are mising id: \"+s + \" :: \" + found );\n            }\n          }\n        }\n        else {\n          List<String> found = new ArrayList<String>();\n          for (SearchResult r : got.results) {\n            found.add(r.document.get(\"id\"));\n          }\n\n          // sort both so that the order is not important\n          Collections.sort(q.ids);\n          Collections.sort(found);\n          Assert.assertEquals(msg, q.ids.toString(), found.toString());\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"112d77ac8d3e10a362516ad834c9a11d35c94234","date":1456784319,"type":5,"author":"nknize","isMerge":false,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n      runTestQuery(concern, q);\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n      runTestQuery(concern, q);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"af2638813028b254a88b418ebeafb541afb49653","date":1456804822,"type":5,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/spatial-extras/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","pathOld":"lucene/spatial/src/test/org/apache/lucene/spatial/StrategyTestCase#runTestQueries(Iterator[SpatialTestQuery],SpatialMatchConcern).mjava","sourceNew":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n      runTestQuery(concern, q);\n    }\n  }\n\n","sourceOld":"  public void runTestQueries(\n      Iterator<SpatialTestQuery> queries,\n      SpatialMatchConcern concern) {\n    while (queries.hasNext()) {\n      SpatialTestQuery q = queries.next();\n      runTestQuery(concern, q);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0415a016b37e58a017fed0a91234f733ab359971":["ebd6f706eb59fe367493c820daeccd76587ec6bf"],"af2638813028b254a88b418ebeafb541afb49653":["e7b27dde701ae80df8bea8eb554d31e4e8bc6126","112d77ac8d3e10a362516ad834c9a11d35c94234"],"da956410d7a790f567af4e7e94584fb0930212f2":["399d569d88e65d963440cdd3a3e2d5f7cdd1bd42"],"407687e67faf6e1f02a211ca078d8e3eed631027":["9cb4b4651ba335fd70d51cf8448325add98f71c6","e7b27dde701ae80df8bea8eb554d31e4e8bc6126"],"9cb4b4651ba335fd70d51cf8448325add98f71c6":["da956410d7a790f567af4e7e94584fb0930212f2"],"112d77ac8d3e10a362516ad834c9a11d35c94234":["e7b27dde701ae80df8bea8eb554d31e4e8bc6126"],"ebd6f706eb59fe367493c820daeccd76587ec6bf":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"e7b27dde701ae80df8bea8eb554d31e4e8bc6126":["9cb4b4651ba335fd70d51cf8448325add98f71c6"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"aba371508186796cc6151d8223a5b4e16d02e26e":["0415a016b37e58a017fed0a91234f733ab359971","399d569d88e65d963440cdd3a3e2d5f7cdd1bd42"],"399d569d88e65d963440cdd3a3e2d5f7cdd1bd42":["0415a016b37e58a017fed0a91234f733ab359971"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b89678825b68eccaf09e6ab71675fc0b0af1e099","399d569d88e65d963440cdd3a3e2d5f7cdd1bd42"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["af2638813028b254a88b418ebeafb541afb49653"]},"commit2Childs":{"0415a016b37e58a017fed0a91234f733ab359971":["aba371508186796cc6151d8223a5b4e16d02e26e","399d569d88e65d963440cdd3a3e2d5f7cdd1bd42"],"af2638813028b254a88b418ebeafb541afb49653":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"da956410d7a790f567af4e7e94584fb0930212f2":["9cb4b4651ba335fd70d51cf8448325add98f71c6"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"112d77ac8d3e10a362516ad834c9a11d35c94234":["af2638813028b254a88b418ebeafb541afb49653"],"9cb4b4651ba335fd70d51cf8448325add98f71c6":["407687e67faf6e1f02a211ca078d8e3eed631027","e7b27dde701ae80df8bea8eb554d31e4e8bc6126"],"ebd6f706eb59fe367493c820daeccd76587ec6bf":["0415a016b37e58a017fed0a91234f733ab359971"],"e7b27dde701ae80df8bea8eb554d31e4e8bc6126":["af2638813028b254a88b418ebeafb541afb49653","407687e67faf6e1f02a211ca078d8e3eed631027","112d77ac8d3e10a362516ad834c9a11d35c94234"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["ebd6f706eb59fe367493c820daeccd76587ec6bf","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"aba371508186796cc6151d8223a5b4e16d02e26e":[],"399d569d88e65d963440cdd3a3e2d5f7cdd1bd42":["da956410d7a790f567af4e7e94584fb0930212f2","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b89678825b68eccaf09e6ab71675fc0b0af1e099"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","aba371508186796cc6151d8223a5b4e16d02e26e","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}