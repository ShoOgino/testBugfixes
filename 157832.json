{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","commits":[{"id":"6681d02f2302c363be938426e68f8dfd090cc1bf","date":1575339019,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props, String collection) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n    this.collection = collection;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas(collection,name, (Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3aa683bba99315838c968fefedf3d74f44aa993","date":1575395112,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object]).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props, String collection) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n    this.collection = collection;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas(collection,name, (Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas((Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a7dfea4f7c80813344b0152e37fc18b31369e8ff","date":1592136683,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/Slice#Slice(String,Map[String,Replica],Map[String,Object],String).mjava","sourceNew":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  @SuppressWarnings({\"unchecked\", \"rawtypes\"})\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props, String collection) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n    this.collection = collection;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas(collection,name, (Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","sourceOld":"  /**\n   * @param name  The name of the slice\n   * @param replicas The replicas of the slice.  This is used directly and a copy is not made.  If null, replicas will be constructed from props.\n   * @param props  The properties of the slice - a shallow copy will always be made.\n   */\n  public Slice(String name, Map<String,Replica> replicas, Map<String,Object> props, String collection) {\n    super( props==null ? new LinkedHashMap<String,Object>(2) : new LinkedHashMap<>(props));\n    this.name = name;\n    this.collection = collection;\n\n    Object rangeObj = propMap.get(RANGE);\n    if (propMap.get(ZkStateReader.STATE_PROP) != null) {\n      this.state = State.getState((String) propMap.get(ZkStateReader.STATE_PROP));\n    } else {\n      this.state = State.ACTIVE;                         //Default to ACTIVE\n      propMap.put(ZkStateReader.STATE_PROP, state.toString());\n    }\n    DocRouter.Range tmpRange = null;\n    if (rangeObj instanceof DocRouter.Range) {\n      tmpRange = (DocRouter.Range)rangeObj;\n    } else if (rangeObj != null) {\n      // Doesn't support custom implementations of Range, but currently not needed.\n      tmpRange = DocRouter.DEFAULT.fromString(rangeObj.toString());\n    }\n    range = tmpRange;\n\n    /** debugging.  this isn't an error condition for custom sharding.\n    if (range == null) {\n      System.out.println(\"###### NO RANGE for \" + name + \" props=\" + props);\n    }\n    **/\n\n    if (propMap.containsKey(PARENT) && propMap.get(PARENT) != null)\n      this.parent = (String) propMap.get(PARENT);\n    else\n      this.parent = null;\n\n    replicationFactor = null;  // future\n\n    // add the replicas *after* the other properties (for aesthetics, so it's easy to find slice properties in the JSON output)\n    this.replicas = replicas != null ? replicas : makeReplicas(collection,name, (Map<String,Object>)propMap.get(REPLICAS));\n    propMap.put(REPLICAS, this.replicas);\n\n    Map<String, Object> rules = (Map<String, Object>) propMap.get(\"routingRules\");\n    if (rules != null) {\n      this.routingRules = new HashMap<>();\n      for (Map.Entry<String, Object> entry : rules.entrySet()) {\n        Object o = entry.getValue();\n        if (o instanceof Map) {\n          Map map = (Map) o;\n          RoutingRule rule = new RoutingRule(entry.getKey(), map);\n          routingRules.put(entry.getKey(), rule);\n        } else {\n          routingRules.put(entry.getKey(), (RoutingRule) o);\n        }\n      }\n    } else {\n      this.routingRules = null;\n    }\n\n    leader = findLeader();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3aa683bba99315838c968fefedf3d74f44aa993":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6681d02f2302c363be938426e68f8dfd090cc1bf"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["6681d02f2302c363be938426e68f8dfd090cc1bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"d3aa683bba99315838c968fefedf3d74f44aa993":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d3aa683bba99315838c968fefedf3d74f44aa993","6681d02f2302c363be938426e68f8dfd090cc1bf"],"a7dfea4f7c80813344b0152e37fc18b31369e8ff":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"6681d02f2302c363be938426e68f8dfd090cc1bf":["d3aa683bba99315838c968fefedf3d74f44aa993","a7dfea4f7c80813344b0152e37fc18b31369e8ff"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d3aa683bba99315838c968fefedf3d74f44aa993","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}