{"path":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","commits":[{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrServerTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrClient solrClient = new HttpSolrClient(url);\n      QueryResponse queryResponse = queryRequest.process(solrClient);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrClient threadedClient = null;\n    try {\n      threadedClient = new CloudSolrClient(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrClient solrClient = new HttpSolrClient(url);\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrServer cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrServer.RouteResponse rr = (CloudSolrServer.RouteResponse) response;\n    Map<String,LBHttpSolrServer.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrServer.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrServer solrServer = new HttpSolrServer(url);\n      QueryResponse queryResponse = queryRequest.process(solrServer);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrServer threadedClient = null;\n    try {\n      threadedClient = new CloudSolrServer(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrServer.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrServer.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrServer solrServer = new HttpSolrServer(url);\n        QueryResponse queryResponse = queryRequest.process(solrServer);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6784d0cc613dc1ee97030eaaa5e0754edc22d164","date":1420824784,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrClient solrClient = new HttpSolrClient(url);\n      try {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      } finally {\n        solrClient.shutdown();\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrClient threadedClient = null;\n    try {\n      threadedClient = new CloudSolrClient(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrClient solrClient = new HttpSolrClient(url);\n        try {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        } finally {\n          solrClient.shutdown();\n        }\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrClient solrClient = new HttpSolrClient(url);\n      QueryResponse queryResponse = queryRequest.process(solrClient);\n      SolrDocumentList docList = queryResponse.getResults();\n      assertTrue(docList.getNumFound() == 1);\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrClient threadedClient = null;\n    try {\n      threadedClient = new CloudSolrClient(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrClient solrClient = new HttpSolrClient(url);\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":["bafca15d8e408346a67f4282ad1143b88023893b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = new HttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = new HttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      HttpSolrClient solrClient = new HttpSolrClient(url);\n      try {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      } finally {\n        solrClient.shutdown();\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    \n    CloudSolrClient threadedClient = null;\n    try {\n      threadedClient = new CloudSolrClient(zkServer.getZkAddress());\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        HttpSolrClient solrClient = new HttpSolrClient(url);\n        try {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        } finally {\n          solrClient.shutdown();\n        }\n      }\n    } finally {\n      threadedClient.shutdown();\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.shutdown();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = new HttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = new HttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = new HttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = new CloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = new HttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b940572a59da1b42b6c20ab5278155b12816807a","date":1462388874,"type":5,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bd78ba595fa6cdd7fff930f26d154d13a823fa47","date":1462400514,"type":5,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73450c0955930295d34703e7ddbfc6973b7a121a","date":1462431925,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","date":1462576651,"type":5,"author":"Mike McCandless","isMerge":true,"pathNew":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#testRouting().mjava","pathOld":"solr/solrj/src/test/org/apache/solr/client/solrj/impl/CloudSolrClientTest#allTests().mjava","sourceNew":"  @Test\n  public void testRouting() throws Exception {\n    \n    AbstractUpdateRequest request = new UpdateRequest()\n        .add(id, \"0\", \"a_t\", \"hello1\")\n        .add(id, \"2\", \"a_t\", \"hello2\")\n        .setAction(AbstractUpdateRequest.ACTION.COMMIT, true, true);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cluster.getSolrClient().request(request, COLLECTION);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    new UpdateRequest()\n        .deleteById(\"0\")\n        .deleteById(\"2\")\n        .commit(cluster.getSolrClient(), COLLECTION);\n\n    QueryResponse qResponse = cluster.getSolrClient().query(COLLECTION, new SolrQuery(\"*:*\"));\n    SolrDocumentList docs = qResponse.getResults();\n    assertEquals(0, docs.getNumFound());\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(cluster.getZkServer().getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(COLLECTION);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cluster.getSolrClient().getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(COLLECTION);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL, COLLECTION));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output: {}\", cluster.getSolrClient().query(COLLECTION, solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, COLLECTION);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n  }\n\n","sourceOld":"  private void allTests() throws Exception {\n\n    String collectionName = \"clientTestExternColl\";\n    createCollection(collectionName, controlClientCloud, 2, 2);\n    waitForRecoveriesToFinish(collectionName, false);\n    CloudSolrClient cloudClient = createCloudClient(collectionName);\n\n    assertNotNull(cloudClient);\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n\n    controlClient.commit();\n    this.cloudClient.commit();\n\n    SolrInputDocument doc1 = new SolrInputDocument();\n    doc1.addField(id, \"0\");\n    doc1.addField(\"a_t\", \"hello1\");\n    SolrInputDocument doc2 = new SolrInputDocument();\n    doc2.addField(id, \"2\");\n    doc2.addField(\"a_t\", \"hello2\");\n    \n    UpdateRequest request = new UpdateRequest();\n    request.add(doc1);\n    request.add(doc2);\n    request.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    \n    // Test single threaded routed updates for UpdateRequest\n    NamedList<Object> response = cloudClient.request(request);\n    CloudSolrClient.RouteResponse rr = (CloudSolrClient.RouteResponse) response;\n    Map<String,LBHttpSolrClient.Req> routes = rr.getRoutes();\n    Iterator<Map.Entry<String,LBHttpSolrClient.Req>> it = routes.entrySet()\n        .iterator();\n    while (it.hasNext()) {\n      Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n      String url = entry.getKey();\n      UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n          .getRequest();\n      SolrInputDocument doc = updateRequest.getDocuments().get(0);\n      String id = doc.getField(\"id\").getValue().toString();\n      ModifiableSolrParams params = new ModifiableSolrParams();\n      params.add(\"q\", \"id:\" + id);\n      params.add(\"distrib\", \"false\");\n      QueryRequest queryRequest = new QueryRequest(params);\n      try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n        QueryResponse queryResponse = queryRequest.process(solrClient);\n        SolrDocumentList docList = queryResponse.getResults();\n        assertTrue(docList.getNumFound() == 1);\n      }\n    }\n    \n    // Test the deleteById routing for UpdateRequest\n    \n    UpdateRequest delRequest = new UpdateRequest();\n    delRequest.deleteById(\"0\");\n    delRequest.deleteById(\"2\");\n    delRequest.setAction(AbstractUpdateRequest.ACTION.COMMIT, false, false);\n    cloudClient.request(delRequest);\n    ModifiableSolrParams qParams = new ModifiableSolrParams();\n    qParams.add(\"q\", \"*:*\");\n    QueryRequest qRequest = new QueryRequest(qParams);\n    QueryResponse qResponse = qRequest.process(cloudClient);\n    SolrDocumentList docs = qResponse.getResults();\n    assertTrue(docs.getNumFound() == 0);\n    \n    // Test Multi-Threaded routed updates for UpdateRequest\n    try (CloudSolrClient threadedClient = getCloudSolrClient(zkServer.getZkAddress())) {\n      threadedClient.setParallelUpdates(true);\n      threadedClient.setDefaultCollection(collectionName);\n      response = threadedClient.request(request);\n      rr = (CloudSolrClient.RouteResponse) response;\n      routes = rr.getRoutes();\n      it = routes.entrySet()\n          .iterator();\n      while (it.hasNext()) {\n        Map.Entry<String,LBHttpSolrClient.Req> entry = it.next();\n        String url = entry.getKey();\n        UpdateRequest updateRequest = (UpdateRequest) entry.getValue()\n            .getRequest();\n        SolrInputDocument doc = updateRequest.getDocuments().get(0);\n        String id = doc.getField(\"id\").getValue().toString();\n        ModifiableSolrParams params = new ModifiableSolrParams();\n        params.add(\"q\", \"id:\" + id);\n        params.add(\"distrib\", \"false\");\n        QueryRequest queryRequest = new QueryRequest(params);\n        try (HttpSolrClient solrClient = getHttpSolrClient(url)) {\n          QueryResponse queryResponse = queryRequest.process(solrClient);\n          SolrDocumentList docList = queryResponse.getResults();\n          assertTrue(docList.getNumFound() == 1);\n        }\n      }\n    }\n\n    // Test that queries with _route_ params are routed by the client\n\n    // Track request counts on each node before query calls\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    DocCollection col = clusterState.getCollection(collectionName);\n    Map<String, Long> requestCountsMap = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        requestCountsMap.put(baseURL, getNumRequests(baseURL,collectionName));\n      }\n    }\n\n    // Collect the base URLs of the replicas of shard that's expected to be hit\n    DocRouter router = col.getRouter();\n    Collection<Slice> expectedSlices = router.getSearchSlicesSingle(\"0\", null, col);\n    Set<String> expectedBaseURLs = Sets.newHashSet();\n    for (Slice expectedSlice : expectedSlices) {\n      for (Replica replica : expectedSlice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n        expectedBaseURLs.add(baseURL);\n      }\n    }\n\n    assertTrue(\"expected urls is not fewer than all urls! expected=\" + expectedBaseURLs\n        + \"; all=\" + requestCountsMap.keySet(),\n        expectedBaseURLs.size() < requestCountsMap.size());\n\n    // Calculate a number of shard keys that route to the same shard.\n    int n;\n    if (TEST_NIGHTLY) {\n      n = random().nextInt(999) + 2;\n    } else {\n      n = random().nextInt(9) + 2;\n    }\n    \n    List<String> sameShardRoutes = Lists.newArrayList();\n    sameShardRoutes.add(\"0\");\n    for (int i = 1; i < n; i++) {\n      String shardKey = Integer.toString(i);\n      Collection<Slice> slices = router.getSearchSlicesSingle(shardKey, null, col);\n      log.info(\"Expected Slices {}\", slices);\n      if (expectedSlices.equals(slices)) {\n        sameShardRoutes.add(shardKey);\n      }\n    }\n\n    assertTrue(sameShardRoutes.size() > 1);\n\n    // Do N queries with _route_ parameter to the same shard\n    for (int i = 0; i < n; i++) {\n      ModifiableSolrParams solrParams = new ModifiableSolrParams();\n      solrParams.set(CommonParams.Q, \"*:*\");\n      solrParams.set(ShardParams._ROUTE_, sameShardRoutes.get(random().nextInt(sameShardRoutes.size())));\n      log.info(\"output  : {}\" ,cloudClient.query(solrParams));\n    }\n\n    // Request counts increase from expected nodes should aggregate to 1000, while there should be\n    // no increase in unexpected nodes.\n    int increaseFromExpectedUrls = 0;\n    int increaseFromUnexpectedUrls = 0;\n    Map<String, Long> numRequestsToUnexpectedUrls = Maps.newHashMap();\n    for (Slice slice : col.getSlices()) {\n      for (Replica replica : slice.getReplicas()) {\n        String baseURL = (String) replica.get(ZkStateReader.BASE_URL_PROP);\n\n        Long prevNumRequests = requestCountsMap.get(baseURL);\n        Long curNumRequests = getNumRequests(baseURL, collectionName);\n\n        long delta = curNumRequests - prevNumRequests;\n        if (expectedBaseURLs.contains(baseURL)) {\n          increaseFromExpectedUrls += delta;\n        } else {\n          increaseFromUnexpectedUrls += delta;\n          numRequestsToUnexpectedUrls.put(baseURL, delta);\n        }\n      }\n    }\n\n    assertEquals(\"Unexpected number of requests to expected URLs\", n, increaseFromExpectedUrls);\n    assertEquals(\"Unexpected number of requests to unexpected URLs: \" + numRequestsToUnexpectedUrls,\n        0, increaseFromUnexpectedUrls);\n\n    controlClient.deleteByQuery(\"*:*\");\n    cloudClient.deleteByQuery(\"*:*\");\n\n    controlClient.commit();\n    cloudClient.commit();\n    cloudClient.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bd78ba595fa6cdd7fff930f26d154d13a823fa47":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","b940572a59da1b42b6c20ab5278155b12816807a"],"73450c0955930295d34703e7ddbfc6973b7a121a":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","b940572a59da1b42b6c20ab5278155b12816807a"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","73450c0955930295d34703e7ddbfc6973b7a121a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["cc3b13b430571c2e169f98fe38e1e7666f88522d","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"bafca15d8e408346a67f4282ad1143b88023893b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"b940572a59da1b42b6c20ab5278155b12816807a":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["73450c0955930295d34703e7ddbfc6973b7a121a"]},"commit2Childs":{"bd78ba595fa6cdd7fff930f26d154d13a823fa47":[],"73450c0955930295d34703e7ddbfc6973b7a121a":["a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"a8ed5da4b0191db6bc7f77f9feb35da6bd76f904":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["bafca15d8e408346a67f4282ad1143b88023893b"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","73450c0955930295d34703e7ddbfc6973b7a121a","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","b940572a59da1b42b6c20ab5278155b12816807a"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"bafca15d8e408346a67f4282ad1143b88023893b":["6784d0cc613dc1ee97030eaaa5e0754edc22d164"],"b940572a59da1b42b6c20ab5278155b12816807a":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","73450c0955930295d34703e7ddbfc6973b7a121a"],"6784d0cc613dc1ee97030eaaa5e0754edc22d164":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bd78ba595fa6cdd7fff930f26d154d13a823fa47","a8ed5da4b0191db6bc7f77f9feb35da6bd76f904","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}