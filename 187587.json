{"path":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","commits":[{"id":"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4","date":1318260487,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState)\n      throws IOException {\n    final FieldInfos fieldInfos = mergeState.fieldInfos;\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] =  mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : fieldInfos) {\n      mergeState.fieldInfo = fieldInfo;\n      TypePromoter currentPromoter = TypePromoter.getIdentityPromoter();\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n            if (docValues[i] != null) {\n              currentPromoter = promoteValueType(fieldInfo, docValues[i], currentPromoter);\n              if (currentPromoter == null) {\n                break;\n              }     \n            }\n          }\n        }\n        \n        if (currentPromoter == null) {\n          fieldInfo.resetDocValues(null);\n          continue;\n        }\n        assert currentPromoter != TypePromoter.getIdentityPromoter();\n        if (fieldInfo.getDocValues() != currentPromoter.type()) {\n          // reset the type if we got promoted\n          fieldInfo.resetDocValues(currentPromoter.type());\n        }\n        \n        final DocValuesConsumer docValuesConsumer = addValuesField(mergeState.fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23c3a6c2ecb0c99396936e72e8998df877ea9ad5","date":1323268151,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] = mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n          }\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }  \n\n","sourceOld":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState)\n      throws IOException {\n    final FieldInfos fieldInfos = mergeState.fieldInfos;\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] =  mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : fieldInfos) {\n      mergeState.fieldInfo = fieldInfo;\n      TypePromoter currentPromoter = TypePromoter.getIdentityPromoter();\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n            if (docValues[i] != null) {\n              currentPromoter = promoteValueType(fieldInfo, docValues[i], currentPromoter);\n              if (currentPromoter == null) {\n                break;\n              }     \n            }\n          }\n        }\n        \n        if (currentPromoter == null) {\n          fieldInfo.resetDocValues(null);\n          continue;\n        }\n        assert currentPromoter != TypePromoter.getIdentityPromoter();\n        if (fieldInfo.getDocValues() != currentPromoter.type()) {\n          // reset the type if we got promoted\n          fieldInfo.resetDocValues(currentPromoter.type());\n        }\n        \n        final DocValuesConsumer docValuesConsumer = addValuesField(mergeState.fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05","date":1323284809,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] = mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n          }\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }  \n\n","sourceOld":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] = mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n          }\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe","date":1323449025,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final DocValues[] docValues = new DocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] = mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n          }\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }  \n\n","sourceOld":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] = mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n          }\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cac4d5fa6c305b94f6232a70bda07f096ad0348c","date":1323538980,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocProducer} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final DocValues[] docValues = new DocValues[mergeState.readers.size()];\n\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < docValues.length; i++) {\n          docValues[i] = mergeState.readers.get(i).reader.docValues(fieldInfo.name);\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n  }  \n\n","sourceOld":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final DocValues[] docValues = new DocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] = mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n          }\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d638301ad1cfcae567b681b893bc8781f0ee48a5","date":1323801546,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocProducer} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final DocValues[] docValues = new DocValues[mergeState.readers.size()];\n\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < docValues.length; i++) {\n          docValues[i] = mergeState.readers.get(i).reader.docValues(fieldInfo.name);\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n  }  \n\n","sourceOld":"  /**\n   * Consumes and merges the given {@link PerDocValues} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState)\n      throws IOException {\n    final FieldInfos fieldInfos = mergeState.fieldInfos;\n    final IndexDocValues[] docValues = new IndexDocValues[mergeState.readers.size()];\n    final PerDocValues[] perDocValues = new PerDocValues[mergeState.readers.size()];\n    // pull all PerDocValues \n    for (int i = 0; i < perDocValues.length; i++) {\n      perDocValues[i] =  mergeState.readers.get(i).reader.perDocValues();\n    }\n    for (FieldInfo fieldInfo : fieldInfos) {\n      mergeState.fieldInfo = fieldInfo;\n      TypePromoter currentPromoter = TypePromoter.getIdentityPromoter();\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < perDocValues.length; i++) {\n          if (perDocValues[i] != null) { // get all IDV to merge\n            docValues[i] = perDocValues[i].docValues(fieldInfo.name);\n            if (docValues[i] != null) {\n              currentPromoter = promoteValueType(fieldInfo, docValues[i], currentPromoter);\n              if (currentPromoter == null) {\n                break;\n              }     \n            }\n          }\n        }\n        \n        if (currentPromoter == null) {\n          fieldInfo.resetDocValues(null);\n          continue;\n        }\n        assert currentPromoter != TypePromoter.getIdentityPromoter();\n        if (fieldInfo.getDocValues() != currentPromoter.type()) {\n          // reset the type if we got promoted\n          fieldInfo.resetDocValues(currentPromoter.type());\n        }\n        \n        final DocValuesConsumer docValuesConsumer = addValuesField(mergeState.fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n    /* NOTE: don't close the perDocProducers here since they are private segment producers\n     * and will be closed once the SegmentReader goes out of scope */ \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/PerDocConsumer#merge(MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/PerDocConsumer#merge(MergeState).mjava","sourceNew":"  /**\n   * Consumes and merges the given {@link PerDocProducer} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final DocValues[] docValues = new DocValues[mergeState.readers.size()];\n\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < docValues.length; i++) {\n          docValues[i] = mergeState.readers.get(i).reader.docValues(fieldInfo.name);\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n  }  \n\n","sourceOld":"  /**\n   * Consumes and merges the given {@link PerDocProducer} producer\n   * into this consumers format.   \n   */\n  public void merge(MergeState mergeState) throws IOException {\n    final DocValues[] docValues = new DocValues[mergeState.readers.size()];\n\n    for (FieldInfo fieldInfo : mergeState.fieldInfos) {\n      mergeState.fieldInfo = fieldInfo; // set the field we are merging\n      if (fieldInfo.hasDocValues()) {\n        for (int i = 0; i < docValues.length; i++) {\n          docValues[i] = mergeState.readers.get(i).reader.docValues(fieldInfo.name);\n        }\n        final DocValuesConsumer docValuesConsumer = addValuesField(fieldInfo.getDocValuesType(), fieldInfo);\n        assert docValuesConsumer != null;\n        docValuesConsumer.merge(mergeState, docValues);\n      }\n    }\n  }  \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"cac4d5fa6c305b94f6232a70bda07f096ad0348c":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05":["23c3a6c2ecb0c99396936e72e8998df877ea9ad5"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23c3a6c2ecb0c99396936e72e8998df877ea9ad5":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4","cac4d5fa6c305b94f6232a70bda07f096ad0348c"]},"commit2Childs":{"cac4d5fa6c305b94f6232a70bda07f096ad0348c":["d638301ad1cfcae567b681b893bc8781f0ee48a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["32aca6bb0a6aa0a1813e7d035ac0e039f54269f4"],"1e59c344a45b9502f40ec44f5fe4e20ed2291dbe":["cac4d5fa6c305b94f6232a70bda07f096ad0348c"],"ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05":["1e59c344a45b9502f40ec44f5fe4e20ed2291dbe"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"32aca6bb0a6aa0a1813e7d035ac0e039f54269f4":["23c3a6c2ecb0c99396936e72e8998df877ea9ad5","d638301ad1cfcae567b681b893bc8781f0ee48a5"],"23c3a6c2ecb0c99396936e72e8998df877ea9ad5":["ecd41ba3cdd1b4d825aa53d1987e4360cf45cb05"],"d638301ad1cfcae567b681b893bc8781f0ee48a5":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}