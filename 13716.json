{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","commits":[{"id":"f6b1e64caa933f6fb3c0494afd6ca2597f55cc91","date":1470238980,"type":0,"author":"jbernste","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(\"id\", name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b013574eedcdbac35dc7e35b0ee616ffc38895d","date":1470897818,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(\"id\", name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"/dev/null","sourceNew":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(\"id\", name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6d2dadc1f5ca8703d8659f4964961f9967935d75","date":1490231750,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(ID, name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(\"id\", name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e5fa6615014cd2288fe930f8c8bb726f9504961d","date":1490280013,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(ID, name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(\"id\", name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","sourceNew":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        return Tuple.EOF();\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(ID, name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        Map map = new HashMap();\n        map.put(\"EOF\", true);\n        return new Tuple(map);\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(ID, name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75","date":1591744896,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/TextLogitStream#read().mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        return Tuple.EOF();\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList<>();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          @SuppressWarnings({\"rawtypes\"})\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        @SuppressWarnings({\"rawtypes\"})\n        Map map = new HashMap();\n        map.put(ID, name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","sourceOld":"  public Tuple read() throws IOException {\n    try {\n\n      if(++iteration > maxIterations) {\n        return Tuple.EOF();\n      } else {\n\n        if (this.idfs == null) {\n          loadTerms();\n\n          if (weights != null && terms.size() + 1 != weights.size()) {\n            throw new IOException(String.format(Locale.ROOT,\"invalid expression %s - the number of weights must be %d, found %d\", terms.size()+1, weights.size()));\n          }\n        }\n\n        List<List<Double>> allWeights = new ArrayList();\n        this.evaluation = new ClassificationEvaluation();\n\n        this.error = 0;\n        for (Future<Tuple> logitCall : callShards(getShardUrls())) {\n\n          Tuple tuple = logitCall.get();\n          List<Double> shardWeights = (List<Double>) tuple.get(\"weights\");\n          allWeights.add(shardWeights);\n          this.error += tuple.getDouble(\"error\");\n          Map shardEvaluation = (Map) tuple.get(\"evaluation\");\n          this.evaluation.addEvaluation(shardEvaluation);\n        }\n\n        this.weights = averageWeights(allWeights);\n        Map map = new HashMap();\n        map.put(ID, name+\"_\"+iteration);\n        map.put(\"name_s\", name);\n        map.put(\"field_s\", field);\n        map.put(\"terms_ss\", terms);\n        map.put(\"iteration_i\", iteration);\n\n        if(weights != null) {\n          map.put(\"weights_ds\", weights);\n        }\n\n        map.put(\"error_d\", error);\n        evaluation.putToMap(map);\n        map.put(\"alpha_d\", this.learningRate);\n        map.put(\"idfs_ds\", this.idfs);\n\n        if (iteration != 1) {\n          if (lastError <= error) {\n            this.learningRate *= 0.5;\n          } else {\n            this.learningRate *= 1.05;\n          }\n        }\n\n        lastError = error;\n\n        return new Tuple(map);\n      }\n\n    } catch(Exception e) {\n      throw new IOException(e);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e5fa6615014cd2288fe930f8c8bb726f9504961d":["f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"f6b1e64caa933f6fb3c0494afd6ca2597f55cc91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"804a8d5358fe7b7563b85ee7838714d720b89272":["6d2dadc1f5ca8703d8659f4964961f9967935d75"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","f6b1e64caa933f6fb3c0494afd6ca2597f55cc91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"]},"commit2Childs":{"e5fa6615014cd2288fe930f8c8bb726f9504961d":[],"f6b1e64caa933f6fb3c0494afd6ca2597f55cc91":["e5fa6615014cd2288fe930f8c8bb726f9504961d","6d2dadc1f5ca8703d8659f4964961f9967935d75","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"6d2dadc1f5ca8703d8659f4964961f9967935d75":["804a8d5358fe7b7563b85ee7838714d720b89272"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["f6b1e64caa933f6fb3c0494afd6ca2597f55cc91","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d"],"2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"804a8d5358fe7b7563b85ee7838714d720b89272":["2b7d28aa15134f77b3a8f4c2724bdc7cb402ab75"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"3b013574eedcdbac35dc7e35b0ee616ffc38895d":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["e5fa6615014cd2288fe930f8c8bb726f9504961d","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","3b013574eedcdbac35dc7e35b0ee616ffc38895d","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}