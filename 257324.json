{"path":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","commits":[{"id":"3766097c9c41a30d67e9b548c62d017abf8e07ac","date":1228770465,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache} or {@link\n   *  ExtendedFieldCache}. Sort type is inferred by testing\n   *  which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n\n    if (parser instanceof FieldCache.IntParser) this.type=INT;\n    else if (parser instanceof FieldCache.FloatParser) this.type=FLOAT;\n    else if (parser instanceof FieldCache.ShortParser) this.type=SHORT;\n    else if (parser instanceof FieldCache.ByteParser) this.type=BYTE;\n    else if (parser instanceof ExtendedFieldCache.LongParser) this.type=LONG;\n    else if (parser instanceof ExtendedFieldCache.DoubleParser) this.type=DOUBLE;\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache or ExtendedFieldCache (got\" + parser + \")\");\n\n    initFieldType(field, type);\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bf32717572de813a59d2207d1f4332ae44fd306e","date":1228778854,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","pathOld":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","sourceNew":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache} or {@link\n   *  ExtendedFieldCache}. Sort type is inferred by testing\n   *  which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n    if (parser instanceof FieldCache.IntParser) initFieldType(field, INT);\n    else if (parser instanceof FieldCache.FloatParser) initFieldType(field, FLOAT);\n    else if (parser instanceof FieldCache.ShortParser) initFieldType(field, SHORT);\n    else if (parser instanceof FieldCache.ByteParser) initFieldType(field, BYTE);\n    else if (parser instanceof ExtendedFieldCache.LongParser) initFieldType(field, LONG);\n    else if (parser instanceof ExtendedFieldCache.DoubleParser) initFieldType(field, DOUBLE);\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache or ExtendedFieldCache (got \" + parser + \")\");\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","sourceOld":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache} or {@link\n   *  ExtendedFieldCache}. Sort type is inferred by testing\n   *  which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n\n    if (parser instanceof FieldCache.IntParser) this.type=INT;\n    else if (parser instanceof FieldCache.FloatParser) this.type=FLOAT;\n    else if (parser instanceof FieldCache.ShortParser) this.type=SHORT;\n    else if (parser instanceof FieldCache.ByteParser) this.type=BYTE;\n    else if (parser instanceof ExtendedFieldCache.LongParser) this.type=LONG;\n    else if (parser instanceof ExtendedFieldCache.DoubleParser) this.type=DOUBLE;\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache or ExtendedFieldCache (got\" + parser + \")\");\n\n    initFieldType(field, type);\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"65eb076d345a794256daba691a2b366657c807e8","date":1245771732,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","pathOld":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","sourceNew":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache}. Sort type is inferred\n   *  by testing which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n    if (parser instanceof FieldCache.IntParser) initFieldType(field, INT);\n    else if (parser instanceof FieldCache.FloatParser) initFieldType(field, FLOAT);\n    else if (parser instanceof FieldCache.ShortParser) initFieldType(field, SHORT);\n    else if (parser instanceof FieldCache.ByteParser) initFieldType(field, BYTE);\n    else if (parser instanceof FieldCache.LongParser) initFieldType(field, LONG);\n    else if (parser instanceof FieldCache.DoubleParser) initFieldType(field, DOUBLE);\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache (got \" + parser + \")\");\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","sourceOld":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache} or {@link\n   *  ExtendedFieldCache}. Sort type is inferred by testing\n   *  which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n    if (parser instanceof FieldCache.IntParser) initFieldType(field, INT);\n    else if (parser instanceof FieldCache.FloatParser) initFieldType(field, FLOAT);\n    else if (parser instanceof FieldCache.ShortParser) initFieldType(field, SHORT);\n    else if (parser instanceof FieldCache.ByteParser) initFieldType(field, BYTE);\n    else if (parser instanceof ExtendedFieldCache.LongParser) initFieldType(field, LONG);\n    else if (parser instanceof ExtendedFieldCache.DoubleParser) initFieldType(field, DOUBLE);\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache or ExtendedFieldCache (got \" + parser + \")\");\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","pathOld":"src/java/org/apache/lucene/search/SortField#SortField(String,FieldCache.Parser,boolean).mjava","sourceNew":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache}. Sort type is inferred\n   *  by testing which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n    if (parser instanceof FieldCache.IntParser) initFieldType(field, INT);\n    else if (parser instanceof FieldCache.FloatParser) initFieldType(field, FLOAT);\n    else if (parser instanceof FieldCache.ShortParser) initFieldType(field, SHORT);\n    else if (parser instanceof FieldCache.ByteParser) initFieldType(field, BYTE);\n    else if (parser instanceof FieldCache.LongParser) initFieldType(field, LONG);\n    else if (parser instanceof FieldCache.DoubleParser) initFieldType(field, DOUBLE);\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache (got \" + parser + \")\");\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","sourceOld":"  /** Creates a sort, possibly in reverse, by terms in the given field, parsed\n   * to numeric values using a custom {@link FieldCache.Parser}.\n   * @param field  Name of field to sort by.  Must not be null.\n   * @param parser Instance of a {@link FieldCache.Parser},\n   *  which must subclass one of the existing numeric\n   *  parsers from {@link FieldCache}. Sort type is inferred\n   *  by testing which numeric parser the parser subclasses.\n   * @param reverse True if natural order should be reversed.\n   * @throws IllegalArgumentException if the parser fails to\n   *  subclass an existing numeric parser, or field is null\n   */\n  public SortField (String field, FieldCache.Parser parser, boolean reverse) {\n    if (parser instanceof FieldCache.IntParser) initFieldType(field, INT);\n    else if (parser instanceof FieldCache.FloatParser) initFieldType(field, FLOAT);\n    else if (parser instanceof FieldCache.ShortParser) initFieldType(field, SHORT);\n    else if (parser instanceof FieldCache.ByteParser) initFieldType(field, BYTE);\n    else if (parser instanceof FieldCache.LongParser) initFieldType(field, LONG);\n    else if (parser instanceof FieldCache.DoubleParser) initFieldType(field, DOUBLE);\n    else\n      throw new IllegalArgumentException(\"Parser instance does not subclass existing numeric parser from FieldCache (got \" + parser + \")\");\n\n    this.reverse = reverse;\n    this.parser = parser;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"bf32717572de813a59d2207d1f4332ae44fd306e":["3766097c9c41a30d67e9b548c62d017abf8e07ac"],"65eb076d345a794256daba691a2b366657c807e8":["bf32717572de813a59d2207d1f4332ae44fd306e"],"3766097c9c41a30d67e9b548c62d017abf8e07ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["65eb076d345a794256daba691a2b366657c807e8"]},"commit2Childs":{"bf32717572de813a59d2207d1f4332ae44fd306e":["65eb076d345a794256daba691a2b366657c807e8"],"65eb076d345a794256daba691a2b366657c807e8":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"3766097c9c41a30d67e9b548c62d017abf8e07ac":["bf32717572de813a59d2207d1f4332ae44fd306e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3766097c9c41a30d67e9b548c62d017abf8e07ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}