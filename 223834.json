{"path":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","commits":[{"id":"81819c5a4a660afd353042c67106e682bb877cf1","date":1583169587,"type":0,"author":"msfroh","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","pathOld":"/dev/null","sourceNew":"  public void testMergeOnCommit() throws IOException, InterruptedException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close();\n\n    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n      @Override\n      public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) {\n        // Optimize down to a single segment on commit\n        if (mergeTrigger == MergeTrigger.COMMIT && segmentInfos.size() > 1) {\n          List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : segmentInfos) {\n            if (mergeContext.getMergingSegments().contains(sci) == false) {\n              nonMergingSegments.add(sci);\n            }\n          }\n          if (nonMergingSegments.size() > 1) {\n            MergeSpecification mergeSpecification = new MergeSpecification();\n            mergeSpecification.add(new OneMerge(nonMergingSegments));\n            return mergeSpecification;\n          }\n        }\n        return null;\n      }\n    };\n\n    AtomicInteger abandonedMerges = new AtomicInteger(0);\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(mergeOnCommitPolicy)\n        .setIndexWriterEvents(new IndexWriterEvents() {\n          @Override\n          public void beginMergeOnCommit() {\n\n          }\n\n          @Override\n          public void finishMergeOnCommit() {\n\n          }\n\n          @Override\n          public void abandonedMergesOnCommit(int abandonedCount) {\n            abandonedMerges.incrementAndGet();\n          }\n        });\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n\n    writerWithMergePolicy.commit();\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit();\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n    mergedReader.close();\n\n    LineFileDocs lineFileDocs = new LineFileDocs(random());\n    int docCount = atLeast(1000);\n    AtomicInteger indexedDocs = new AtomicInteger(0);\n    int numIndexingThreads = atLeast(2);\n    CountDownLatch startingGun = new CountDownLatch(1);\n    Collection<Thread> indexingThreads = new ArrayList<>();\n    for (int i = 0; i < numIndexingThreads; i++) {\n      Thread t = new Thread(() -> {\n        try {\n          while (indexedDocs.getAndIncrement() < docCount) {\n            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n            if (rarely()) {\n              writerWithMergePolicy.commit();\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          fail();\n        }\n      });\n      t.start();\n      indexingThreads.add(t);\n    }\n    startingGun.countDown();\n    for (Thread t : indexingThreads) {\n      t.join();\n    }\n    for (int i = 0; i < 50; i++) {\n      // Wait for pending merges to finish\n      synchronized (writerWithMergePolicy) {\n        if (writerWithMergePolicy.getMergingSegments().isEmpty()) {\n          break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    abandonedMerges.set(0);\n    writerWithMergePolicy.commit();\n    if (abandonedMerges.get() == 0) {\n      assertEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    } else {\n      assertNotEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    }\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(docCount + 6, reader.numDocs());\n      assertEquals(docCount + 6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a0fba1d4c4dd09bd1f7d6779090d0942bf071d0","date":1583191752,"type":3,"author":"msfroh","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","sourceNew":"  public void testMergeOnCommit() throws IOException, InterruptedException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close();\n\n    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n      @Override\n      public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) {\n        // Optimize down to a single segment on commit\n        if (mergeTrigger == MergeTrigger.COMMIT && segmentInfos.size() > 1) {\n          List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : segmentInfos) {\n            if (mergeContext.getMergingSegments().contains(sci) == false) {\n              nonMergingSegments.add(sci);\n            }\n          }\n          if (nonMergingSegments.size() > 1) {\n            MergeSpecification mergeSpecification = new MergeSpecification();\n            mergeSpecification.add(new OneMerge(nonMergingSegments));\n            return mergeSpecification;\n          }\n        }\n        return null;\n      }\n    };\n\n    AtomicInteger abandonedMerges = new AtomicInteger(0);\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(mergeOnCommitPolicy)\n        .setIndexWriterEvents(new IndexWriterEvents() {\n          @Override\n          public void beginMergeOnCommit() {\n\n          }\n\n          @Override\n          public void finishMergeOnCommit() {\n\n          }\n\n          @Override\n          public void abandonedMergesOnCommit(int abandonedCount) {\n            abandonedMerges.incrementAndGet();\n          }\n        });\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n\n    writerWithMergePolicy.commit();\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit();\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n    mergedReader.close();\n\n    LineFileDocs lineFileDocs = new LineFileDocs(random());\n    int docCount = atLeast(1000);\n    AtomicInteger indexedDocs = new AtomicInteger(0);\n    int numIndexingThreads = atLeast(2);\n    CountDownLatch startingGun = new CountDownLatch(1);\n    Collection<Thread> indexingThreads = new ArrayList<>();\n    for (int i = 0; i < numIndexingThreads; i++) {\n      Thread t = new Thread(() -> {\n        try {\n          startingGun.await();\n          while (indexedDocs.getAndIncrement() < docCount) {\n            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n            if (rarely()) {\n              writerWithMergePolicy.commit();\n            }\n          }\n        } catch (IOException | InterruptedException e) {\n          e.printStackTrace();\n          fail();\n        }\n      });\n      t.start();\n      indexingThreads.add(t);\n    }\n    startingGun.countDown();\n    for (Thread t : indexingThreads) {\n      t.join();\n    }\n    for (int i = 0; i < 50; i++) {\n      // Wait for pending merges to finish\n      synchronized (writerWithMergePolicy) {\n        if (writerWithMergePolicy.getMergingSegments().isEmpty()) {\n          break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    abandonedMerges.set(0);\n    // Ensure there's at least one pending change so merge on commit happens\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit();\n    if (abandonedMerges.get() == 0) {\n      assertEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    } else {\n      assertNotEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    }\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(docCount + 7, reader.numDocs());\n      assertEquals(docCount + 7, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeOnCommit() throws IOException, InterruptedException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close();\n\n    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n      @Override\n      public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) {\n        // Optimize down to a single segment on commit\n        if (mergeTrigger == MergeTrigger.COMMIT && segmentInfos.size() > 1) {\n          List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : segmentInfos) {\n            if (mergeContext.getMergingSegments().contains(sci) == false) {\n              nonMergingSegments.add(sci);\n            }\n          }\n          if (nonMergingSegments.size() > 1) {\n            MergeSpecification mergeSpecification = new MergeSpecification();\n            mergeSpecification.add(new OneMerge(nonMergingSegments));\n            return mergeSpecification;\n          }\n        }\n        return null;\n      }\n    };\n\n    AtomicInteger abandonedMerges = new AtomicInteger(0);\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(mergeOnCommitPolicy)\n        .setIndexWriterEvents(new IndexWriterEvents() {\n          @Override\n          public void beginMergeOnCommit() {\n\n          }\n\n          @Override\n          public void finishMergeOnCommit() {\n\n          }\n\n          @Override\n          public void abandonedMergesOnCommit(int abandonedCount) {\n            abandonedMerges.incrementAndGet();\n          }\n        });\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n\n    writerWithMergePolicy.commit();\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit();\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n    mergedReader.close();\n\n    LineFileDocs lineFileDocs = new LineFileDocs(random());\n    int docCount = atLeast(1000);\n    AtomicInteger indexedDocs = new AtomicInteger(0);\n    int numIndexingThreads = atLeast(2);\n    CountDownLatch startingGun = new CountDownLatch(1);\n    Collection<Thread> indexingThreads = new ArrayList<>();\n    for (int i = 0; i < numIndexingThreads; i++) {\n      Thread t = new Thread(() -> {\n        try {\n          while (indexedDocs.getAndIncrement() < docCount) {\n            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n            if (rarely()) {\n              writerWithMergePolicy.commit();\n            }\n          }\n        } catch (IOException e) {\n          e.printStackTrace();\n          fail();\n        }\n      });\n      t.start();\n      indexingThreads.add(t);\n    }\n    startingGun.countDown();\n    for (Thread t : indexingThreads) {\n      t.join();\n    }\n    for (int i = 0; i < 50; i++) {\n      // Wait for pending merges to finish\n      synchronized (writerWithMergePolicy) {\n        if (writerWithMergePolicy.getMergingSegments().isEmpty()) {\n          break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    abandonedMerges.set(0);\n    writerWithMergePolicy.commit();\n    if (abandonedMerges.get() == 0) {\n      assertEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    } else {\n      assertNotEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    }\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(docCount + 6, reader.numDocs());\n      assertEquals(docCount + 6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5","date":1583441366,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","sourceNew":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(MERGE_ON_COMMIT_POLICY);\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","sourceOld":"  public void testMergeOnCommit() throws IOException, InterruptedException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close();\n\n    MergePolicy mergeOnCommitPolicy = new LogDocMergePolicy() {\n      @Override\n      public MergeSpecification findFullFlushMerges(MergeTrigger mergeTrigger, SegmentInfos segmentInfos, MergeContext mergeContext) {\n        // Optimize down to a single segment on commit\n        if (mergeTrigger == MergeTrigger.COMMIT && segmentInfos.size() > 1) {\n          List<SegmentCommitInfo> nonMergingSegments = new ArrayList<>();\n          for (SegmentCommitInfo sci : segmentInfos) {\n            if (mergeContext.getMergingSegments().contains(sci) == false) {\n              nonMergingSegments.add(sci);\n            }\n          }\n          if (nonMergingSegments.size() > 1) {\n            MergeSpecification mergeSpecification = new MergeSpecification();\n            mergeSpecification.add(new OneMerge(nonMergingSegments));\n            return mergeSpecification;\n          }\n        }\n        return null;\n      }\n    };\n\n    AtomicInteger abandonedMerges = new AtomicInteger(0);\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(mergeOnCommitPolicy)\n        .setIndexWriterEvents(new IndexWriterEvents() {\n          @Override\n          public void beginMergeOnCommit() {\n\n          }\n\n          @Override\n          public void finishMergeOnCommit() {\n\n          }\n\n          @Override\n          public void abandonedMergesOnCommit(int abandonedCount) {\n            abandonedMerges.incrementAndGet();\n          }\n        });\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n\n    writerWithMergePolicy.commit();\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size()); // Don't merge unless there's a change\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit();\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size()); // Now we merge on commit\n    mergedReader.close();\n\n    LineFileDocs lineFileDocs = new LineFileDocs(random());\n    int docCount = atLeast(1000);\n    AtomicInteger indexedDocs = new AtomicInteger(0);\n    int numIndexingThreads = atLeast(2);\n    CountDownLatch startingGun = new CountDownLatch(1);\n    Collection<Thread> indexingThreads = new ArrayList<>();\n    for (int i = 0; i < numIndexingThreads; i++) {\n      Thread t = new Thread(() -> {\n        try {\n          startingGun.await();\n          while (indexedDocs.getAndIncrement() < docCount) {\n            writerWithMergePolicy.addDocument(lineFileDocs.nextDoc());\n            if (rarely()) {\n              writerWithMergePolicy.commit();\n            }\n          }\n        } catch (IOException | InterruptedException e) {\n          e.printStackTrace();\n          fail();\n        }\n      });\n      t.start();\n      indexingThreads.add(t);\n    }\n    startingGun.countDown();\n    for (Thread t : indexingThreads) {\n      t.join();\n    }\n    for (int i = 0; i < 50; i++) {\n      // Wait for pending merges to finish\n      synchronized (writerWithMergePolicy) {\n        if (writerWithMergePolicy.getMergingSegments().isEmpty()) {\n          break;\n        }\n      }\n      Thread.sleep(100);\n    }\n    abandonedMerges.set(0);\n    // Ensure there's at least one pending change so merge on commit happens\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit();\n    if (abandonedMerges.get() == 0) {\n      assertEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    } else {\n      assertNotEquals(1, writerWithMergePolicy.listOfSegmentCommitInfos().size());\n    }\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(docCount + 7, reader.numDocs());\n      assertEquals(docCount + 7, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba192a321314de8edbe20b279eee9c471b16b48b","date":1583706474,"type":4,"author":"Michael Sokolov","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","sourceNew":null,"sourceOld":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(MERGE_ON_COMMIT_POLICY);\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe39f1a106531207c028defebbc9eb5bb489ac50","date":1592513789,"type":0,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","pathOld":"/dev/null","sourceNew":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(MERGE_ON_COMMIT_POLICY).setMaxCommitMergeWaitSeconds(30);\n\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1182fe36fb5df768dc2da53f6d5338cbc07268ae","date":1592861749,"type":4,"author":"Michael Sokolov","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","sourceNew":null,"sourceOld":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(MERGE_ON_COMMIT_POLICY).setMaxCommitMergeWaitSeconds(30);\n\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c2a23476693f2bd9a4b44cc3187c429a2e21dac2","date":1593289545,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","pathOld":"/dev/null","sourceNew":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(MERGE_ON_COMMIT_POLICY).setMaxCommitMergeWaitMillis(Integer.MAX_VALUE);\n\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f354ba79a5a3e8491ec2953f14f365a02c058ac","date":1598293148,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","pathOld":"lucene/core/src/test/org/apache/lucene/index/TestIndexWriterMergePolicy#testMergeOnCommit().mjava","sourceNew":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(new MergeOnXMergePolicy(newMergePolicy(), MergeTrigger.COMMIT)).setMaxFullFlushMergeWaitMillis(Integer.MAX_VALUE);\n\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","sourceOld":"  // Test basic semantics of merge on commit\n  public void testMergeOnCommit() throws IOException {\n    Directory dir = newDirectory();\n\n    IndexWriter firstWriter = new IndexWriter(dir, newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(NoMergePolicy.INSTANCE));\n    for (int i = 0; i < 5; i++) {\n      TestIndexWriter.addDoc(firstWriter);\n      firstWriter.flush();\n    }\n    DirectoryReader firstReader = DirectoryReader.open(firstWriter);\n    assertEquals(5, firstReader.leaves().size());\n    firstReader.close();\n    firstWriter.close(); // When this writer closes, it does not merge on commit.\n\n    IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()))\n        .setMergePolicy(MERGE_ON_COMMIT_POLICY).setMaxCommitMergeWaitMillis(Integer.MAX_VALUE);\n\n\n    IndexWriter writerWithMergePolicy = new IndexWriter(dir, iwc);\n    writerWithMergePolicy.commit(); // No changes. Commit doesn't trigger a merge.\n\n    DirectoryReader unmergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(5, unmergedReader.leaves().size());\n    unmergedReader.close();\n\n    TestIndexWriter.addDoc(writerWithMergePolicy);\n    writerWithMergePolicy.commit(); // Doc added, do merge on commit.\n    assertEquals(1, writerWithMergePolicy.getSegmentCount()); //\n\n    DirectoryReader mergedReader = DirectoryReader.open(writerWithMergePolicy);\n    assertEquals(1, mergedReader.leaves().size());\n    mergedReader.close();\n\n    try (IndexReader reader = writerWithMergePolicy.getReader()) {\n      IndexSearcher searcher = new IndexSearcher(reader);\n      assertEquals(6, reader.numDocs());\n      assertEquals(6, searcher.count(new MatchAllDocsQuery()));\n    }\n\n    writerWithMergePolicy.close();\n    dir.close();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"ba192a321314de8edbe20b279eee9c471b16b48b":["fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5":["0a0fba1d4c4dd09bd1f7d6779090d0942bf071d0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"0a0fba1d4c4dd09bd1f7d6779090d0942bf071d0":["81819c5a4a660afd353042c67106e682bb877cf1"],"81819c5a4a660afd353042c67106e682bb877cf1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["ba192a321314de8edbe20b279eee9c471b16b48b"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"]},"commit2Childs":{"ba192a321314de8edbe20b279eee9c471b16b48b":["fe39f1a106531207c028defebbc9eb5bb489ac50"],"c2a23476693f2bd9a4b44cc3187c429a2e21dac2":["3f354ba79a5a3e8491ec2953f14f365a02c058ac"],"fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5":["ba192a321314de8edbe20b279eee9c471b16b48b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["81819c5a4a660afd353042c67106e682bb877cf1"],"0a0fba1d4c4dd09bd1f7d6779090d0942bf071d0":["fe1dc1107e70a3ffaa5d6ce6801458a59923b1b5"],"81819c5a4a660afd353042c67106e682bb877cf1":["0a0fba1d4c4dd09bd1f7d6779090d0942bf071d0"],"1182fe36fb5df768dc2da53f6d5338cbc07268ae":["c2a23476693f2bd9a4b44cc3187c429a2e21dac2"],"fe39f1a106531207c028defebbc9eb5bb489ac50":["1182fe36fb5df768dc2da53f6d5338cbc07268ae"],"3f354ba79a5a3e8491ec2953f14f365a02c058ac":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}