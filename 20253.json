{"path":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e470e29caa5c5200b096b6e282e9e657bc591bfb","date":1269888021,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":["3b6f51785c57651e9e1864b7b883037f24541c76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7b463204b25ac5d8c308b5671ab045542a817efa","date":1270065281,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\n\tif (longX2 != 0.0) {\n\t\t//We are around the prime meridian\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {//we are around the 180th longitude\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n\t\t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t}\n\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n    if (longX2 != 0.0) {\n\tif (longX2 != 0.0) {\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \t\tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n        \t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t\t}\n\t}\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":["3b6f51785c57651e9e1864b7b883037f24541c76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"874647a46122c7eeec2e5c004239075f7b13891a","date":1270065749,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n\t//In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then \n\t//from the meridan to the upper right\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\n\tif (longX2 != 0.0) {\n\t\t//We are around the prime meridian\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {//we are around the 180th longitude\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n\t\t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t}\n\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\n\tif (longX2 != 0.0) {\n\t\t//We are around the prime meridian\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {//we are around the 180th longitude\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n\t\t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t}\n\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":["3b6f51785c57651e9e1864b7b883037f24541c76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"898a51f1e284c6a04897872ac91d1180e7216937","date":1270127087,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n\t//In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then \n\t//from the meridan to the upper right\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\t//for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\tif (longX2 != 0.0) {\n\t      if (longX == 0.0) {\n\t        longX = longX2;\n\t        longY = 0.0;\n\t        //handles the lower left longitude to the prime meridian\n\t        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\t      } else {\n\t        //this clause handles the lower left longitude up to the 180 meridian\n\t        longX = longX2;\n\t        longY = 180.0;\n\t      }\n\t      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n\t      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n\t        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n\t    }\n\t\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n\t//In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then \n\t//from the meridan to the upper right\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\n\tif (longX2 != 0.0) {\n\t\t//We are around the prime meridian\n\t\tif (longX == 0.0) {\n\t\t\tlongX = longX2;\n\t\t\tlongY = 0.0;\n        \tshape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\t\t} else {//we are around the 180th longitude\n\t\t\tlongX = longX2;\n\t\t\tlongY = -180.0;\n\t\t\tshape = getShapeLoop(shape,ctp,latY,longY,latX,longX);\n\t}\n\n        //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":["3b6f51785c57651e9e1864b7b883037f24541c76"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3b6f51785c57651e9e1864b7b883037f24541c76","date":1271186480,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng lowerLeft = box1.getLowerLeft();\n    LatLng upperRight = box1.getUpperRight();\n\n    double latUpperRight = upperRight.getLat();\n    double latLowerLeft = lowerLeft.getLat();\n    double longUpperRight = upperRight.getLng();\n    double longLowerLeft = lowerLeft.getLng();\n\n    CartesianTierPlotter ctp = new CartesianTierPlotter( miles, projector, tierPrefix );\n    Shape shape = new Shape(ctp.getTierLevelId());\n\n    if (longUpperRight < longLowerLeft) { // Box cross the 180 meridian\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, LatLng.LONGITUDE_DEGREE_MAX);\n      addBoxes(shape, ctp, latLowerLeft, -LatLng.LONGITUDE_DEGREE_MIN, latUpperRight, longUpperRight);\n    } else {\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, longUpperRight);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n\t//In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then \n\t//from the meridan to the upper right\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\t//for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\tif (longX2 != 0.0) {\n\t      if (longX == 0.0) {\n\t        longX = longX2;\n\t        longY = 0.0;\n\t        //handles the lower left longitude to the prime meridian\n\t        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\t      } else {\n\t        //this clause handles the lower left longitude up to the 180 meridian\n\t        longX = longX2;\n\t        longY = 180.0;\n\t      }\n\t      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n\t      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n\t        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n\t    }\n\t\n \n    return shape; \n  } \n\n","bugFix":["7b463204b25ac5d8c308b5671ab045542a817efa","04a4a94db1eb59c8583adb166acfe686a031bedc","c057d06d0103fe57745280be1f2e5da933210462","898a51f1e284c6a04897872ac91d1180e7216937","0a04035855bf53c50aaef580f2ec794acf73029e","874647a46122c7eeec2e5c004239075f7b13891a","e470e29caa5c5200b096b6e282e9e657bc591bfb"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f2b0ba43649ebd893dd536677af71d1f5f59e2a4","date":1271241696,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng lowerLeft = box1.getLowerLeft();\n    LatLng upperRight = box1.getUpperRight();\n\n    double latUpperRight = upperRight.getLat();\n    double latLowerLeft = lowerLeft.getLat();\n    double longUpperRight = upperRight.getLng();\n    double longLowerLeft = lowerLeft.getLng();\n\n    CartesianTierPlotter ctp = new CartesianTierPlotter( miles, projector, tierPrefix, minTier, maxTier );\n    Shape shape = new Shape(ctp.getTierLevelId());\n\n    if (longUpperRight < longLowerLeft) { // Box cross the 180 meridian\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, LatLng.LONGITUDE_DEGREE_MAX);\n      addBoxes(shape, ctp, latLowerLeft, -LatLng.LONGITUDE_DEGREE_MIN, latUpperRight, longUpperRight);\n    } else {\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, longUpperRight);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng lowerLeft = box1.getLowerLeft();\n    LatLng upperRight = box1.getUpperRight();\n\n    double latUpperRight = upperRight.getLat();\n    double latLowerLeft = lowerLeft.getLat();\n    double longUpperRight = upperRight.getLng();\n    double longLowerLeft = lowerLeft.getLng();\n\n    CartesianTierPlotter ctp = new CartesianTierPlotter( miles, projector, tierPrefix );\n    Shape shape = new Shape(ctp.getTierLevelId());\n\n    if (longUpperRight < longLowerLeft) { // Box cross the 180 meridian\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, LatLng.LONGITUDE_DEGREE_MAX);\n      addBoxes(shape, ctp, latLowerLeft, -LatLng.LONGITUDE_DEGREE_MIN, latUpperRight, longUpperRight);\n    } else {\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, longUpperRight);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":["ae346e1b9114f24145c75e8edf720c1e2db5b448"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ae346e1b9114f24145c75e8edf720c1e2db5b448","date":1271251510,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng lowerLeft = box1.getLowerLeft();\n    LatLng upperRight = box1.getUpperRight();\n\n    double latUpperRight = upperRight.getLat();\n    double latLowerLeft = lowerLeft.getLat();\n    double longUpperRight = upperRight.getLng();\n    double longLowerLeft = lowerLeft.getLng();\n\n    CartesianTierPlotter ctp = new CartesianTierPlotter( CartesianTierPlotter.bestFit(miles, minTier, maxTier), projector, tierPrefix);\n    Shape shape = new Shape(ctp.getTierLevelId());\n\n    if (longUpperRight < longLowerLeft) { // Box cross the 180 meridian\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, LatLng.LONGITUDE_DEGREE_MAX);\n      addBoxes(shape, ctp, latLowerLeft, -LatLng.LONGITUDE_DEGREE_MIN, latUpperRight, longUpperRight);\n    } else {\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, longUpperRight);\n    }\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng lowerLeft = box1.getLowerLeft();\n    LatLng upperRight = box1.getUpperRight();\n\n    double latUpperRight = upperRight.getLat();\n    double latLowerLeft = lowerLeft.getLat();\n    double longUpperRight = upperRight.getLng();\n    double longLowerLeft = lowerLeft.getLng();\n\n    CartesianTierPlotter ctp = new CartesianTierPlotter( miles, projector, tierPrefix, minTier, maxTier );\n    Shape shape = new Shape(ctp.getTierLevelId());\n\n    if (longUpperRight < longLowerLeft) { // Box cross the 180 meridian\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, LatLng.LONGITUDE_DEGREE_MAX);\n      addBoxes(shape, ctp, latLowerLeft, -LatLng.LONGITUDE_DEGREE_MIN, latUpperRight, longUpperRight);\n    } else {\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, longUpperRight);\n    }\n \n    return shape; \n  } \n\n","bugFix":["f2b0ba43649ebd893dd536677af71d1f5f59e2a4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8e6ff1dd868eee0c9202357a60a5636ad62cb0c5","date":1271290552,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n\t//In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then \n\t//from the meridan to the upper right\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\t//for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\tif (longX2 != 0.0) {\n\t      if (longX == 0.0) {\n\t        longX = longX2;\n\t        longY = 0.0;\n\t        //handles the lower left longitude to the prime meridian\n\t        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\t      } else {\n\t        //this clause handles the lower left longitude up to the 180 meridian\n\t        longX = longX2;\n\t        longY = 180.0;\n\t      }\n\t      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n\t      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n\t        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n\t    }\n\t\n \n    return shape; \n  } \n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng lowerLeft = box1.getLowerLeft();\n    LatLng upperRight = box1.getUpperRight();\n\n    double latUpperRight = upperRight.getLat();\n    double latLowerLeft = lowerLeft.getLat();\n    double longUpperRight = upperRight.getLng();\n    double longLowerLeft = lowerLeft.getLng();\n\n    CartesianTierPlotter ctp = new CartesianTierPlotter( CartesianTierPlotter.bestFit(miles, minTier, maxTier), projector, tierPrefix);\n    Shape shape = new Shape(ctp.getTierLevelId());\n\n    if (longUpperRight < longLowerLeft) { // Box cross the 180 meridian\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, LatLng.LONGITUDE_DEGREE_MAX);\n      addBoxes(shape, ctp, latLowerLeft, -LatLng.LONGITUDE_DEGREE_MIN, latUpperRight, longUpperRight);\n    } else {\n      addBoxes(shape, ctp, latLowerLeft, longLowerLeft, latUpperRight, longUpperRight);\n    }\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"136b98ba17597f6320aebd8a1e7e997fae9e80d9","date":1271423734,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":"  public Shape getBoxShape(double latitude, double longitude, double miles) {\n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox(new FloatLatLng(latitude, longitude), miles, miles);\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n    //These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n    //In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then\n    //from the meridan to the upper right\n    //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n      longX2 = ll.getLng();\n      longX = -180.0;\n    }\n    //are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n      longX2 = ll.getLng();\n      longX = 0.0;\n    }\n\n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector, tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    if (bestFit < minTier) {\n      bestFit = minTier;\n    } else if (bestFit > maxTier) {\n      bestFit = maxTier;\n    }\n\n    ctp = new CartesianTierPlotter(bestFit, projector, tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n\n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    //for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n    if (longX2 != 0.0) {\n      if (longX == 0.0) {\n        longX = longX2;\n        longY = 0.0;\n        //handles the lower left longitude to the prime meridian\n        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n      } else {\n        //this clause handles the lower left longitude up to the 180 meridian\n        longX = longX2;\n        longY = 180.0;\n      }\n      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n      //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n\n\n    return shape;\n  }\n\n","sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles)\n  {  \n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox( new FloatLatLng( latitude, longitude ), miles, miles );\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n\t//These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n\t//In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then \n\t//from the meridan to the upper right\n\t//Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = -180.0;\t\n    }\n\t//are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n\tlongX2 = ll.getLng();\n \tlongX = 0.0;\t\n    }\n    \n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector,tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n\tif (bestFit < minTier){\n\t\tbestFit = minTier;\n\t} else if (bestFit > maxTier){\n\t\tbestFit = maxTier;\n\t}\n    \n    ctp = new CartesianTierPlotter(bestFit, projector,tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n    \n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n\t//for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape,ctp,latX,longX,latY,longY);\n\tif (longX2 != 0.0) {\n\t      if (longX == 0.0) {\n\t        longX = longX2;\n\t        longY = 0.0;\n\t        //handles the lower left longitude to the prime meridian\n\t        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\t      } else {\n\t        //this clause handles the lower left longitude up to the 180 meridian\n\t        longX = longX2;\n\t        longY = 180.0;\n\t      }\n\t      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n\t      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n\t        //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n\t    }\n\t\n \n    return shape; \n  } \n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2fb7e38713d15939e085d376c6391e6e6262a81f","date":1329897272,"type":4,"author":"David Wayne Smiley","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":null,"sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles) {\n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox(new FloatLatLng(latitude, longitude), miles, miles);\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n    //These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n    //In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then\n    //from the meridan to the upper right\n    //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n      longX2 = ll.getLng();\n      longX = -180.0;\n    }\n    //are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n      longX2 = ll.getLng();\n      longX = 0.0;\n    }\n\n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector, tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    if (bestFit < minTier) {\n      bestFit = minTier;\n    } else if (bestFit > maxTier) {\n      bestFit = maxTier;\n    }\n\n    ctp = new CartesianTierPlotter(bestFit, projector, tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n\n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    //for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n    if (longX2 != 0.0) {\n      if (longX == 0.0) {\n        longX = longX2;\n        longY = 0.0;\n        //handles the lower left longitude to the prime meridian\n        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n      } else {\n        //this clause handles the lower left longitude up to the 180 meridian\n        longX = longX2;\n        longY = 180.0;\n      }\n      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n      //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n\n\n    return shape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e47768b261c28e7e6032060e8331475c81057953","date":1331681297,"type":4,"author":"Ryan McKinley","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/contrib/spatial/src/java/org/apache/lucene/spatial/tier/CartesianPolyFilterBuilder#getBoxShape(double,double,double).mjava","sourceNew":null,"sourceOld":"  public Shape getBoxShape(double latitude, double longitude, double miles) {\n    if (miles < MILES_FLOOR) {\n      miles = MILES_FLOOR;\n    }\n    LLRect box1 = LLRect.createBox(new FloatLatLng(latitude, longitude), miles, miles);\n    LatLng ll = box1.getLowerLeft();\n    LatLng ur = box1.getUpperRight();\n\n    double latY = ur.getLat();\n    double latX = ll.getLat();\n    double longY = ur.getLng();\n    double longX = ll.getLng();\n    double longX2 = 0.0;\n    //These two if checks setup us up to deal with issues around the prime meridian and the 180th meridian\n    //In these two cases, we need to get tiles (tiers) from the lower left up to the meridian and then\n    //from the meridan to the upper right\n    //Are we crossing the 180 deg. longitude, if so, we need to do some special things\n    if (ur.getLng() < 0.0 && ll.getLng() > 0.0) {\n      longX2 = ll.getLng();\n      longX = -180.0;\n    }\n    //are we crossing the prime meridian (0 degrees)?  If so, we need to account for it and boxes on both sides\n    if (ur.getLng() > 0.0 && ll.getLng() < 0.0) {\n      longX2 = ll.getLng();\n      longX = 0.0;\n    }\n\n    //System.err.println(\"getBoxShape:\"+latY+\",\" + longY);\n    //System.err.println(\"getBoxShape:\"+latX+\",\" + longX);\n    CartesianTierPlotter ctp = new CartesianTierPlotter(2, projector, tierPrefix);\n    int bestFit = ctp.bestFit(miles);\n    if (bestFit < minTier) {\n      bestFit = minTier;\n    } else if (bestFit > maxTier) {\n      bestFit = maxTier;\n    }\n\n    ctp = new CartesianTierPlotter(bestFit, projector, tierPrefix);\n    Shape shape = new Shape(ctp.getTierFieldName());\n\n    // generate shape\n    // iterate from startX->endX\n    //     iterate from startY -> endY\n    //      shape.add(currentLat.currentLong);\n    //for the edge cases (prime meridian and the 180th meridian), this call handles all tiles East of the meridian\n    //for all other cases, it handles the whole set of tiles\n    shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n    if (longX2 != 0.0) {\n      if (longX == 0.0) {\n        longX = longX2;\n        longY = 0.0;\n        //handles the lower left longitude to the prime meridian\n        //shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n      } else {\n        //this clause handles the lower left longitude up to the 180 meridian\n        longX = longX2;\n        longY = 180.0;\n      }\n      shape = getShapeLoop(shape, ctp, latX, longX, latY, longY);\n\n      //System.err.println(\"getBoxShape2:\"+latY+\",\" + longY);\n      //System.err.println(\"getBoxShape2:\"+latX+\",\" + longX);\n    }\n\n\n    return shape;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3b6f51785c57651e9e1864b7b883037f24541c76":["898a51f1e284c6a04897872ac91d1180e7216937"],"e470e29caa5c5200b096b6e282e9e657bc591bfb":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"874647a46122c7eeec2e5c004239075f7b13891a":["7b463204b25ac5d8c308b5671ab045542a817efa"],"f2b0ba43649ebd893dd536677af71d1f5f59e2a4":["3b6f51785c57651e9e1864b7b883037f24541c76"],"7b463204b25ac5d8c308b5671ab045542a817efa":["e470e29caa5c5200b096b6e282e9e657bc591bfb"],"2fb7e38713d15939e085d376c6391e6e6262a81f":["136b98ba17597f6320aebd8a1e7e997fae9e80d9"],"136b98ba17597f6320aebd8a1e7e997fae9e80d9":["8e6ff1dd868eee0c9202357a60a5636ad62cb0c5"],"898a51f1e284c6a04897872ac91d1180e7216937":["874647a46122c7eeec2e5c004239075f7b13891a"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8e6ff1dd868eee0c9202357a60a5636ad62cb0c5":["ae346e1b9114f24145c75e8edf720c1e2db5b448"],"ae346e1b9114f24145c75e8edf720c1e2db5b448":["f2b0ba43649ebd893dd536677af71d1f5f59e2a4"],"e47768b261c28e7e6032060e8331475c81057953":["136b98ba17597f6320aebd8a1e7e997fae9e80d9","2fb7e38713d15939e085d376c6391e6e6262a81f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["e47768b261c28e7e6032060e8331475c81057953"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3b6f51785c57651e9e1864b7b883037f24541c76":["f2b0ba43649ebd893dd536677af71d1f5f59e2a4"],"e470e29caa5c5200b096b6e282e9e657bc591bfb":["7b463204b25ac5d8c308b5671ab045542a817efa"],"874647a46122c7eeec2e5c004239075f7b13891a":["898a51f1e284c6a04897872ac91d1180e7216937"],"f2b0ba43649ebd893dd536677af71d1f5f59e2a4":["ae346e1b9114f24145c75e8edf720c1e2db5b448"],"7b463204b25ac5d8c308b5671ab045542a817efa":["874647a46122c7eeec2e5c004239075f7b13891a"],"2fb7e38713d15939e085d376c6391e6e6262a81f":["e47768b261c28e7e6032060e8331475c81057953"],"136b98ba17597f6320aebd8a1e7e997fae9e80d9":["2fb7e38713d15939e085d376c6391e6e6262a81f","e47768b261c28e7e6032060e8331475c81057953"],"898a51f1e284c6a04897872ac91d1180e7216937":["3b6f51785c57651e9e1864b7b883037f24541c76"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"8e6ff1dd868eee0c9202357a60a5636ad62cb0c5":["136b98ba17597f6320aebd8a1e7e997fae9e80d9"],"ae346e1b9114f24145c75e8edf720c1e2db5b448":["8e6ff1dd868eee0c9202357a60a5636ad62cb0c5"],"e47768b261c28e7e6032060e8331475c81057953":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["e470e29caa5c5200b096b6e282e9e657bc591bfb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}