{"path":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","commits":[{"id":"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767","date":1520865397,"type":1,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testMetadata().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasProperties(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testMetadata() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set metadata\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more metadata\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove metadata\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasMetadata(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasMetadata(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n    assertNotNull(meta);\n\n    // old metadata still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new metadata added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasMetadata(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasMetadata(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a980795a56f2fcbc94caeb3233071312d5684d59","date":1524255736,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasProperties(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    UnaryOperator<Aliases> op5 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\");\n    aliasesManager.applyModificationAndExportToZk(op5);\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    UnaryOperator<Aliases> op4 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\");\n    aliasesManager.applyModificationAndExportToZk(op4);\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    UnaryOperator<Aliases> op3 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op3);\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    UnaryOperator<Aliases> op2 = a -> a.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null);\n    aliasesManager.applyModificationAndExportToZk(op2);\n\n    // chained invocations\n    UnaryOperator<Aliases> op1 = a ->\n        a.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\");\n    aliasesManager.applyModificationAndExportToZk(op1);\n\n    // some other independent update (not overwritten)\n    UnaryOperator<Aliases> op = a -> a.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\");\n    aliasesManager.applyModificationAndExportToZk(op);\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasProperties(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":["3cbd743a4843f513f793670e3ab0e272bf824faf","7e16ac84f9e5d560008fe1554462ff8b853b3d3c","6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767","215e40821821b2df2e69355e208532c05ef095a5"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"db3a95645baea7e03cf8ae62147cba606639004e","date":1525745850,"type":3,"author":"David Smiley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    UnaryOperator<Aliases> op6 = a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\");\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(op6);\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    String zkAddress = cluster.getZkServer().getZkAddress();\n    boolean createdZKSR = false;\n    try(SolrZkClient zkClient = new SolrZkClient(zkAddress, 30000)) {\n\n      ZkController.createClusterZkNodes(zkClient);\n\n      zkStateReader = new ZkStateReader(zkClient);\n      createdZKSR = true;\n      zkStateReader.createClusterStateWatchersAndUpdate();\n\n      meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n      assertNotNull(meta);\n\n      // verify key was removed in independent view\n      assertFalse(meta.containsKey(\"foo\"));\n\n      // but only the specified key was removed\n      assertTrue(meta.containsKey(\"foobar\"));\n      assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n      Aliases a = zkStateReader.getAliases();\n      Aliases clone = a.cloneWithCollectionAlias(\"meta1\", null);\n      meta = clone.getCollectionAliasProperties(\"meta1\");\n      assertEquals(0,meta.size());\n    } finally {\n      if (createdZKSR) {\n        zkStateReader.close();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e","date":1529622176,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  //@BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\")\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n    \n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 1));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":["215e40821821b2df2e69355e208532c05ef095a5"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1eebf1b080530bdd7572c4927fb2bb52334b7a86","date":1563199033,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n    \n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n    \n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98520789adb1d5ad05afb4956eca0944a929688","date":1592430701,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"eba8995e4d085569e201ecf8bf75d1cb02fa74bf","date":1592955411,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/AliasIntegrationTest#testProperties().mjava","sourceNew":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","sourceOld":"  @Test\n  @SuppressWarnings({\"unchecked\"})\n  public void testProperties() throws Exception {\n    CollectionAdminRequest.createCollection(\"collection1meta\", \"conf\", 2, 1).process(cluster.getSolrClient());\n    CollectionAdminRequest.createCollection(\"collection2meta\", \"conf\", 1, 1).process(cluster.getSolrClient());\n\n    cluster.waitForActiveCollection(\"collection1meta\", 2, 2);\n    cluster.waitForActiveCollection(\"collection2meta\", 1, 1);\n\n    waitForState(\"Expected collection1 to be created with 2 shards and 1 replica\", \"collection1meta\", clusterShape(2, 2));\n    waitForState(\"Expected collection2 to be created with 1 shard and 1 replica\", \"collection2meta\", clusterShape(1, 1));\n    ZkStateReader zkStateReader = cluster.getSolrClient().getZkStateReader();\n    zkStateReader.createClusterStateWatchersAndUpdate();\n    List<String> aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(1, aliases.size());\n    assertEquals(\"meta1\", aliases.get(0));\n    final ZkStateReader.AliasesManager aliasesManager = zkStateReader.aliasesManager;\n\n    aliasesManager.applyModificationAndExportToZk(a -> a.cloneWithCollectionAlias(\"meta1\", \"collection1meta,collection2meta\"));\n    aliases = zkStateReader.getAliases().resolveAliases(\"meta1\");\n    assertEquals(2, aliases.size());\n    assertEquals(\"collection1meta\", aliases.get(0));\n    assertEquals(\"collection2meta\", aliases.get(1));\n    //ensure we have the back-compat format in ZK:\n    final byte[] rawBytes = zkStateReader.getZkClient().getData(ALIASES, null, null, true);\n    //noinspection unchecked\n    assertTrue(((Map<String,Map<String,?>>)Utils.fromJSON(rawBytes)).get(\"collection\").get(\"meta1\") instanceof String);\n\n    // set properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", \"bar\"));\n    Map<String, String> meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // set more properties\n    aliasesManager.applyModificationAndExportToZk( a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foobar\", \"bazbam\"));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foo\"));\n    assertEquals(\"bar\", meta.get(\"foo\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // remove properties\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // verify key was removed\n    assertFalse(meta.containsKey(\"foo\"));\n\n    // but only the specified key was removed\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // removal of non existent key should succeed.\n    aliasesManager.applyModificationAndExportToZk(a2 ->\n        a2.cloneWithCollectionAliasProperties(\"meta1\", \"foo\", null));\n\n    // chained invocations\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAliasProperties(\"meta1\", \"foo2\", \"bazbam\")\n        .cloneWithCollectionAliasProperties(\"meta1\", \"foo3\", \"bazbam2\"));\n\n    // some other independent update (not overwritten)\n    aliasesManager.applyModificationAndExportToZk(a1 ->\n        a1.cloneWithCollectionAlias(\"meta3\", \"collection1meta,collection2meta\"));\n\n    // competing went through\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    meta = zkStateReader.getAliases().getCollectionAliasProperties(\"meta1\");\n    assertNotNull(meta);\n\n    // old properties still there\n    assertTrue(meta.containsKey(\"foobar\"));\n    assertEquals(\"bazbam\", meta.get(\"foobar\"));\n\n    // competing update not overwritten\n    assertEquals(\"collection1meta,collection2meta\", zkStateReader.getAliases().getCollectionAliasMap().get(\"meta3\"));\n\n    // new properties added\n    assertTrue(meta.containsKey(\"foo2\"));\n    assertEquals(\"bazbam\", meta.get(\"foo2\"));\n    assertTrue(meta.containsKey(\"foo3\"));\n    assertEquals(\"bazbam2\", meta.get(\"foo3\"));\n\n    // now check that an independently constructed ZkStateReader can see what we've done.\n    // i.e. the data is really in zookeeper\n    try (SolrZkClient zkClient = new SolrZkClient(cluster.getZkServer().getZkAddress(), 30000)) {\n      ZkController.createClusterZkNodes(zkClient);\n      try (ZkStateReader zkStateReader2 = new ZkStateReader(zkClient)) {\n        zkStateReader2.createClusterStateWatchersAndUpdate();\n\n        meta = zkStateReader2.getAliases().getCollectionAliasProperties(\"meta1\");\n        assertNotNull(meta);\n\n        // verify key was removed in independent view\n        assertFalse(meta.containsKey(\"foo\"));\n\n        // but only the specified key was removed\n        assertTrue(meta.containsKey(\"foobar\"));\n        assertEquals(\"bazbam\", meta.get(\"foobar\"));\n      }\n    }\n\n    // check removal leaves no props behind\n    assertEquals(0, zkStateReader.getAliases()\n        .cloneWithCollectionAlias(\"meta1\", null) // not persisted to zk on purpose\n        .getCollectionAliasProperties(\"meta1\")\n        .size());\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a980795a56f2fcbc94caeb3233071312d5684d59":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["db3a95645baea7e03cf8ae62147cba606639004e","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"db3a95645baea7e03cf8ae62147cba606639004e":["a980795a56f2fcbc94caeb3233071312d5684d59"],"eba8995e4d085569e201ecf8bf75d1cb02fa74bf":["e98520789adb1d5ad05afb4956eca0944a929688"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e":["db3a95645baea7e03cf8ae62147cba606639004e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["eba8995e4d085569e201ecf8bf75d1cb02fa74bf"],"e98520789adb1d5ad05afb4956eca0944a929688":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["db3a95645baea7e03cf8ae62147cba606639004e","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e"]},"commit2Childs":{"a980795a56f2fcbc94caeb3233071312d5684d59":["db3a95645baea7e03cf8ae62147cba606639004e"],"6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767":["a980795a56f2fcbc94caeb3233071312d5684d59"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["1eebf1b080530bdd7572c4927fb2bb52334b7a86"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6f29e9eb6c1655cd0b273f3c0dcdf43bc0822767"],"db3a95645baea7e03cf8ae62147cba606639004e":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","7a7544ad4b63d1b5f556c3da8f9c63d332aa034e","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"eba8995e4d085569e201ecf8bf75d1cb02fa74bf":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"1eebf1b080530bdd7572c4927fb2bb52334b7a86":["e98520789adb1d5ad05afb4956eca0944a929688"],"7a7544ad4b63d1b5f556c3da8f9c63d332aa034e":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","bb222a3f9d9421d5c95afce73013fbd8de07ea1f","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"e98520789adb1d5ad05afb4956eca0944a929688":["eba8995e4d085569e201ecf8bf75d1cb02fa74bf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}