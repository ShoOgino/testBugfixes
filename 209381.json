{"path":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimScenario.LoadAutoscaling#execute(SimScenario).mjava","commits":[{"id":"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d","date":1571856490,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimScenario.LoadAutoscaling#execute(SimScenario).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public void execute(SimScenario scenario) throws Exception {\n      Map<String, Object> map;\n      boolean addDefaults = Boolean.parseBoolean(params.get(\"withDefaultTriggers\", \"true\"));\n      int defaultWaitFor = Integer.parseInt(params.get(\"defaultWaitFor\", \"120\"));\n      String path = params.get(\"path\");\n      if (path == null) {\n        String json = params.get(\"json\");\n        if (json == null) {\n          throw new IOException(SimAction.LOAD_AUTOSCALING + \" must specify either 'path' or 'json'\");\n        } else {\n          map = (Map<String, Object>) Utils.fromJSONString(json);\n        }\n      } else {\n        File f = new File(path);\n        Reader r;\n        if (f.exists()) {\n          r = new InputStreamReader(new FileInputStream(f), Charset.forName(\"UTF-8\"));\n        } else {\n          InputStream is = getClass().getResourceAsStream(path);\n          if (is == null) {\n            throw new IOException(\"path \" + path + \" does not exist and it's not a resource\");\n          }\n          r = new InputStreamReader(is, Charset.forName(\"UTF-8\"));\n        }\n        map = (Map<String, Object>) Utils.fromJSON(r);\n      }\n      AutoScalingConfig config = new AutoScalingConfig(map);\n      if (addDefaults) {\n        // add default triggers\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME)) {\n          Map<String, Object> props = new HashMap<>(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_PROPS);\n          props.put(\"waitFor\", defaultWaitFor);\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME, props);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME);\n        }\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME)) {\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_PROPS);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME);\n        }\n      }\n      scenario.config = config;\n      // set this config on the simulator\n      scenario.cluster.getSimDistribStateManager().simSetAutoScalingConfig(config);\n      // wait until it finished processing the config\n      (new TimeOut(30, TimeUnit.SECONDS, scenario.cluster.getTimeSource()))\n          .waitFor(\"OverseerTriggerThread never caught up to the latest znodeVersion\", () -> {\n            try {\n              AutoScalingConfig autoscalingConfig = scenario.cluster.getDistribStateManager().getAutoScalingConfig();\n              return autoscalingConfig.getZkVersion() == scenario.cluster.getOverseerTriggerThread().getProcessedZnodeVersion();\n            } catch (Exception e) {\n              throw new RuntimeException(\"FAILED\", e);\n            }\n          });\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"daa0f21a44e235a2299ea1fa913898b182dd7cce","date":1590952026,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimScenario.LoadAutoscaling#execute(SimScenario).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimScenario.LoadAutoscaling#execute(SimScenario).mjava","sourceNew":"    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public void execute(SimScenario scenario) throws Exception {\n      Map<String, Object> map;\n      boolean addDefaults = Boolean.parseBoolean(params.get(\"withDefaultTriggers\", \"true\"));\n      int defaultWaitFor = Integer.parseInt(params.get(\"defaultWaitFor\", \"120\"));\n      String path = params.get(\"path\");\n      if (path == null) {\n        String json = params.get(\"json\");\n        if (json == null) {\n          throw new IOException(SimAction.LOAD_AUTOSCALING + \" must specify either 'path' or 'json'\");\n        } else {\n          map = (Map<String, Object>) Utils.fromJSONString(json);\n        }\n      } else {\n        File f = new File(path);\n        Reader r;\n        if (f.exists()) {\n          r = new InputStreamReader(new FileInputStream(f), Charset.forName(\"UTF-8\"));\n        } else {\n          InputStream is = getClass().getResourceAsStream(path);\n          if (is == null) {\n            throw new IOException(\"path \" + path + \" does not exist and it's not a resource\");\n          }\n          r = new InputStreamReader(is, Charset.forName(\"UTF-8\"));\n        }\n        map = (Map<String, Object>) Utils.fromJSON(r);\n      }\n      AutoScalingConfig config = new AutoScalingConfig(map);\n      if (addDefaults) {\n        // add default triggers\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME)) {\n          Map<String, Object> props = new HashMap<>(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_PROPS);\n          props.put(\"waitFor\", defaultWaitFor);\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME, props);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME);\n        }\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME)) {\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_PROPS);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME);\n        }\n      }\n      scenario.config = config;\n      // set this config on the simulator\n      scenario.cluster.getSimDistribStateManager().simSetAutoScalingConfig(config);\n      // wait until it finished processing the config\n      (new TimeOut(30, TimeUnit.SECONDS, scenario.cluster.getTimeSource()))\n          .waitFor(\"OverseerTriggerThread never caught up to the latest znodeVersion\", () -> {\n            try {\n              AutoScalingConfig autoscalingConfig = scenario.cluster.getDistribStateManager().getAutoScalingConfig();\n              return autoscalingConfig.getZkVersion() == scenario.cluster.getOverseerTriggerThread().getProcessedZnodeVersion();\n            } catch (Exception e) {\n              throw new RuntimeException(\"FAILED\", e);\n            }\n          });\n\n    }\n\n","sourceOld":"    @Override\n    public void execute(SimScenario scenario) throws Exception {\n      Map<String, Object> map;\n      boolean addDefaults = Boolean.parseBoolean(params.get(\"withDefaultTriggers\", \"true\"));\n      int defaultWaitFor = Integer.parseInt(params.get(\"defaultWaitFor\", \"120\"));\n      String path = params.get(\"path\");\n      if (path == null) {\n        String json = params.get(\"json\");\n        if (json == null) {\n          throw new IOException(SimAction.LOAD_AUTOSCALING + \" must specify either 'path' or 'json'\");\n        } else {\n          map = (Map<String, Object>) Utils.fromJSONString(json);\n        }\n      } else {\n        File f = new File(path);\n        Reader r;\n        if (f.exists()) {\n          r = new InputStreamReader(new FileInputStream(f), Charset.forName(\"UTF-8\"));\n        } else {\n          InputStream is = getClass().getResourceAsStream(path);\n          if (is == null) {\n            throw new IOException(\"path \" + path + \" does not exist and it's not a resource\");\n          }\n          r = new InputStreamReader(is, Charset.forName(\"UTF-8\"));\n        }\n        map = (Map<String, Object>) Utils.fromJSON(r);\n      }\n      AutoScalingConfig config = new AutoScalingConfig(map);\n      if (addDefaults) {\n        // add default triggers\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME)) {\n          Map<String, Object> props = new HashMap<>(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_PROPS);\n          props.put(\"waitFor\", defaultWaitFor);\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME, props);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME);\n        }\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME)) {\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_PROPS);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME);\n        }\n      }\n      scenario.config = config;\n      // set this config on the simulator\n      scenario.cluster.getSimDistribStateManager().simSetAutoScalingConfig(config);\n      // wait until it finished processing the config\n      (new TimeOut(30, TimeUnit.SECONDS, scenario.cluster.getTimeSource()))\n          .waitFor(\"OverseerTriggerThread never caught up to the latest znodeVersion\", () -> {\n            try {\n              AutoScalingConfig autoscalingConfig = scenario.cluster.getDistribStateManager().getAutoScalingConfig();\n              return autoscalingConfig.getZkVersion() == scenario.cluster.getOverseerTriggerThread().getProcessedZnodeVersion();\n            } catch (Exception e) {\n              throw new RuntimeException(\"FAILED\", e);\n            }\n          });\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f504512a03d978990cbff30db0522b354e846db","date":1595247421,"type":4,"author":"Ishan Chattopadhyaya","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/core/src/java/org/apache/solr/cloud/autoscaling/sim/SimScenario.LoadAutoscaling#execute(SimScenario).mjava","sourceNew":null,"sourceOld":"    @Override\n    @SuppressWarnings({\"unchecked\"})\n    public void execute(SimScenario scenario) throws Exception {\n      Map<String, Object> map;\n      boolean addDefaults = Boolean.parseBoolean(params.get(\"withDefaultTriggers\", \"true\"));\n      int defaultWaitFor = Integer.parseInt(params.get(\"defaultWaitFor\", \"120\"));\n      String path = params.get(\"path\");\n      if (path == null) {\n        String json = params.get(\"json\");\n        if (json == null) {\n          throw new IOException(SimAction.LOAD_AUTOSCALING + \" must specify either 'path' or 'json'\");\n        } else {\n          map = (Map<String, Object>) Utils.fromJSONString(json);\n        }\n      } else {\n        File f = new File(path);\n        Reader r;\n        if (f.exists()) {\n          r = new InputStreamReader(new FileInputStream(f), Charset.forName(\"UTF-8\"));\n        } else {\n          InputStream is = getClass().getResourceAsStream(path);\n          if (is == null) {\n            throw new IOException(\"path \" + path + \" does not exist and it's not a resource\");\n          }\n          r = new InputStreamReader(is, Charset.forName(\"UTF-8\"));\n        }\n        map = (Map<String, Object>) Utils.fromJSON(r);\n      }\n      AutoScalingConfig config = new AutoScalingConfig(map);\n      if (addDefaults) {\n        // add default triggers\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME)) {\n          Map<String, Object> props = new HashMap<>(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_PROPS);\n          props.put(\"waitFor\", defaultWaitFor);\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME, props);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.AUTO_ADD_REPLICAS_TRIGGER_NAME);\n        }\n        if (!config.getTriggerConfigs().containsKey(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME)) {\n          AutoScalingConfig.TriggerConfig trigger = new AutoScalingConfig.TriggerConfig(AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_PROPS);\n          config = config.withTriggerConfig(trigger);\n          config = AutoScalingHandler.withSystemLogListener(config, AutoScaling.SCHEDULED_MAINTENANCE_TRIGGER_NAME);\n        }\n      }\n      scenario.config = config;\n      // set this config on the simulator\n      scenario.cluster.getSimDistribStateManager().simSetAutoScalingConfig(config);\n      // wait until it finished processing the config\n      (new TimeOut(30, TimeUnit.SECONDS, scenario.cluster.getTimeSource()))\n          .waitFor(\"OverseerTriggerThread never caught up to the latest znodeVersion\", () -> {\n            try {\n              AutoScalingConfig autoscalingConfig = scenario.cluster.getDistribStateManager().getAutoScalingConfig();\n              return autoscalingConfig.getZkVersion() == scenario.cluster.getOverseerTriggerThread().getProcessedZnodeVersion();\n            } catch (Exception e) {\n              throw new RuntimeException(\"FAILED\", e);\n            }\n          });\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3f504512a03d978990cbff30db0522b354e846db":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3f504512a03d978990cbff30db0522b354e846db"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"3f504512a03d978990cbff30db0522b354e846db":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"daa0f21a44e235a2299ea1fa913898b182dd7cce":["3f504512a03d978990cbff30db0522b354e846db"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a7aeb53916301ea6a5fedff4fdc9617b257cbc7d"],"a7aeb53916301ea6a5fedff4fdc9617b257cbc7d":["daa0f21a44e235a2299ea1fa913898b182dd7cce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}