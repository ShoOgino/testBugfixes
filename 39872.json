{"path":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","commits":[{"id":"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96","date":1433340999,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","pathOld":"/dev/null","sourceNew":"  public DocIdSet intersect(Bits acceptDocs, double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(acceptDocs, state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return new BitDocIdSet(state.bits, hitCount);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0f4464508ee83288c8c4585b533f9faaa93aa314","date":1435240759,"type":5,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","pathOld":"lucene/sandbox/src/java/org/apache/lucene/bkdtree/BKDTreeReader#intersect(Bits,double,double,double,double,LatLonFilter,SortedNumericDocValues).mjava","sourceNew":"  public DocIdSet intersect(double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return new BitDocIdSet(state.bits, hitCount);\n  }\n\n","sourceOld":"  public DocIdSet intersect(Bits acceptDocs, double latMin, double latMax, double lonMin, double lonMax, LatLonFilter filter, SortedNumericDocValues sndv) throws IOException {\n    if (BKDTreeWriter.validLat(latMin) == false) {\n      throw new IllegalArgumentException(\"invalid latMin: \" + latMin);\n    }\n    if (BKDTreeWriter.validLat(latMax) == false) {\n      throw new IllegalArgumentException(\"invalid latMax: \" + latMax);\n    }\n    if (BKDTreeWriter.validLon(lonMin) == false) {\n      throw new IllegalArgumentException(\"invalid lonMin: \" + lonMin);\n    }\n    if (BKDTreeWriter.validLon(lonMax) == false) {\n      throw new IllegalArgumentException(\"invalid lonMax: \" + lonMax);\n    }\n\n    int latMinEnc = BKDTreeWriter.encodeLat(latMin);\n    int latMaxEnc = BKDTreeWriter.encodeLat(latMax);\n    int lonMinEnc = BKDTreeWriter.encodeLon(lonMin);\n    int lonMaxEnc = BKDTreeWriter.encodeLon(lonMax);\n\n    // TODO: we should use a sparse bit collector here, but BitDocIdSet.Builder is 2.4X slower than straight FixedBitSet.\n    // Maybe we should use simple int[] (not de-duping) up until size X, then cutover.  Or maybe SentinelIntSet when it's\n    // small.\n\n    QueryState state = new QueryState(in.clone(), maxDoc,\n                                      latMinEnc, latMaxEnc,\n                                      lonMinEnc, lonMaxEnc,\n                                      filter,\n                                      sndv);\n\n    int hitCount = intersect(acceptDocs, state, 1,\n                             BKDTreeWriter.encodeLat(-90.0),\n                             BKDTreeWriter.encodeLat(Math.nextAfter(90.0, Double.POSITIVE_INFINITY)),\n                             BKDTreeWriter.encodeLon(-180.0),\n                             BKDTreeWriter.encodeLon(Math.nextAfter(180.0, Double.POSITIVE_INFINITY)));\n\n    // NOTE: hitCount is an over-estimate in the multi-valued case:\n    return new BitDocIdSet(state.bits, hitCount);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"0f4464508ee83288c8c4585b533f9faaa93aa314":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4e50a8c6cf9370a926c7efe6aa39429e6a18cf96"],"4e50a8c6cf9370a926c7efe6aa39429e6a18cf96":["0f4464508ee83288c8c4585b533f9faaa93aa314"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}