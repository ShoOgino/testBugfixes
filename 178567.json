{"path":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","commits":[{"id":"5ee0394b8176abd7c90a4be8c05465be1879db79","date":1522842314,"type":0,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"/dev/null","sourceNew":"  protected MutableBits getMutableBits() throws IOException {\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      LiveDocsFormat liveDocsFormat = info.info.getCodec().liveDocsFormat();\n      MutableBits mutableBits;\n      if (liveDocs == null) {\n        mutableBits = liveDocsFormat.newLiveDocs(info.info.maxDoc());\n      } else {\n        mutableBits = liveDocsFormat.newLiveDocs(liveDocs);\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (MutableBits) liveDocs;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"49575fe0d33c4904ac42b0526411d1dee7549e9b","date":1523529874,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","sourceNew":"  protected MutableBits getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      LiveDocsFormat liveDocsFormat = info.info.getCodec().liveDocsFormat();\n      MutableBits mutableBits;\n      if (liveDocs == null) {\n        mutableBits = liveDocsFormat.newLiveDocs(info.info.maxDoc());\n      } else {\n        mutableBits = liveDocsFormat.newLiveDocs(liveDocs);\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (MutableBits) liveDocs;\n  }\n\n","sourceOld":"  protected MutableBits getMutableBits() throws IOException {\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      LiveDocsFormat liveDocsFormat = info.info.getCodec().liveDocsFormat();\n      MutableBits mutableBits;\n      if (liveDocs == null) {\n        mutableBits = liveDocsFormat.newLiveDocs(info.info.maxDoc());\n      } else {\n        mutableBits = liveDocsFormat.newLiveDocs(liveDocs);\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (MutableBits) liveDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5d36ba65c7e095c7938bfc2343a9a6cf689bfb43","date":1523531370,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","sourceNew":"  protected MutableBits getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      LiveDocsFormat liveDocsFormat = info.info.getCodec().liveDocsFormat();\n      MutableBits mutableBits;\n      if (liveDocs == null) {\n        mutableBits = liveDocsFormat.newLiveDocs(info.info.maxDoc());\n      } else {\n        mutableBits = liveDocsFormat.newLiveDocs(liveDocs);\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (MutableBits) liveDocs;\n  }\n\n","sourceOld":"  protected MutableBits getMutableBits() throws IOException {\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      LiveDocsFormat liveDocsFormat = info.info.getCodec().liveDocsFormat();\n      MutableBits mutableBits;\n      if (liveDocs == null) {\n        mutableBits = liveDocsFormat.newLiveDocs(info.info.maxDoc());\n      } else {\n        mutableBits = liveDocsFormat.newLiveDocs(liveDocs);\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (MutableBits) liveDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d","date":1525873214,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","sourceNew":"  protected FixedBitSet getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      FixedBitSet mutableBits = new FixedBitSet(info.info.maxDoc());\n      mutableBits.set(0, info.info.maxDoc());\n      if (liveDocs != null) {\n        for (int i = 0; i < liveDocs.length(); ++i) {\n          if (liveDocs.get(i) == false) {\n            mutableBits.clear(i);\n          }\n        }\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (FixedBitSet) liveDocs;\n  }\n\n","sourceOld":"  protected MutableBits getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      LiveDocsFormat liveDocsFormat = info.info.getCodec().liveDocsFormat();\n      MutableBits mutableBits;\n      if (liveDocs == null) {\n        mutableBits = liveDocsFormat.newLiveDocs(info.info.maxDoc());\n      } else {\n        mutableBits = liveDocsFormat.newLiveDocs(liveDocs);\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (MutableBits) liveDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"13bce432480722e4f48bce0da3623dab44dd8d9c","date":1525873214,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","sourceNew":"  protected FixedBitSet getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (writeableLiveDocs == null) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      writeableLiveDocs = new FixedBitSet(info.info.maxDoc());\n      writeableLiveDocs.set(0, info.info.maxDoc());\n      if (liveDocs != null) {\n        for (int i = 0; i < liveDocs.length(); ++i) {\n          if (liveDocs.get(i) == false) {\n            writeableLiveDocs.clear(i);\n          }\n        }\n      }\n      liveDocs = writeableLiveDocs;\n    }\n    return writeableLiveDocs;\n  }\n\n","sourceOld":"  protected FixedBitSet getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (liveDocsShared) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      FixedBitSet mutableBits = new FixedBitSet(info.info.maxDoc());\n      mutableBits.set(0, info.info.maxDoc());\n      if (liveDocs != null) {\n        for (int i = 0; i < liveDocs.length(); ++i) {\n          if (liveDocs.get(i) == false) {\n            mutableBits.clear(i);\n          }\n        }\n      }\n      liveDocs = mutableBits;\n      liveDocsShared = false;\n    }\n    return (FixedBitSet) liveDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"33adea025f43af3243278587a46b8d9fd2e8ccf9","date":1525885077,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","sourceNew":"  protected FixedBitSet getMutableBits() {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (writeableLiveDocs == null) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      if (liveDocs != null) {\n        writeableLiveDocs = FixedBitSet.copyOf(liveDocs);\n      } else {\n        writeableLiveDocs = new FixedBitSet(info.info.maxDoc());\n        writeableLiveDocs.set(0, info.info.maxDoc());\n      }\n      liveDocs = writeableLiveDocs;\n    }\n    return writeableLiveDocs;\n  }\n\n","sourceOld":"  protected FixedBitSet getMutableBits() throws IOException {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (writeableLiveDocs == null) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      writeableLiveDocs = new FixedBitSet(info.info.maxDoc());\n      writeableLiveDocs.set(0, info.info.maxDoc());\n      if (liveDocs != null) {\n        for (int i = 0; i < liveDocs.length(); ++i) {\n          if (liveDocs.get(i) == false) {\n            writeableLiveDocs.clear(i);\n          }\n        }\n      }\n      liveDocs = writeableLiveDocs;\n    }\n    return writeableLiveDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"858adca70b05a27f5e0996d8d62c95172b695210","date":1526486059,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/PendingDeletes#getMutableBits().mjava","sourceNew":"  protected FixedBitSet getMutableBits() {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (writeableLiveDocs == null) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      if (liveDocs != null) {\n        writeableLiveDocs = FixedBitSet.copyOf(liveDocs);\n      } else {\n        writeableLiveDocs = new FixedBitSet(info.info.maxDoc());\n        writeableLiveDocs.set(0, info.info.maxDoc());\n      }\n      liveDocs = writeableLiveDocs.asReadOnlyBits();\n    }\n    return writeableLiveDocs;\n  }\n\n","sourceOld":"  protected FixedBitSet getMutableBits() {\n    // if we pull mutable bits but we haven't been initialized something is completely off.\n    // this means we receive deletes without having the bitset that is on-disk ready to be cloned\n    assert liveDocsInitialized : \"can't delete if liveDocs are not initialized\";\n    if (writeableLiveDocs == null) {\n      // Copy on write: this means we've cloned a\n      // SegmentReader sharing the current liveDocs\n      // instance; must now make a private clone so we can\n      // change it:\n      if (liveDocs != null) {\n        writeableLiveDocs = FixedBitSet.copyOf(liveDocs);\n      } else {\n        writeableLiveDocs = new FixedBitSet(info.info.maxDoc());\n        writeableLiveDocs.set(0, info.info.maxDoc());\n      }\n      liveDocs = writeableLiveDocs;\n    }\n    return writeableLiveDocs;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"13bce432480722e4f48bce0da3623dab44dd8d9c":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d"],"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d":["5d36ba65c7e095c7938bfc2343a9a6cf689bfb43"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"49575fe0d33c4904ac42b0526411d1dee7549e9b":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"858adca70b05a27f5e0996d8d62c95172b695210":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"5d36ba65c7e095c7938bfc2343a9a6cf689bfb43":["5ee0394b8176abd7c90a4be8c05465be1879db79","49575fe0d33c4904ac42b0526411d1dee7549e9b"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["13bce432480722e4f48bce0da3623dab44dd8d9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["858adca70b05a27f5e0996d8d62c95172b695210"]},"commit2Childs":{"13bce432480722e4f48bce0da3623dab44dd8d9c":["33adea025f43af3243278587a46b8d9fd2e8ccf9"],"fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d":["13bce432480722e4f48bce0da3623dab44dd8d9c"],"5ee0394b8176abd7c90a4be8c05465be1879db79":["49575fe0d33c4904ac42b0526411d1dee7549e9b","5d36ba65c7e095c7938bfc2343a9a6cf689bfb43"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ee0394b8176abd7c90a4be8c05465be1879db79"],"49575fe0d33c4904ac42b0526411d1dee7549e9b":["5d36ba65c7e095c7938bfc2343a9a6cf689bfb43"],"5d36ba65c7e095c7938bfc2343a9a6cf689bfb43":["fb8a3dfca2d8b39c20bdfc87eb7171c06ea9400d"],"858adca70b05a27f5e0996d8d62c95172b695210":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"33adea025f43af3243278587a46b8d9fd2e8ccf9":["858adca70b05a27f5e0996d8d62c95172b695210"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}