{"path":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","commits":[{"id":"cdcf766020b9b159d0b3a6ecae90ff1998ded019","date":1286818331,"type":0,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"/dev/null","sourceNew":"\tpublic List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n\t\t\tint maxCollations, int maxTries) {\n\t\tList<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n\t\tQueryComponent queryComponent = null;\n\t\tif (ultimateResponse.components != null) {\n\t\t\tfor (SearchComponent sc : ultimateResponse.components) {\n\t\t\t\tif (sc instanceof QueryComponent) {\n\t\t\t\t\tqueryComponent = (QueryComponent) sc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean verifyCandidateWithQuery = true;\n\t\tif (maxTries < 1) {\n\t\t\tmaxTries = 1;\n\t\t\tverifyCandidateWithQuery = false;\n\t\t}\n\t\tif (queryComponent == null && verifyCandidateWithQuery) {\n\t\t\tLOG.warn(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n\t\t\tmaxTries = 1;\n\t\t\tverifyCandidateWithQuery = false;\n\t\t}\n\t\t\n\t\tint tryNo = 0;\n\t\tint collNo = 0;\n\t\tPossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n\t\twhile (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n\t\t\tRankedSpellPossibility possibility = possibilityIter.next();\n\t\t\tString collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n\t\t\tint hits = 0;\n\t\t\t\t\t\n\t\t\tif (verifyCandidateWithQuery) {\n\t\t\t\ttryNo++;\n\n\t\t\t\tResponseBuilder checkResponse = new ResponseBuilder();\n\t\t\t\tcheckResponse.setQparser(ultimateResponse.getQparser());\t\t\t\t\n\t\t\t\tcheckResponse.setFilters(ultimateResponse.getFilters());\n\t\t\t\tcheckResponse.setQueryString(collationQueryStr);\t\t\t\t\n\t\t\t\tcheckResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\t\t\t\t\n\t\t\t\tModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n\t\t\t\tparams.remove(CommonParams.Q);\n\t\t\t\tparams.add(CommonParams.Q, collationQueryStr);\n\t\t\t\tparams.remove(CommonParams.START);\n\t\t\t\tparams.remove(CommonParams.ROWS);\n\t\t\t\tparams.add(CommonParams.FL, \"id\");\n\t\t\t\tparams.add(CommonParams.ROWS, \"0\");\n\t\t\t\t//Would rather have found a concrete class to use...\n\t\t\t\tcheckResponse.req = new SolrQueryRequestBase(ultimateResponse.req.getCore(), params) { };\n\t\t\t\tcheckResponse.rsp = new SolrQueryResponse();\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tqueryComponent.prepare(checkResponse);\n\t\t\t\t\tqueryComponent.process(checkResponse);\t\t\t\t\n\t\t\t\t\thits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\t\t\t\t\t\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hits > 0 || !verifyCandidateWithQuery) {\n\t\t\t\tcollNo++;\n\t\t\t\tSpellCheckCollation collation = new SpellCheckCollation();\n\t\t\t\tcollation.setCollationQuery(collationQueryStr);\n\t\t\t\tcollation.setHits(hits);\n\t\t\t\tcollation.setInternalRank(possibility.getRank());\n\n\t\t\t\tNamedList<String> misspellingsAndCorrections = new NamedList<String>();\n\t\t\t\tfor (SpellCheckCorrection corr : possibility.getCorrections()) {\n\t\t\t\t\tmisspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n\t\t\t\t}\n\t\t\t\tcollation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n\t\t\t\tcollations.add(collation);\n\t\t\t}\n\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n\t\t\t}\t\t\n\t\t}\n\t\treturn collations;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01dce43e4bc4beefad6c846395bc4bd7aecd89be","date":1287236931,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.warn(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ResponseBuilder checkResponse = new ResponseBuilder();\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.remove(CommonParams.Q);\n        params.add(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.remove(CommonParams.ROWS);\n        params.add(CommonParams.FL, \"id\");\n        params.add(CommonParams.ROWS, \"0\");\n        //Would rather have found a concrete class to use...\n        checkResponse.req = new SolrQueryRequestBase(ultimateResponse.req.getCore(), params) { };\n        checkResponse.rsp = new SolrQueryResponse();\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"\tpublic List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n\t\t\tint maxCollations, int maxTries) {\n\t\tList<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n\t\tQueryComponent queryComponent = null;\n\t\tif (ultimateResponse.components != null) {\n\t\t\tfor (SearchComponent sc : ultimateResponse.components) {\n\t\t\t\tif (sc instanceof QueryComponent) {\n\t\t\t\t\tqueryComponent = (QueryComponent) sc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean verifyCandidateWithQuery = true;\n\t\tif (maxTries < 1) {\n\t\t\tmaxTries = 1;\n\t\t\tverifyCandidateWithQuery = false;\n\t\t}\n\t\tif (queryComponent == null && verifyCandidateWithQuery) {\n\t\t\tLOG.warn(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n\t\t\tmaxTries = 1;\n\t\t\tverifyCandidateWithQuery = false;\n\t\t}\n\t\t\n\t\tint tryNo = 0;\n\t\tint collNo = 0;\n\t\tPossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n\t\twhile (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n\t\t\tRankedSpellPossibility possibility = possibilityIter.next();\n\t\t\tString collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n\t\t\tint hits = 0;\n\t\t\t\t\t\n\t\t\tif (verifyCandidateWithQuery) {\n\t\t\t\ttryNo++;\n\n\t\t\t\tResponseBuilder checkResponse = new ResponseBuilder();\n\t\t\t\tcheckResponse.setQparser(ultimateResponse.getQparser());\t\t\t\t\n\t\t\t\tcheckResponse.setFilters(ultimateResponse.getFilters());\n\t\t\t\tcheckResponse.setQueryString(collationQueryStr);\t\t\t\t\n\t\t\t\tcheckResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\t\t\t\t\n\t\t\t\tModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n\t\t\t\tparams.remove(CommonParams.Q);\n\t\t\t\tparams.add(CommonParams.Q, collationQueryStr);\n\t\t\t\tparams.remove(CommonParams.START);\n\t\t\t\tparams.remove(CommonParams.ROWS);\n\t\t\t\tparams.add(CommonParams.FL, \"id\");\n\t\t\t\tparams.add(CommonParams.ROWS, \"0\");\n\t\t\t\t//Would rather have found a concrete class to use...\n\t\t\t\tcheckResponse.req = new SolrQueryRequestBase(ultimateResponse.req.getCore(), params) { };\n\t\t\t\tcheckResponse.rsp = new SolrQueryResponse();\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tqueryComponent.prepare(checkResponse);\n\t\t\t\t\tqueryComponent.process(checkResponse);\t\t\t\t\n\t\t\t\t\thits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\t\t\t\t\t\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hits > 0 || !verifyCandidateWithQuery) {\n\t\t\t\tcollNo++;\n\t\t\t\tSpellCheckCollation collation = new SpellCheckCollation();\n\t\t\t\tcollation.setCollationQuery(collationQueryStr);\n\t\t\t\tcollation.setHits(hits);\n\t\t\t\tcollation.setInternalRank(possibility.getRank());\n\n\t\t\t\tNamedList<String> misspellingsAndCorrections = new NamedList<String>();\n\t\t\t\tfor (SpellCheckCorrection corr : possibility.getCorrections()) {\n\t\t\t\t\tmisspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n\t\t\t\t}\n\t\t\t\tcollation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n\t\t\t\tcollations.add(collation);\n\t\t\t}\n\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n\t\t\t}\t\t\n\t\t}\n\t\treturn collations;\n\t}\n\n","bugFix":null,"bugIntro":["f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","f8f3dce1d4820d9634c1a6a46cd50ac13cf0f5a6","adc9774a93b078f8bcbea4e856c90055f6ffaa7f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"eebc0050da2a25fa8ca277d08cec0afaf92ed865","date":1287248791,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ResponseBuilder checkResponse = new ResponseBuilder();\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n        // creating a request here... make sure to close it!\n        checkResponse.req = new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params);\n        checkResponse.rsp = new SolrQueryResponse();\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.warn(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ResponseBuilder checkResponse = new ResponseBuilder();\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.remove(CommonParams.Q);\n        params.add(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.remove(CommonParams.ROWS);\n        params.add(CommonParams.FL, \"id\");\n        params.add(CommonParams.ROWS, \"0\");\n        //Would rather have found a concrete class to use...\n        checkResponse.req = new SolrQueryRequestBase(ultimateResponse.req.getCore(), params) { };\n        checkResponse.rsp = new SolrQueryResponse();\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ecea1664e8617d82eca3b8055a3c37cb4da8511","date":1287578668,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ResponseBuilder checkResponse = new ResponseBuilder();\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n        // creating a request here... make sure to close it!\n        checkResponse.req = new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params);\n        checkResponse.rsp = new SolrQueryResponse();\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"\tpublic List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n\t\t\tint maxCollations, int maxTries) {\n\t\tList<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n\t\tQueryComponent queryComponent = null;\n\t\tif (ultimateResponse.components != null) {\n\t\t\tfor (SearchComponent sc : ultimateResponse.components) {\n\t\t\t\tif (sc instanceof QueryComponent) {\n\t\t\t\t\tqueryComponent = (QueryComponent) sc;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tboolean verifyCandidateWithQuery = true;\n\t\tif (maxTries < 1) {\n\t\t\tmaxTries = 1;\n\t\t\tverifyCandidateWithQuery = false;\n\t\t}\n\t\tif (queryComponent == null && verifyCandidateWithQuery) {\n\t\t\tLOG.warn(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n\t\t\tmaxTries = 1;\n\t\t\tverifyCandidateWithQuery = false;\n\t\t}\n\t\t\n\t\tint tryNo = 0;\n\t\tint collNo = 0;\n\t\tPossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n\t\twhile (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n\t\t\tRankedSpellPossibility possibility = possibilityIter.next();\n\t\t\tString collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n\t\t\tint hits = 0;\n\t\t\t\t\t\n\t\t\tif (verifyCandidateWithQuery) {\n\t\t\t\ttryNo++;\n\n\t\t\t\tResponseBuilder checkResponse = new ResponseBuilder();\n\t\t\t\tcheckResponse.setQparser(ultimateResponse.getQparser());\t\t\t\t\n\t\t\t\tcheckResponse.setFilters(ultimateResponse.getFilters());\n\t\t\t\tcheckResponse.setQueryString(collationQueryStr);\t\t\t\t\n\t\t\t\tcheckResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\t\t\t\t\n\t\t\t\tModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n\t\t\t\tparams.remove(CommonParams.Q);\n\t\t\t\tparams.add(CommonParams.Q, collationQueryStr);\n\t\t\t\tparams.remove(CommonParams.START);\n\t\t\t\tparams.remove(CommonParams.ROWS);\n\t\t\t\tparams.add(CommonParams.FL, \"id\");\n\t\t\t\tparams.add(CommonParams.ROWS, \"0\");\n\t\t\t\t//Would rather have found a concrete class to use...\n\t\t\t\tcheckResponse.req = new SolrQueryRequestBase(ultimateResponse.req.getCore(), params) { };\n\t\t\t\tcheckResponse.rsp = new SolrQueryResponse();\n\t\t\t\t\n\t\t\t\ttry {\n\t\t\t\t\tqueryComponent.prepare(checkResponse);\n\t\t\t\t\tqueryComponent.process(checkResponse);\t\t\t\t\n\t\t\t\t\thits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\t\t\t\t\t\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLog.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (hits > 0 || !verifyCandidateWithQuery) {\n\t\t\t\tcollNo++;\n\t\t\t\tSpellCheckCollation collation = new SpellCheckCollation();\n\t\t\t\tcollation.setCollationQuery(collationQueryStr);\n\t\t\t\tcollation.setHits(hits);\n\t\t\t\tcollation.setInternalRank(possibility.getRank());\n\n\t\t\t\tNamedList<String> misspellingsAndCorrections = new NamedList<String>();\n\t\t\t\tfor (SpellCheckCorrection corr : possibility.getCorrections()) {\n\t\t\t\t\tmisspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n\t\t\t\t}\n\t\t\t\tcollation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n\t\t\t\tcollations.add(collation);\n\t\t\t}\n\t\t\tif (LOG.isDebugEnabled()) {\n\t\t\t\tLOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n\t\t\t}\t\t\n\t\t}\n\t\treturn collations;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","date":1292210954,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ResponseBuilder checkResponse = new ResponseBuilder();\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n        // creating a request here... make sure to close it!\n        checkResponse.req = new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params);\n        checkResponse.rsp = new SolrQueryResponse();\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ab5cb6a74aefb78aa0569857970b9151dfe2e787","date":1292842407,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ResponseBuilder checkResponse = new ResponseBuilder();\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n        // creating a request here... make sure to close it!\n        checkResponse.req = new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params);\n        checkResponse.rsp = new SolrQueryResponse();\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":0,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"/dev/null","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"adc9774a93b078f8bcbea4e856c90055f6ffaa7f","date":1297638590,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":["01dce43e4bc4beefad6c846395bc4bd7aecd89be"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          Log.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"31aff65a420ac3dfd25611e2c4a99d38b7dd60e9","date":1307387688,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries, int maxEvaluations) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), maxTries, maxEvaluations);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"77cf4379b2824f6ea34b091c495d6e95c38ff9e2","date":1307610475,"type":5,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int,int).mjava","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries, int maxEvaluations) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions(), maxTries, maxEvaluations);\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n        params.remove(GroupParams.GROUP);\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","date":1307729864,"type":4,"author":"Steven Rowe","isMerge":true,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/spelling/SpellCheckCollator#collate(SpellingResult,String,ResponseBuilder,int,int).mjava","sourceNew":null,"sourceOld":"  public List<SpellCheckCollation> collate(SpellingResult result, String originalQuery, ResponseBuilder ultimateResponse,\n                                           int maxCollations, int maxTries) {\n    List<SpellCheckCollation> collations = new ArrayList<SpellCheckCollation>();\n\n    QueryComponent queryComponent = null;\n    if (ultimateResponse.components != null) {\n      for (SearchComponent sc : ultimateResponse.components) {\n        if (sc instanceof QueryComponent) {\n          queryComponent = (QueryComponent) sc;\n          break;\n        }\n      }\n    }\n\n    boolean verifyCandidateWithQuery = true;\n    if (maxTries < 1) {\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n    if (queryComponent == null && verifyCandidateWithQuery) {\n      LOG.info(\"Could not find an instance of QueryComponent.  Disabling collation verification against the index.\");\n      maxTries = 1;\n      verifyCandidateWithQuery = false;\n    }\n\n    int tryNo = 0;\n    int collNo = 0;\n    PossibilityIterator possibilityIter = new PossibilityIterator(result.getSuggestions());\n    while (tryNo < maxTries && collNo < maxCollations && possibilityIter.hasNext()) {\n\n      RankedSpellPossibility possibility = possibilityIter.next();\n      String collationQueryStr = getCollation(originalQuery, possibility.getCorrections());\n      int hits = 0;\n\n      if (verifyCandidateWithQuery) {\n        tryNo++;\n\n        ModifiableSolrParams params = new ModifiableSolrParams(ultimateResponse.req.getParams());\n        params.set(CommonParams.Q, collationQueryStr);\n        params.remove(CommonParams.START);\n        params.set(CommonParams.FL, \"id\");\n        params.set(CommonParams.ROWS, \"0\");\n\n        // creating a request here... make sure to close it!\n        ResponseBuilder checkResponse = new ResponseBuilder(new LocalSolrQueryRequest(ultimateResponse.req.getCore(), params),new SolrQueryResponse(), Arrays.asList(new SearchComponent[] { queryComponent }));\n        checkResponse.setQparser(ultimateResponse.getQparser());\n        checkResponse.setFilters(ultimateResponse.getFilters());\n        checkResponse.setQueryString(collationQueryStr);\n        checkResponse.components = Arrays.asList(new SearchComponent[] { queryComponent });\n\n        try {\n          queryComponent.prepare(checkResponse);\n          queryComponent.process(checkResponse);\n          hits = (Integer) checkResponse.rsp.getToLog().get(\"hits\");\n        } catch (Exception e) {\n          LOG.warn(\"Exception trying to re-query to check if a spell check possibility would return any hits.\", e);\n        } finally {\n          checkResponse.req.close();  \n        }\n      }\n      if (hits > 0 || !verifyCandidateWithQuery) {\n        collNo++;\n        SpellCheckCollation collation = new SpellCheckCollation();\n        collation.setCollationQuery(collationQueryStr);\n        collation.setHits(hits);\n        collation.setInternalRank(possibility.getRank());\n\n        NamedList<String> misspellingsAndCorrections = new NamedList<String>();\n        for (SpellCheckCorrection corr : possibility.getCorrections()) {\n          misspellingsAndCorrections.add(corr.getOriginal().toString(), corr.getCorrection());\n        }\n        collation.setMisspellingsAndCorrections(misspellingsAndCorrections);\n        collations.add(collation);\n      }\n      if (LOG.isDebugEnabled()) {\n        LOG.debug(\"Collation: \" + collationQueryStr + (verifyCandidateWithQuery ? (\" will return \" + hits + \" hits.\") : \"\"));\n      }\n    }\n    return collations;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":["adc9774a93b078f8bcbea4e856c90055f6ffaa7f","31aff65a420ac3dfd25611e2c4a99d38b7dd60e9"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","adc9774a93b078f8bcbea4e856c90055f6ffaa7f"],"31aff65a420ac3dfd25611e2c4a99d38b7dd60e9":["adc9774a93b078f8bcbea4e856c90055f6ffaa7f"],"cdcf766020b9b159d0b3a6ecae90ff1998ded019":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["4ecea1664e8617d82eca3b8055a3c37cb4da8511","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"eebc0050da2a25fa8ca277d08cec0afaf92ed865":["01dce43e4bc4beefad6c846395bc4bd7aecd89be"],"adc9774a93b078f8bcbea4e856c90055f6ffaa7f":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["eebc0050da2a25fa8ca277d08cec0afaf92ed865"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":["f1bdbf92da222965b46c0a942c3857ba56e5c638","31aff65a420ac3dfd25611e2c4a99d38b7dd60e9"],"01dce43e4bc4beefad6c846395bc4bd7aecd89be":["cdcf766020b9b159d0b3a6ecae90ff1998ded019"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["cdcf766020b9b159d0b3a6ecae90ff1998ded019","eebc0050da2a25fa8ca277d08cec0afaf92ed865"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","adc9774a93b078f8bcbea4e856c90055f6ffaa7f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["31aff65a420ac3dfd25611e2c4a99d38b7dd60e9"]},"commit2Childs":{"a02058e0eaba4bbd5d05e6b06b9522c0acfd1655":[],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["77cf4379b2824f6ea34b091c495d6e95c38ff9e2"],"31aff65a420ac3dfd25611e2c4a99d38b7dd60e9":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cdcf766020b9b159d0b3a6ecae90ff1998ded019":["01dce43e4bc4beefad6c846395bc4bd7aecd89be","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"ab5cb6a74aefb78aa0569857970b9151dfe2e787":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"eebc0050da2a25fa8ca277d08cec0afaf92ed865":["227a2cd43fc1affe16eb4c4ab4423fbc276bd81d","4ecea1664e8617d82eca3b8055a3c37cb4da8511"],"adc9774a93b078f8bcbea4e856c90055f6ffaa7f":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","f1bdbf92da222965b46c0a942c3857ba56e5c638","31aff65a420ac3dfd25611e2c4a99d38b7dd60e9","bde51b089eb7f86171eb3406e38a274743f9b7ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cdcf766020b9b159d0b3a6ecae90ff1998ded019","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"227a2cd43fc1affe16eb4c4ab4423fbc276bd81d":["ab5cb6a74aefb78aa0569857970b9151dfe2e787","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","adc9774a93b078f8bcbea4e856c90055f6ffaa7f"],"77cf4379b2824f6ea34b091c495d6e95c38ff9e2":[],"01dce43e4bc4beefad6c846395bc4bd7aecd89be":["eebc0050da2a25fa8ca277d08cec0afaf92ed865"],"4ecea1664e8617d82eca3b8055a3c37cb4da8511":["ab5cb6a74aefb78aa0569857970b9151dfe2e787"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["a02058e0eaba4bbd5d05e6b06b9522c0acfd1655","77cf4379b2824f6ea34b091c495d6e95c38ff9e2","bde51b089eb7f86171eb3406e38a274743f9b7ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}