{"path":"solr/core/src/test/org/apache/solr/update/processor/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","commits":[{"id":"667eea18b7ca87af38d05d81d479f943a717a6b1","date":1548452298,"type":1,"author":"Tomas Fernandez Lobbe","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fb03700c9690d16b15fb4f56f6ec36b128fd894e","date":1586745995,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/update/processor/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","pathOld":"solr/core/src/test/org/apache/solr/update/processor/TestDocBasedVersionConstraints#testConcurrentAdds().mjava","sourceNew":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new SolrNamedThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","sourceOld":"  /** \n   * Constantly hammer the same doc with multiple concurrent threads and diff versions,\n   * confirm that the highest version wins.\n   */\n  public void testConcurrentAdds() throws Exception {\n    final int NUM_DOCS = atLeast(50);\n    final int MAX_CONCURENT = atLeast(10);\n    ExecutorService runner = ExecutorUtil.newMDCAwareFixedThreadPool(MAX_CONCURENT, new DefaultSolrThreadFactory(\"TestDocBasedVersionConstraints\"));\n    // runner = Executors.newFixedThreadPool(1);    // to test single threaded\n    try {\n      for (int id = 0; id < NUM_DOCS; id++) {\n        final int numAdds = TestUtil.nextInt(random(), 3, MAX_CONCURENT);\n        final int winner = TestUtil.nextInt(random(), 0, numAdds - 1);\n        final int winnerVersion = atLeast(100);\n        final boolean winnerIsDeleted = (0 == TestUtil.nextInt(random(), 0, 4));\n        List<Callable<Object>> tasks = new ArrayList<>(numAdds);\n        for (int variant = 0; variant < numAdds; variant++) {\n          final boolean iShouldWin = (variant==winner);\n          final long version = (iShouldWin ? winnerVersion \n                                : TestUtil.nextInt(random(), 1, winnerVersion - 1));\n          if ((iShouldWin && winnerIsDeleted)\n              || (!iShouldWin && 0 == TestUtil.nextInt(random(), 0, 4))) {\n            tasks.add(delayedDelete(\"\"+id, \"\"+version));\n          } else {\n            tasks.add(delayedAdd(\"id\",\"\"+id,\"name\",\"name\"+id+\"_\"+variant,\n                                 \"my_version_l\", \"\"+ version));\n          }\n        }\n        runner.invokeAll(tasks);\n        final String expectedDoc = \"{'id':'\"+id+\"','my_version_l':\"+winnerVersion +\n          ( ! winnerIsDeleted ? \",'name':'name\"+id+\"_\"+winner+\"'}\" : \"}\");\n\n        assertJQ(req(\"qt\",\"/get\", \"id\",\"\"+id, \"fl\",\"id,name,my_version_l\")\n                 , \"=={'doc':\" + expectedDoc + \"}\");\n        assertU(commit());\n        assertJQ(req(\"q\",\"id:\"+id,\n                     \"fl\",\"id,name,my_version_l\")\n                 ,\"/response/numFound==1\"\n                 ,\"/response/docs==[\"+expectedDoc+\"]\");\n      }\n    } finally {\n      ExecutorUtil.shutdownAndAwaitTermination(runner);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["667eea18b7ca87af38d05d81d479f943a717a6b1"],"667eea18b7ca87af38d05d81d479f943a717a6b1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["667eea18b7ca87af38d05d81d479f943a717a6b1"],"fb03700c9690d16b15fb4f56f6ec36b128fd894e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"667eea18b7ca87af38d05d81d479f943a717a6b1":["fb03700c9690d16b15fb4f56f6ec36b128fd894e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}