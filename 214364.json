{"path":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","commits":[{"id":"d26db6980435280d32792a7ddd3e26866ac98ea9","date":1042658704,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"/dev/null","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.prohibited) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.prohibited) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.required) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = searcher.getSimilarity().coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["f4e4ac061c7cb668bd0651cb565ebbad1157cadc","f4e4ac061c7cb668bd0651cb565ebbad1157cadc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ff40ad80f7ee098df7921f3467ede1806a08284b","date":1044643516,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.prohibited) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.prohibited) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.required) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = searcher.getSimilarity().coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(0);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.prohibited) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.prohibited) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.required) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = searcher.getSimilarity().coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c","date":1076095160,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.prohibited) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.prohibited) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.required) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = getSimilarity(searcher).coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.prohibited) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.prohibited) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.required) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = searcher.getSimilarity().coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0d1fc81afb0c32e0b7589e656cceb5cf177093fa","date":1093637352,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.isRequired()) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = getSimilarity(searcher).coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.prohibited) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.prohibited) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.required) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = getSimilarity(searcher).coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"402061809f3a4629ea0c449e33e9f94a9772f3c3","date":1113967712,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.isRequired()) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.isRequired()) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = getSimilarity(searcher).coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7a53ba34cf04e8d72c7d4c4bd297d32206a25c05","date":1150765993,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            return new Explanation(0.0f, \"match prohibited\");\n          }\n        } else if (c.isRequired()) {\n          return new Explanation(0.0f, \"match required\");\n        }\n      }\n      sumExpl.setValue(sum);\n\n      if (coord == 1)                               // only one clause matched\n        sumExpl = sumExpl.getDetails()[0];          // eliminate wrapper\n\n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":["f4e4ac061c7cb668bd0651cb565ebbad1157cadc","f4e4ac061c7cb668bd0651cb565ebbad1157cadc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f4e4ac061c7cb668bd0651cb565ebbad1157cadc","date":1151347127,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      Explanation sumExpl = new Explanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.getValue() > 0) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        Explanation result = new Explanation();\n        result.setDescription(\"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        result.setValue(sum*coordFactor);\n        return result;\n      }\n    }\n\n","bugFix":["7a53ba34cf04e8d72c7d4c4bd297d32206a25c05","d26db6980435280d32792a7ddd3e26866ac98ea9"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e","date":1166323237,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.elementAt(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19f758d6efad251890e720eb5370329f6ab5b509","date":1217253519,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.elementAt(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"052fac7830290bd38a04cddee1a121ee07656b56","date":1245780702,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        QueryWeight w = (QueryWeight)weights.get(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        Weight w = (Weight)weights.get(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d6c98c690b593cea727f68742684c979ead1a0a","date":1248688202,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (Iterator wIter = weights.iterator(), cIter = clauses.iterator(); wIter.hasNext();) {\n        QueryWeight w = (QueryWeight) wIter.next();\n        BooleanClause c = (BooleanClause) cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (int i = 0 ; i < weights.size(); i++) {\n        BooleanClause c = (BooleanClause)clauses.get(i);\n        QueryWeight w = (QueryWeight)weights.get(i);\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur().equals(Occur.SHOULD))\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":["ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea","ad158e4c28c7c33b7d3fd5c187a183d014d1f6ea"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe941135bdfc28c81e20b4d21422f8726af34925","date":1250040150,"type":5,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(Searcher,IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    public Explanation explain(Searcher searcher, IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (Iterator wIter = weights.iterator(), cIter = clauses.iterator(); wIter.hasNext();) {\n        Weight w = (Weight) wIter.next();\n        BooleanClause c = (BooleanClause) cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(searcher, reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (Iterator wIter = weights.iterator(), cIter = clauses.iterator(); wIter.hasNext();) {\n        QueryWeight w = (QueryWeight) wIter.next();\n        BooleanClause c = (BooleanClause) cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"231941d2cb96b9752e839c311391096d90470db8","date":1251116803,"type":1,"author":"Mark Robert Miller","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(Searcher,IndexReader,int).mjava","sourceNew":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (Iterator wIter = weights.iterator(), cIter = clauses.iterator(); wIter.hasNext();) {\n        Weight w = (Weight) wIter.next();\n        BooleanClause c = (BooleanClause) cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(Searcher searcher, IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (Iterator wIter = weights.iterator(), cIter = clauses.iterator(); wIter.hasNext();) {\n        Weight w = (Weight) wIter.next();\n        BooleanClause c = (BooleanClause) cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(searcher, reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc","date":1255773182,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    @Override\n    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n        Weight w = wIter.next();\n        BooleanClause c = cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      for (Iterator wIter = weights.iterator(), cIter = clauses.iterator(); wIter.hasNext();) {\n        Weight w = (Weight) wIter.next();\n        BooleanClause c = (BooleanClause) cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","pathOld":"src/java/org/apache/lucene/search/BooleanQuery.BooleanWeight#explain(IndexReader,int).mjava","sourceNew":"    @Override\n    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n        Weight w = wIter.next();\n        BooleanClause c = cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","sourceOld":"    @Override\n    public Explanation explain(IndexReader reader, int doc)\n      throws IOException {\n      final int minShouldMatch =\n        BooleanQuery.this.getMinimumNumberShouldMatch();\n      ComplexExplanation sumExpl = new ComplexExplanation();\n      sumExpl.setDescription(\"sum of:\");\n      int coord = 0;\n      int maxCoord = 0;\n      float sum = 0.0f;\n      boolean fail = false;\n      int shouldMatchCount = 0;\n      Iterator<BooleanClause> cIter = clauses.iterator();\n      for (Iterator<Weight> wIter = weights.iterator(); wIter.hasNext();) {\n        Weight w = wIter.next();\n        BooleanClause c = cIter.next();\n        if (w.scorer(reader, true, true) == null) {\n          continue;\n        }\n        Explanation e = w.explain(reader, doc);\n        if (!c.isProhibited()) maxCoord++;\n        if (e.isMatch()) {\n          if (!c.isProhibited()) {\n            sumExpl.addDetail(e);\n            sum += e.getValue();\n            coord++;\n          } else {\n            Explanation r =\n              new Explanation(0.0f, \"match on prohibited clause (\" + c.getQuery().toString() + \")\");\n            r.addDetail(e);\n            sumExpl.addDetail(r);\n            fail = true;\n          }\n          if (c.getOccur() == Occur.SHOULD)\n            shouldMatchCount++;\n        } else if (c.isRequired()) {\n          Explanation r = new Explanation(0.0f, \"no match on required clause (\" + c.getQuery().toString() + \")\");\n          r.addDetail(e);\n          sumExpl.addDetail(r);\n          fail = true;\n        }\n      }\n      if (fail) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription\n          (\"Failure to meet condition(s) of required/prohibited clause(s)\");\n        return sumExpl;\n      } else if (shouldMatchCount < minShouldMatch) {\n        sumExpl.setMatch(Boolean.FALSE);\n        sumExpl.setValue(0.0f);\n        sumExpl.setDescription(\"Failure to match minimum number \"+\n                               \"of optional clauses: \" + minShouldMatch);\n        return sumExpl;\n      }\n      \n      sumExpl.setMatch(0 < coord ? Boolean.TRUE : Boolean.FALSE);\n      sumExpl.setValue(sum);\n      \n      float coordFactor = similarity.coord(coord, maxCoord);\n      if (coordFactor == 1.0f)                      // coord is no-op\n        return sumExpl;                             // eliminate wrapper\n      else {\n        ComplexExplanation result = new ComplexExplanation(sumExpl.isMatch(),\n                                                           sum*coordFactor,\n                                                           \"product of:\");\n        result.addDetail(sumExpl);\n        result.addDetail(new Explanation(coordFactor,\n                                         \"coord(\"+coord+\"/\"+maxCoord+\")\"));\n        return result;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc":["231941d2cb96b9752e839c311391096d90470db8"],"231941d2cb96b9752e839c311391096d90470db8":["fe941135bdfc28c81e20b4d21422f8726af34925"],"fe941135bdfc28c81e20b4d21422f8726af34925":["8d6c98c690b593cea727f68742684c979ead1a0a"],"ff40ad80f7ee098df7921f3467ede1806a08284b":["d26db6980435280d32792a7ddd3e26866ac98ea9"],"19f758d6efad251890e720eb5370329f6ab5b509":["570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e"],"7a53ba34cf04e8d72c7d4c4bd297d32206a25c05":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["0d1fc81afb0c32e0b7589e656cceb5cf177093fa"],"d26db6980435280d32792a7ddd3e26866ac98ea9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f4e4ac061c7cb668bd0651cb565ebbad1157cadc":["7a53ba34cf04e8d72c7d4c4bd297d32206a25c05"],"0d1fc81afb0c32e0b7589e656cceb5cf177093fa":["8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c"],"8d6c98c690b593cea727f68742684c979ead1a0a":["052fac7830290bd38a04cddee1a121ee07656b56"],"570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e":["f4e4ac061c7cb668bd0651cb565ebbad1157cadc"],"8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c":["ff40ad80f7ee098df7921f3467ede1806a08284b"],"052fac7830290bd38a04cddee1a121ee07656b56":["19f758d6efad251890e720eb5370329f6ab5b509"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc"]},"commit2Childs":{"b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"231941d2cb96b9752e839c311391096d90470db8":["b4e40ecf6eb9bff831572fe33a2758f9ef1e0dcc"],"fe941135bdfc28c81e20b4d21422f8726af34925":["231941d2cb96b9752e839c311391096d90470db8"],"ff40ad80f7ee098df7921f3467ede1806a08284b":["8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c"],"19f758d6efad251890e720eb5370329f6ab5b509":["052fac7830290bd38a04cddee1a121ee07656b56"],"7a53ba34cf04e8d72c7d4c4bd297d32206a25c05":["f4e4ac061c7cb668bd0651cb565ebbad1157cadc"],"402061809f3a4629ea0c449e33e9f94a9772f3c3":["7a53ba34cf04e8d72c7d4c4bd297d32206a25c05"],"d26db6980435280d32792a7ddd3e26866ac98ea9":["ff40ad80f7ee098df7921f3467ede1806a08284b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d26db6980435280d32792a7ddd3e26866ac98ea9"],"f4e4ac061c7cb668bd0651cb565ebbad1157cadc":["570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e"],"0d1fc81afb0c32e0b7589e656cceb5cf177093fa":["402061809f3a4629ea0c449e33e9f94a9772f3c3"],"8d6c98c690b593cea727f68742684c979ead1a0a":["fe941135bdfc28c81e20b4d21422f8726af34925"],"570e1572d75ec17bfc5c2e0e4e4dad03e3ce323e":["19f758d6efad251890e720eb5370329f6ab5b509"],"8bf3ec8f8b7d926e51ec6723d33679ea12e5d23c":["0d1fc81afb0c32e0b7589e656cceb5cf177093fa"],"052fac7830290bd38a04cddee1a121ee07656b56":["8d6c98c690b593cea727f68742684c979ead1a0a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}