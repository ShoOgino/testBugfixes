{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws CorruptIndexException, IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws CorruptIndexException, IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws CorruptIndexException, IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws CorruptIndexException, IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n    \tboolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["901d103ab7c2eeae92b111fc91bb1b00580a3fd7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot flush\");\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4","date":1414017220,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    assert testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9299079153fd7895bf3cf6835cf7019af2ba89b3","date":1417813477,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (AbortingException | OutOfMemoryError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads(this);\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":["e4f3b0a30c9d521b86f768348f832af93505b4eb","c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4f3b0a30c9d521b86f768348f832af93505b4eb","date":1420797674,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n        }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | OutOfMemoryError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      final boolean anySegmentFlushed;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anySegmentFlushed = docWriter.flushAllThreads();\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        if (!anySegmentFlushed) {\n          // flushCount is incremented in flushAllThreads\n          flushCount.incrementAndGet();\n        }\n        success = true;\n        return anySegmentFlushed;\n      }\n    } catch (AbortingException | OutOfMemoryError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":["9299079153fd7895bf3cf6835cf7019af2ba89b3","7d45e9e2ad7f57776540627c78f5e22e469ccdc1","1b1414bb9669ffe06a89e46b889729f2e2588081","d2ed1b9b7b46829fe3199afe9a8bc203f201b175"],"bugIntro":["901d103ab7c2eeae92b111fc91bb1b00580a3fd7"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"901d103ab7c2eeae92b111fc91bb1b00580a3fd7","date":1422827173,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | OutOfMemoryError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n      boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n        }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | OutOfMemoryError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":["e4f3b0a30c9d521b86f768348f832af93505b4eb","a1c3710e755dc60691ac0d7fe23c9fcba0537bdc","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c48871ed951104729f5e17a8ee1091b43fa18980","date":1446564542,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | OutOfMemoryError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f492fe129985750df09c8dac738aecc503158bb3","date":1464099630,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          anyChanges = docWriter.flushAllThreads();\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n      synchronized(this) {\n        anyChanges |= maybeApplyDeletes(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy);\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false, true);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (AbortingException | VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      // never hit\n      return false;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7","date":1524496660,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads(this);\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6b8498afacfc8322268ca0d659d274fcce08d557","date":1524577248,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert holdsFullFlushLock();\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads(this);\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          flushSuccess = true;\n        } finally {\n          docWriter.finishFullFlush(this, flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f372764a5bd3ebacde5b99ee3303153eb5ec0d2f","date":1525347515,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert holdsFullFlushLock();\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        writeReaderPool(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert holdsFullFlushLock();\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b07024a7318c25225dc4d070cf6d047315b73aaf","date":1586885963,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads() ;\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert holdsFullFlushLock();\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        writeReaderPool(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges = false;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads();\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert holdsFullFlushLock();\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        writeReaderPool(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2","date":1588002560,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#doFlush(boolean).mjava","sourceNew":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads() ;\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert Thread.holdsLock(fullFlushLock);;\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        writeReaderPool(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","sourceOld":"  /** Returns true a segment was flushed or deletes were applied. */\n  private boolean doFlush(boolean applyAllDeletes) throws IOException {\n    if (tragedy.get() != null) {\n      throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot flush\", tragedy.get());\n    }\n\n    doBeforeFlush();\n    testPoint(\"startDoFlush\");\n    boolean success = false;\n    try {\n\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"  start flush: applyAllDeletes=\" + applyAllDeletes);\n        infoStream.message(\"IW\", \"  index before flush \" + segString());\n      }\n      boolean anyChanges;\n      \n      synchronized (fullFlushLock) {\n        boolean flushSuccess = false;\n        try {\n          long seqNo = docWriter.flushAllThreads() ;\n          if (seqNo < 0) {\n            seqNo = -seqNo;\n            anyChanges = true;\n          } else {\n            anyChanges = false;\n          }\n          if (!anyChanges) {\n            // flushCount is incremented in flushAllThreads\n            flushCount.incrementAndGet();\n          }\n          publishFlushedSegments(true);\n          flushSuccess = true;\n        } finally {\n          assert holdsFullFlushLock();\n          docWriter.finishFullFlush(flushSuccess);\n          processEvents(false);\n        }\n      }\n\n      if (applyAllDeletes) {\n        applyAllDeletesAndUpdates();\n      }\n\n      anyChanges |= maybeMerge.getAndSet(false);\n      \n      synchronized(this) {\n        writeReaderPool(applyAllDeletes);\n        doAfterFlush();\n        success = true;\n        return anyChanges;\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"doFlush\");\n      throw tragedy;\n    } finally {\n      if (!success) {\n        if (infoStream.isEnabled(\"IW\")) {\n          infoStream.message(\"IW\", \"hit exception during flush\");\n        }\n        maybeCloseOnTragicEvent();\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["28288370235ed02234a64753cdbf0c6ec096304a"],"7af110b00ea8df9429309d83e38e0533d82e144f":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"f372764a5bd3ebacde5b99ee3303153eb5ec0d2f":["6b8498afacfc8322268ca0d659d274fcce08d557"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["c48871ed951104729f5e17a8ee1091b43fa18980","6483e4260c08168709c02238ae083a51519a28dd"],"6b8498afacfc8322268ca0d659d274fcce08d557":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["7af110b00ea8df9429309d83e38e0533d82e144f"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376","7af110b00ea8df9429309d83e38e0533d82e144f"],"6483e4260c08168709c02238ae083a51519a28dd":["c48871ed951104729f5e17a8ee1091b43fa18980","f492fe129985750df09c8dac738aecc503158bb3"],"901d103ab7c2eeae92b111fc91bb1b00580a3fd7":["e4f3b0a30c9d521b86f768348f832af93505b4eb"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["191128ac5b85671b1671e2c857437694283b6ebf","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["191128ac5b85671b1671e2c857437694283b6ebf","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c48871ed951104729f5e17a8ee1091b43fa18980","191128ac5b85671b1671e2c857437694283b6ebf"],"c48871ed951104729f5e17a8ee1091b43fa18980":["901d103ab7c2eeae92b111fc91bb1b00580a3fd7"],"b07024a7318c25225dc4d070cf6d047315b73aaf":["f372764a5bd3ebacde5b99ee3303153eb5ec0d2f"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"f492fe129985750df09c8dac738aecc503158bb3":["c48871ed951104729f5e17a8ee1091b43fa18980"],"e4f3b0a30c9d521b86f768348f832af93505b4eb":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["86a2e8a56b368d37ef3ba7180541fa317d6fd6c7"],"7af110b00ea8df9429309d83e38e0533d82e144f":["949847c0040cd70a68222d526cb0da7bf6cbb3c2","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4":["9299079153fd7895bf3cf6835cf7019af2ba89b3"],"f372764a5bd3ebacde5b99ee3303153eb5ec0d2f":["b07024a7318c25225dc4d070cf6d047315b73aaf"],"86a2e8a56b368d37ef3ba7180541fa317d6fd6c7":["6b8498afacfc8322268ca0d659d274fcce08d557"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"191128ac5b85671b1671e2c857437694283b6ebf":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"6b8498afacfc8322268ca0d659d274fcce08d557":["f372764a5bd3ebacde5b99ee3303153eb5ec0d2f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["9cdbc2cadeaf282528fe4d1c06e9f8bee38ccec4"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"901d103ab7c2eeae92b111fc91bb1b00580a3fd7":["c48871ed951104729f5e17a8ee1091b43fa18980"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c48871ed951104729f5e17a8ee1091b43fa18980":["191128ac5b85671b1671e2c857437694283b6ebf","6483e4260c08168709c02238ae083a51519a28dd","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","f492fe129985750df09c8dac738aecc503158bb3"],"b07024a7318c25225dc4d070cf6d047315b73aaf":["8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"f492fe129985750df09c8dac738aecc503158bb3":["6483e4260c08168709c02238ae083a51519a28dd"],"8a428f5314daaabf8eab7c50bdc3bc14e6cd1aa2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e4f3b0a30c9d521b86f768348f832af93505b4eb":["901d103ab7c2eeae92b111fc91bb1b00580a3fd7"],"9299079153fd7895bf3cf6835cf7019af2ba89b3":["e4f3b0a30c9d521b86f768348f832af93505b4eb"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","fe33227f6805edab2036cbb80645cc4e2d1fa424","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}