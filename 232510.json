{"path":"lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources#testMultiFunctionHelperEquivilence().mjava","commits":[{"id":"1c8b9dc858d8c3ca3907a4968cfe0b4af03de8fa","date":1434410774,"type":0,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources#testMultiFunctionHelperEquivilence().mjava","pathOld":"/dev/null","sourceNew":"  public void testMultiFunctionHelperEquivilence() throws IOException {\n    // the 2 arg versions of these methods should return the exact same results as\n    // the multi arg versions with a 2 element array\n    \n    // actual doc / index is not relevant for this test\n    final LeafReaderContext leaf = searcher.getIndexReader().leaves().get(0);\n    final Map context = ValueSource.newContext(searcher);\n\n    ALL_EXIST_VS.createWeight(context, searcher);\n    NONE_EXIST_VS.createWeight(context, searcher);\n\n    final FunctionValues ALL = ALL_EXIST_VS.getValues(context, leaf);\n    final FunctionValues NONE = NONE_EXIST_VS.getValues(context, leaf);\n\n    // quick sanity checks of explicit results\n    assertTrue(MultiFunction.allExists(1, ALL, ALL));\n    assertTrue(MultiFunction.allExists(1, new FunctionValues[] {ALL, ALL}));\n    assertTrue(MultiFunction.anyExists(1, ALL, NONE));\n    assertTrue(MultiFunction.anyExists(1, new FunctionValues[] {ALL, NONE}));\n    //\n    assertFalse(MultiFunction.allExists(1, ALL, NONE));\n    assertFalse(MultiFunction.allExists(1, new FunctionValues[] {ALL, NONE}));\n    assertFalse(MultiFunction.anyExists(1, NONE, NONE));\n    assertFalse(MultiFunction.anyExists(1, new FunctionValues[] {NONE, NONE}));\n\n\n    \n    // iterate all permutations and verify equivilence\n    for (FunctionValues firstArg : new FunctionValues[] {ALL, NONE}) {\n      for (FunctionValues secondArg : new FunctionValues[] {ALL, NONE}) {\n        assertEquals(\"allExists(\"+firstArg+\",\"+secondArg+\")\",\n                     MultiFunction.allExists(1, firstArg,secondArg),\n                     MultiFunction.allExists(1, new FunctionValues[] { firstArg,secondArg}));\n        assertEquals(\"anyExists(\"+firstArg+\",\"+secondArg+\")\",\n                     MultiFunction.anyExists(1, firstArg,secondArg),\n                     MultiFunction.anyExists(1, new FunctionValues[] { firstArg,secondArg}));\n        \n        // future proof against posibility of someone \"optimizing\" the array method\n        // if .length==2 ... redundent third arg should give same results as well...\n        assertEquals(\"allExists(\"+firstArg+\",\"+secondArg+\",\"+secondArg+\")\",\n                     MultiFunction.allExists(1, firstArg,secondArg),\n                     MultiFunction.allExists(1, new FunctionValues[] { firstArg,secondArg,secondArg}));\n        assertEquals(\"anyExists(\"+firstArg+\",\"+secondArg+\",\"+secondArg+\")\",\n                     MultiFunction.anyExists(1, firstArg,secondArg),\n                     MultiFunction.anyExists(1, new FunctionValues[] { firstArg,secondArg,secondArg}));\n        \n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2","date":1591961131,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources#testMultiFunctionHelperEquivilence().mjava","pathOld":"lucene/queries/src/test/org/apache/lucene/queries/function/TestValueSources#testMultiFunctionHelperEquivilence().mjava","sourceNew":"  public void testMultiFunctionHelperEquivilence() throws IOException {\n    // the 2 arg versions of these methods should return the exact same results as\n    // the multi arg versions with a 2 element array\n    \n    // actual doc / index is not relevant for this test\n    final LeafReaderContext leaf = searcher.getIndexReader().leaves().get(0);\n    final Map<Object, Object> context = ValueSource.newContext(searcher);\n\n    ALL_EXIST_VS.createWeight(context, searcher);\n    NONE_EXIST_VS.createWeight(context, searcher);\n\n    final FunctionValues ALL = ALL_EXIST_VS.getValues(context, leaf);\n    final FunctionValues NONE = NONE_EXIST_VS.getValues(context, leaf);\n\n    // quick sanity checks of explicit results\n    assertTrue(MultiFunction.allExists(1, ALL, ALL));\n    assertTrue(MultiFunction.allExists(1, new FunctionValues[] {ALL, ALL}));\n    assertTrue(MultiFunction.anyExists(1, ALL, NONE));\n    assertTrue(MultiFunction.anyExists(1, new FunctionValues[] {ALL, NONE}));\n    //\n    assertFalse(MultiFunction.allExists(1, ALL, NONE));\n    assertFalse(MultiFunction.allExists(1, new FunctionValues[] {ALL, NONE}));\n    assertFalse(MultiFunction.anyExists(1, NONE, NONE));\n    assertFalse(MultiFunction.anyExists(1, new FunctionValues[] {NONE, NONE}));\n\n\n    \n    // iterate all permutations and verify equivilence\n    for (FunctionValues firstArg : new FunctionValues[] {ALL, NONE}) {\n      for (FunctionValues secondArg : new FunctionValues[] {ALL, NONE}) {\n        assertEquals(\"allExists(\"+firstArg+\",\"+secondArg+\")\",\n                     MultiFunction.allExists(1, firstArg,secondArg),\n                     MultiFunction.allExists(1, new FunctionValues[] { firstArg,secondArg}));\n        assertEquals(\"anyExists(\"+firstArg+\",\"+secondArg+\")\",\n                     MultiFunction.anyExists(1, firstArg,secondArg),\n                     MultiFunction.anyExists(1, new FunctionValues[] { firstArg,secondArg}));\n        \n        // future proof against posibility of someone \"optimizing\" the array method\n        // if .length==2 ... redundent third arg should give same results as well...\n        assertEquals(\"allExists(\"+firstArg+\",\"+secondArg+\",\"+secondArg+\")\",\n                     MultiFunction.allExists(1, firstArg,secondArg),\n                     MultiFunction.allExists(1, new FunctionValues[] { firstArg,secondArg,secondArg}));\n        assertEquals(\"anyExists(\"+firstArg+\",\"+secondArg+\",\"+secondArg+\")\",\n                     MultiFunction.anyExists(1, firstArg,secondArg),\n                     MultiFunction.anyExists(1, new FunctionValues[] { firstArg,secondArg,secondArg}));\n        \n      }\n    }\n  }\n\n","sourceOld":"  public void testMultiFunctionHelperEquivilence() throws IOException {\n    // the 2 arg versions of these methods should return the exact same results as\n    // the multi arg versions with a 2 element array\n    \n    // actual doc / index is not relevant for this test\n    final LeafReaderContext leaf = searcher.getIndexReader().leaves().get(0);\n    final Map context = ValueSource.newContext(searcher);\n\n    ALL_EXIST_VS.createWeight(context, searcher);\n    NONE_EXIST_VS.createWeight(context, searcher);\n\n    final FunctionValues ALL = ALL_EXIST_VS.getValues(context, leaf);\n    final FunctionValues NONE = NONE_EXIST_VS.getValues(context, leaf);\n\n    // quick sanity checks of explicit results\n    assertTrue(MultiFunction.allExists(1, ALL, ALL));\n    assertTrue(MultiFunction.allExists(1, new FunctionValues[] {ALL, ALL}));\n    assertTrue(MultiFunction.anyExists(1, ALL, NONE));\n    assertTrue(MultiFunction.anyExists(1, new FunctionValues[] {ALL, NONE}));\n    //\n    assertFalse(MultiFunction.allExists(1, ALL, NONE));\n    assertFalse(MultiFunction.allExists(1, new FunctionValues[] {ALL, NONE}));\n    assertFalse(MultiFunction.anyExists(1, NONE, NONE));\n    assertFalse(MultiFunction.anyExists(1, new FunctionValues[] {NONE, NONE}));\n\n\n    \n    // iterate all permutations and verify equivilence\n    for (FunctionValues firstArg : new FunctionValues[] {ALL, NONE}) {\n      for (FunctionValues secondArg : new FunctionValues[] {ALL, NONE}) {\n        assertEquals(\"allExists(\"+firstArg+\",\"+secondArg+\")\",\n                     MultiFunction.allExists(1, firstArg,secondArg),\n                     MultiFunction.allExists(1, new FunctionValues[] { firstArg,secondArg}));\n        assertEquals(\"anyExists(\"+firstArg+\",\"+secondArg+\")\",\n                     MultiFunction.anyExists(1, firstArg,secondArg),\n                     MultiFunction.anyExists(1, new FunctionValues[] { firstArg,secondArg}));\n        \n        // future proof against posibility of someone \"optimizing\" the array method\n        // if .length==2 ... redundent third arg should give same results as well...\n        assertEquals(\"allExists(\"+firstArg+\",\"+secondArg+\",\"+secondArg+\")\",\n                     MultiFunction.allExists(1, firstArg,secondArg),\n                     MultiFunction.allExists(1, new FunctionValues[] { firstArg,secondArg,secondArg}));\n        assertEquals(\"anyExists(\"+firstArg+\",\"+secondArg+\",\"+secondArg+\")\",\n                     MultiFunction.anyExists(1, firstArg,secondArg),\n                     MultiFunction.anyExists(1, new FunctionValues[] { firstArg,secondArg,secondArg}));\n        \n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"1c8b9dc858d8c3ca3907a4968cfe0b4af03de8fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["1c8b9dc858d8c3ca3907a4968cfe0b4af03de8fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["1c8b9dc858d8c3ca3907a4968cfe0b4af03de8fa"],"1c8b9dc858d8c3ca3907a4968cfe0b4af03de8fa":["f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2"],"f95c0e33e58652b2a4d8560c8297dbe86ff5b1f2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}