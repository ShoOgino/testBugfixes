{"path":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#collect(DocSet,int,IntFunction[SlotContext]).mjava","commits":[{"id":"2c705a0d590cf911e7c942df49563ca2ea176e22","date":1526916174,"type":1,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#collect(DocSet,int,IntFunction[SlotContext]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#collect(DocSet,int).mjava","sourceNew":"  int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      // we may be in a \"processEmpty\" type situation where the client still cares about this bucket\n      // either way, we should let our accumulators know about the empty set, so they can collect &\n      // compute the slot (ie: let them decide if they care even when it's size==0)\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); // NOT per-seg collectors\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            // should be impossible\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  // per-seg collectors\n    }\n    return count;\n  }\n\n","sourceOld":"  int collect(DocSet docs, int slot) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            // should be impossible\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot);  // per-seg collectors\n    }\n    return count;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1c841e27891873cab110ebeb89f124a8ec470176","date":1586527220,"type":3,"author":"Munendra S N","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#collect(DocSet,int,IntFunction[SlotContext]).mjava","pathOld":"solr/core/src/java/org/apache/solr/search/facet/FacetProcessor#collect(DocSet,int,IntFunction[SlotContext]).mjava","sourceNew":"  long collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    long count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      // we may be in a \"processEmpty\" type situation where the client still cares about this bucket\n      // either way, we should let our accumulators know about the empty set, so they can collect &\n      // compute the slot (ie: let them decide if they care even when it's size==0)\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); // NOT per-seg collectors\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            // should be impossible\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  // per-seg collectors\n    }\n    return count;\n  }\n\n","sourceOld":"  int collect(DocSet docs, int slot, IntFunction<SlotContext> slotContext) throws IOException {\n    int count = 0;\n    SolrIndexSearcher searcher = fcontext.searcher;\n\n    if (0 == docs.size()) {\n      // we may be in a \"processEmpty\" type situation where the client still cares about this bucket\n      // either way, we should let our accumulators know about the empty set, so they can collect &\n      // compute the slot (ie: let them decide if they care even when it's size==0)\n      if (accs != null) {\n        for (SlotAcc acc : accs) {\n          acc.collect(docs, slot, slotContext); // NOT per-seg collectors\n        }\n      }\n      return count;\n    }\n    \n    final List<LeafReaderContext> leaves = searcher.getIndexReader().leaves();\n    final Iterator<LeafReaderContext> ctxIt = leaves.iterator();\n    LeafReaderContext ctx = null;\n    int segBase = 0;\n    int segMax;\n    int adjustedMax = 0;\n    for (DocIterator docsIt = docs.iterator(); docsIt.hasNext(); ) {\n      final int doc = docsIt.nextDoc();\n      if (doc >= adjustedMax) {\n        do {\n          ctx = ctxIt.next();\n          if (ctx == null) {\n            // should be impossible\n            throw new RuntimeException(\"INTERNAL FACET ERROR\");\n          }\n          segBase = ctx.docBase;\n          segMax = ctx.reader().maxDoc();\n          adjustedMax = segBase + segMax;\n        } while (doc >= adjustedMax);\n        assert doc >= ctx.docBase;\n        setNextReader(ctx);\n      }\n      count++;\n      collect(doc - segBase, slot, slotContext);  // per-seg collectors\n    }\n    return count;\n  }\n\n","bugFix":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"1c841e27891873cab110ebeb89f124a8ec470176":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["1c841e27891873cab110ebeb89f124a8ec470176"]},"commit2Childs":{"1c841e27891873cab110ebeb89f124a8ec470176":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2c705a0d590cf911e7c942df49563ca2ea176e22":["1c841e27891873cab110ebeb89f124a8ec470176"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["2c705a0d590cf911e7c942df49563ca2ea176e22"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}