{"path":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","commits":[{"id":"571abba77e55fea386a38c0024f72ffa5b37a9ad","date":1360272747,"type":1,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(FacetArrays,int).mjava","sourceNew":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    int partitionSize = facetArrays.arrayLength; // all partitions, except, possibly, the last,\n    // have the same length. Hence modulo is OK.\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = this.facetRequest.getValueOf(facetArrays, rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = facetRequest.getValueOf(facetArrays, tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = this.facetRequest.getValueOf(facetArrays, rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","sourceOld":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#getNumResults()}) children\n   * among its children that are encountered in the given particular partition\n   * (aka current counting list).\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential\n   *         {@link FacetResult} nodes to their top K children encountered in\n   *         the current partition. Note that the mapped potential tree nodes\n   *         need not belong to the given partition, only the top K children\n   *         mapped to. The aim is to identify nodes that are certainly excluded\n   *         from the {@link FacetResult} to be eventually (after going through\n   *         all the partitions) returned by this handler, because they have K\n   *         better siblings, already identified in this partition. For the\n   *         identified excluded nodes, we only count number of their\n   *         descendants in the subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @param arrays the already filled in count array, potentially only covering\n   *        one partition: the ordinals ranging from\n   * @param offset to <code>offset</code> + the length of the count arrays\n   *        within <code>arrays</code> (exclusive)\n   * @throws IOException in case\n   *         {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *         does.\n   * @see FacetResultsHandler#fetchPartitionResult(FacetArrays, int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(FacetArrays arrays, int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.getNumResults(),taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    int partitionSize = arrays.arrayLength; // all partitions, except, possibly, the last,\n    // have the same length. Hence modulo is OK.\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, arrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = this.facetRequest.getValueOf(arrays, rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = facetRequest.getValueOf(arrays, tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, arrays, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, arrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = this.facetRequest.getValueOf(arrays, rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3b1c67b5eba853532b31132bf5aef70a3b2be63f","date":1375351298,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","sourceNew":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    // all partitions, except, possibly, the last, have the same length. Hence modulo is OK.\n    int partitionSize = facetArrays.arrayLength;\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = resolver.valueOf(tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","sourceOld":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    int partitionSize = facetArrays.arrayLength; // all partitions, except, possibly, the last,\n    // have the same length. Hence modulo is OK.\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = this.facetRequest.getValueOf(facetArrays, rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = facetRequest.getValueOf(facetArrays, tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = this.facetRequest.getValueOf(facetArrays, rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","sourceNew":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    // all partitions, except, possibly, the last, have the same length. Hence modulo is OK.\n    int partitionSize = facetArrays.arrayLength;\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = resolver.valueOf(tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","sourceOld":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    int partitionSize = facetArrays.arrayLength; // all partitions, except, possibly, the last,\n    // have the same length. Hence modulo is OK.\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = this.facetRequest.getValueOf(facetArrays, rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = facetRequest.getValueOf(facetArrays, tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = this.facetRequest.getValueOf(facetArrays, rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c190847801a50f4dd20fd639bdc29b54ea3b288b","date":1384461522,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","sourceNew":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.FacetLabel)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    // all partitions, except, possibly, the last, have the same length. Hence modulo is OK.\n    int partitionSize = facetArrays.arrayLength;\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = resolver.valueOf(tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","sourceOld":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    // all partitions, except, possibly, the last, have the same length. Hence modulo is OK.\n    int partitionSize = facetArrays.arrayLength;\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = resolver.valueOf(tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d33e19a97046248623a7591aeaa6547233fd15e2","date":1385424777,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.FacetLabel)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    // all partitions, except, possibly, the last, have the same length. Hence modulo is OK.\n    int partitionSize = facetArrays.arrayLength;\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = resolver.valueOf(tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3cc728b07df73b197e6d940d27f9b08b63918f13","date":1388834348,"type":4,"author":"Michael McCandless","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/facet/src/java/org/apache/lucene/facet/search/TopKInEachNodeHandler#fetchPartitionResult(int).mjava","sourceNew":null,"sourceOld":"  /**\n   * Recursively explore all facets that can be potentially included in the\n   * {@link FacetResult} to be generated, and that belong to the given\n   * partition, so that values can be examined and collected. For each such\n   * node, gather its top K ({@link FacetRequest#numResults}) children among its\n   * children that are encountered in the given particular partition (aka\n   * current counting list).\n   * @param offset\n   *          to <code>offset</code> + the length of the count arrays within\n   *          <code>arrays</code> (exclusive)\n   * \n   * @return {@link IntermediateFacetResult} consisting of\n   *         {@link IntToObjectMap} that maps potential {@link FacetResult}\n   *         nodes to their top K children encountered in the current partition.\n   *         Note that the mapped potential tree nodes need not belong to the\n   *         given partition, only the top K children mapped to. The aim is to\n   *         identify nodes that are certainly excluded from the\n   *         {@link FacetResult} to be eventually (after going through all the\n   *         partitions) returned by this handler, because they have K better\n   *         siblings, already identified in this partition. For the identified\n   *         excluded nodes, we only count number of their descendants in the\n   *         subtree (to be included in\n   *         {@link FacetResult#getNumValidDescendants()}), but not bother with\n   *         selecting top K in these generations, which, by definition, are,\n   *         too, excluded from the FacetResult tree.\n   * @throws IOException\n   *           in case\n   *           {@link TaxonomyReader#getOrdinal(org.apache.lucene.facet.taxonomy.CategoryPath)}\n   *           does.\n   * @see #fetchPartitionResult(int)\n   */\n  @Override\n  public IntermediateFacetResult fetchPartitionResult(int offset) throws IOException {\n\n    // get the root of the result tree to be returned, and the depth of that result tree\n    // (depth means number of node levels excluding the root). \n    int rootNode = this.taxonomyReader.getOrdinal(facetRequest.categoryPath);\n    if (rootNode == TaxonomyReader.INVALID_ORDINAL) {\n      return null;\n    }\n\n    int K = Math.min(facetRequest.numResults,taxonomyReader.getSize()); // number of best results in each node\n\n    // this will grow into the returned IntermediateFacetResult\n    IntToObjectMap<AACO> AACOsOfOnePartition = new IntToObjectMap<AACO>();\n\n    // all partitions, except, possibly, the last, have the same length. Hence modulo is OK.\n    int partitionSize = facetArrays.arrayLength;\n\n    int depth = facetRequest.getDepth();\n\n    if (depth == 0) {\n      // Need to only have root node.\n      IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n          facetRequest, AACOsOfOnePartition);\n      if (isSelfPartition(rootNode, facetArrays, offset)) {\n        tempFRWH.isRootNodeIncluded = true;\n        tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n      }\n      return tempFRWH;\n    }\n\n    if (depth > Short.MAX_VALUE - 3) {\n      depth = Short.MAX_VALUE -3;\n    }\n\n    int endOffset = offset + partitionSize; // one past the largest ordinal in the partition\n    ParallelTaxonomyArrays childrenArray = taxonomyReader.getParallelTaxonomyArrays();\n    int[] children = childrenArray.children();\n    int[] siblings = childrenArray.siblings();\n    int totalNumOfDescendantsConsidered = 0; // total number of facets with value != 0, \n    // in the tree. These include those selected as top K in each node, and all the others that\n    // were not. Not including rootNode\n\n    // the following priority queue will be used again and again for each node recursed into\n    // to select its best K children among its children encountered in the given partition\n    PriorityQueue<AggregatedCategory> pq = \n      new AggregatedCategoryHeap(K, this.getSuitableACComparator());\n\n    // reusables will feed the priority queue in each use \n    AggregatedCategory [] reusables = new AggregatedCategory[2+K];\n    for (int i = 0; i < reusables.length; i++) {\n      reusables[i] = new AggregatedCategory(1,0);\n    }\n\n    /*\n     * The returned map is built by a recursive visit of potential tree nodes. Nodes \n     * determined to be excluded from the FacetResult are not recursively explored as others,\n     * they are only recursed in order to count the number of their descendants.\n     * Also, nodes that they and any of their descendants can not be mapped into facets encountered \n     * in this partition, are, too, explored no further. These are facets whose ordinal \n     * numbers are greater than the ordinals of the given partition. (recall that the Taxonomy\n     * maintains that a parent ordinal is smaller than any of its descendants' ordinals).  \n     * So, when scanning over all children of a potential tree node n: (1) all children with ordinal number\n     * greater than those in the given partition are skipped over, (2) among the children of n residing\n     * in this partition, the best K children are selected (using pq) for usual further recursion \n     * and the rest (those rejected out from the pq) are only recursed for counting total number\n     * of descendants, and (3) all the children of ordinal numbers smaller than the given partition \n     * are further explored in the usual way, since these may lead to descendants residing in this partition.\n     * \n     * ordinalStack drives the recursive descent. \n     * Top of stack holds the current node which we recurse from.\n     * ordinalStack[0] holds the root of the facetRequest, and\n     * it is always maintained that parent(ordianlStack[i]) = ordinalStack[i-1]. \n     * localDepth points to the current top of ordinalStack.\n     * Only top of ordinalStack can be TaxonomyReader.INVALID_ORDINAL, and this if and only if\n     * the element below it explored all its relevant children.\n     */\n    int[] ordinalStack = new int[depth+2]; // for 0 and for invalid on top\n    ordinalStack[0] = rootNode;\n    int localDepth = 0;\n\n    /* \n     * bestSignlingsStack[i] maintains the best K children of ordinalStack[i-1], namely,\n     * the best K siblings of ordinalStack[i], best K among those residing in the given partition.\n     * Note that the residents of ordinalStack need not belong\n     * to the current partition, only the residents of bestSignlingsStack.\n     * When exploring the children of ordianlStack[i-1] that reside in the current partition\n     * (after the top K of them have been determined and stored into bestSignlingsStack[i]),\n     * siblingExplored[i] points into bestSignlingsStack[i], to the child now explored, hence\n     * residing in ordinalStack[i], and firstToTheLeftOfPartition[i] holds the largest ordinal of\n     * a sibling smaller than the ordinals in the partition.  \n     * When siblingExplored[i] == max int, the top K siblings of ordinalStack[i] among those siblings\n     * that reside in this partition have not been determined yet. \n     * if siblingExplored[i] < 0, the node in ordinalStack[i] is to the left of partition \n     * (i.e. of a smaller ordinal than the current partition) \n     * (step (3) above is executed for the children of ordianlStack[i-1])   \n     */\n    int[][] bestSignlingsStack = new int[depth+2][];\n    int[] siblingExplored = new int[depth+2];\n    int[] firstToTheLeftOfPartition = new int [depth+2];\n\n    int tosOrdinal; // top of stack element, the ordinal at the top of stack\n\n    /*\n     * to start the loop, complete the datastructures for root node: \n     * push its youngest child to ordinalStack; make a note in siblingExplored[] that the children\n     * of rootNode, which reside in the current partition have not been read yet to select the top\n     * K of them.  Also, make rootNode as if, related to its parent, rootNode belongs to the children\n     * of ordinal numbers smaller than those of the current partition (this will ease on end condition -- \n     * we can continue to the older sibling of rootNode once the localDepth goes down, before we verify that \n     * it went that down)\n     */\n    ordinalStack[++localDepth] = children[rootNode];\n    siblingExplored[localDepth] = Integer.MAX_VALUE;  // we have not verified position wrt current partition\n    siblingExplored[0] = -1; // as if rootNode resides to the left of current position\n\n    /*\n     * now the whole recursion: loop as long as stack is not empty of elements descendants of \n     * facetRequest's root.\n     */\n\n    while (localDepth > 0) {\n      tosOrdinal = ordinalStack[localDepth];\n      if (tosOrdinal == TaxonomyReader.INVALID_ORDINAL) {\n        // the brotherhood that has been occupying the top of stack is all exhausted.  \n        // Hence, element below tos, namely, father of tos, has all its children, \n        // and itself, all explored. \n        localDepth--;\n        // replace this father, now on top of stack, by this father's sibling:\n        // this parent's ordinal can not be greater than current partition, as otherwise\n        // its child, now just removed, would not have been pushed on it.\n        // so the father is either inside the partition, or smaller ordinal\n        if (siblingExplored[localDepth] < 0 ) {\n          ordinalStack[localDepth] = siblings[ordinalStack[localDepth]];\n          continue;\n        } \n        // in this point, siblingExplored[localDepth] between 0 and number of bestSiblings\n        // it can not be max int\n        siblingExplored[localDepth]--;\n        if (siblingExplored[localDepth] == -1 ) {\n          //siblings residing in the partition have been all processed, we now move\n          // to those of ordinal numbers smaller than the partition\n          ordinalStack[localDepth] = firstToTheLeftOfPartition[localDepth];\n        } else {\n          // still explore siblings residing in the partition\n          // just move to the next one\n          ordinalStack[localDepth] = bestSignlingsStack[localDepth][siblingExplored[localDepth]];\n        }\n        continue;\n      } // endof tosOrdinal is invalid, and hence removed, and its parent was replaced by this \n      // parent's sibling\n\n      // now try to push a kid, but first look at tos whether it 'deserves' its kids explored:\n      // it is not to the right of current partition, and we know whether to only count or to \n      // select best K siblings.\n      if (siblingExplored[localDepth] == Integer.MAX_VALUE) {\n        //tosOrdinal was not examined yet for its position relative to current partition\n        // and the best K of current partition, among its siblings, have not been determined yet\n        while (tosOrdinal >= endOffset) {\n          tosOrdinal = siblings[tosOrdinal];\n        }\n        // now it is inside. Run it and all its siblings inside the partition through a heap\n        // and in doing so, count them, find best K\n        pq.clear();\n\n        //reusables are consumed as from a stack. The stack starts full and returns full.\n        int tosReuslables = reusables.length -1;  \n\n        while (tosOrdinal >= offset) { // while tosOrdinal belongs to the given partition; here, too, we use the fact\n          // that TaxonomyReader.INVALID_ORDINAL == -1 < offset\n          double value = resolver.valueOf(tosOrdinal % partitionSize);\n          if (value != 0) { // the value of yc is not 0, it is to be considered.  \n            totalNumOfDescendantsConsidered++;\n\n            // consume one reusable, and push to the priority queue\n            AggregatedCategory ac = reusables[tosReuslables--];  \n            ac.ordinal = tosOrdinal;\n            ac.value = value; \n            ac = pq.insertWithOverflow(ac);\n            if (null != ac) {\n              /* when a facet is excluded from top K, because already in this partition it has\n               * K better siblings, it is only recursed for count only.\n               */ \n              // update totalNumOfDescendants by the now excluded node and all its descendants\n              totalNumOfDescendantsConsidered--; // reduce the 1 earned when the excluded node entered the heap\n              // and now return it and all its descendants. These will never make it to FacetResult\n              totalNumOfDescendantsConsidered += countOnly (ac.ordinal, children, \n                  siblings, partitionSize, offset, endOffset, localDepth, depth);\n              reusables[++tosReuslables] = ac;\n            }\n          }\n          tosOrdinal = siblings[tosOrdinal];  \n        }\n        // now pq has best K children of ordinals that belong to the given partition.   \n        // Populate a new AACO with them.\n        // tosOrdinal is now first sibling smaller than partition, make a note of that\n        firstToTheLeftOfPartition[localDepth] = tosOrdinal;\n        int aaci = pq.size();\n        int[] ords = new int[aaci];\n        double [] vals = new double [aaci];\n        while (aaci > 0) {\n          AggregatedCategory ac = pq.pop();\n          ords[--aaci] = ac.ordinal;\n          vals[aaci] = ac.value;\n          reusables[++tosReuslables] = ac;\n        }\n        // if more than 0 ordinals, add this AACO to the map to be returned, \n        // and add ords to sibling stack, and make a note in siblingExplored that these are to \n        // be visited now\n        if (ords.length > 0) {\n          AACOsOfOnePartition.put(ordinalStack[localDepth-1], new AACO(ords,vals));\n          bestSignlingsStack[localDepth] = ords;\n          siblingExplored[localDepth] = ords.length-1;\n          ordinalStack[localDepth] = ords[ords.length-1];\n        } else {\n          // no ordinals siblings of tosOrdinal in current partition, move to the left of it\n          // tosOrdinal is already there (to the left of partition).\n          // make a note of it in siblingExplored\n          ordinalStack[localDepth] = tosOrdinal;\n          siblingExplored[localDepth] = -1;\n        }\n        continue;\n      } // endof we did not check the position of a valid ordinal wrt partition\n\n      // now tosOrdinal is a valid ordinal, inside partition or to the left of it, we need \n      // to push its kids on top of it, if not too deep. \n      // Make a note that we did not check them yet\n      if (localDepth >= depth) { \n        // localDepth == depth; current tos exhausted its possible children, mark this by pushing INVALID_ORDINAL\n        ordinalStack[++localDepth] = TaxonomyReader.INVALID_ORDINAL;\n        continue;\n      }\n      ordinalStack[++localDepth] = children[tosOrdinal];\n      siblingExplored[localDepth] = Integer.MAX_VALUE;\n    } // endof loop while stack is not empty\n\n    // now generate a TempFacetResult from AACOsOfOnePartition, and consider self.\n    IntermediateFacetResultWithHash tempFRWH = new IntermediateFacetResultWithHash(\n        facetRequest, AACOsOfOnePartition);\n    if (isSelfPartition(rootNode, facetArrays, offset)) {\n      tempFRWH.isRootNodeIncluded = true;\n      tempFRWH.rootNodeValue = resolver.valueOf(rootNode % partitionSize);\n    }\n    tempFRWH.totalNumOfFacetsConsidered = totalNumOfDescendantsConsidered;\n    return tempFRWH;\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"3b1c67b5eba853532b31132bf5aef70a3b2be63f":["571abba77e55fea386a38c0024f72ffa5b37a9ad"],"d33e19a97046248623a7591aeaa6547233fd15e2":["c190847801a50f4dd20fd639bdc29b54ea3b288b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["571abba77e55fea386a38c0024f72ffa5b37a9ad"],"3cc728b07df73b197e6d940d27f9b08b63918f13":["3b1c67b5eba853532b31132bf5aef70a3b2be63f","d33e19a97046248623a7591aeaa6547233fd15e2"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["3b1c67b5eba853532b31132bf5aef70a3b2be63f"]},"commit2Childs":{"3b1c67b5eba853532b31132bf5aef70a3b2be63f":["3cc728b07df73b197e6d940d27f9b08b63918f13","c190847801a50f4dd20fd639bdc29b54ea3b288b"],"d33e19a97046248623a7591aeaa6547233fd15e2":["3cc728b07df73b197e6d940d27f9b08b63918f13"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["571abba77e55fea386a38c0024f72ffa5b37a9ad"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"3cc728b07df73b197e6d940d27f9b08b63918f13":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"571abba77e55fea386a38c0024f72ffa5b37a9ad":["3b1c67b5eba853532b31132bf5aef70a3b2be63f","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"c190847801a50f4dd20fd639bdc29b54ea3b288b":["d33e19a97046248623a7591aeaa6547233fd15e2"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}