{"path":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"042e4d934397657ba04c82b46cc5665076bc5c58","date":1336511170,"type":3,"author":"Ryan McKinley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"stream.file\",filename,\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"stream.file\",filename, \"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","date":1376375609,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","pathOld":"solr/core/src/test/org/apache/solr/handler/TestCSVLoader#testCSV().mjava","sourceNew":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","sourceOld":"  @Test\n  public void testCSV() throws Exception {\n    lrf.args.put(CommonParams.VERSION,\"2.2\");\n    \n    makeFile(\"id,str_s\\n100,\\\"quoted\\\"\\n101,\\n102,\\\"\\\"\\n103,\");\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    // 102 is a quoted zero length field ,\"\", as opposed to ,,\n    // but we can't distinguish this case (and it's debateable\n    // if we should).  Does CSV have a way to specify missing\n    // from zero-length?\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test overwrite by default\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test explicitly adding header=true (the default)\n    loadLocal(\"commit\",\"true\",\"header\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test no overwrites\n    loadLocal(\"commit\",\"true\", \"overwrite\",\"false\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='8']\");\n\n    // test overwrite\n    loadLocal(\"commit\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n\n    // test global value mapping\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:102\"),\"count(//str[@name='str_s'])=0\");\n    assertQ(req(\"id:103\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping to empty (remove)\n    loadLocal(\"commit\",\"true\", \"map\",\"quoted:\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"count(//str[@name='str_s'])=0\");\n\n    // test value mapping from empty\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test multiple map rules\n    loadLocal(\"commit\",\"true\", \"map\",\":EMPTY\", \"map\",\"quoted:QUOTED\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='QUOTED']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n    // test indexing empty fields\n    loadLocal(\"commit\",\"true\", \"f.str_s.keepEmpty\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='']\");\n\n    // test overriding the name of fields\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"true\",\n             \"f.my_s.map\",\":EMPTY\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:102\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:103\"),\"count(//arr[@name='str_s']/str)=0\");\n    assertQ(req(\"id:101\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='my_s']/str[.='EMPTY']\");\n\n    // test that header in file was skipped\n    assertQ(req(\"id:id\"),\"//*[@numFound='0']\");\n\n    // test skipping a field via the \"skip\" parameter\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"skip\",\"str_s\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test skipping a field by specifying an empty name\n    loadLocal(\"commit\",\"true\",\"keepEmpty\",\"true\",\"fieldnames\",\"id,\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:[100 TO 110]\"),\"count(//str[@name='str_s']/str)=0\");\n\n    // test loading file as if it didn't have a header\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n    // test skipLines\n    loadLocal(\"commit\",\"true\",\n             \"fieldnames\",\"id,my_s\", \"header\",\"false\", \"skipLines\",\"1\");\n    assertQ(req(\"id:id\"),\"//*[@numFound='1']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='my_s']/str[.='quoted']\");\n\n\n    // test multi-valued fields via field splitting w/ mapping of subvalues\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted\\\"\\n\"\n            +\"101,\\\"a,b,c\\\"\\n\"\n            +\"102,\\\"a,,b\\\"\\n\"\n            +\"103,\\n\");\n    loadLocal(\"commit\",\"true\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\");\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='4']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n\n\n    // test alternate values for delimiters\n    makeFile(\"id|str_s\\n\"\n            +\"100|^quoted^\\n\"\n            +\"101|a;'b';c\\n\"\n            +\"102|a;;b\\n\"\n            +\"103|\\n\"\n            +\"104|a\\\\\\\\b\\n\"  // no backslash escaping should be done by default\n    );\n\n    loadLocal(\"commit\",\"true\",\n              \"separator\",\"|\",\n              \"encapsulator\",\"^\",\n              \"f.str_s.map\",\":EMPTY\",\n              \"f.str_s.split\",\"true\",\n              \"f.str_s.separator\",\";\",\n              \"f.str_s.encapsulator\",\"'\"\n    );\n    assertQ(req(\"id:[100 TO 110]\"),\"//*[@numFound='5']\");\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[1][.='a']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[2][.='b']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[3][.='c']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[2][.='EMPTY']\");\n    assertQ(req(\"id:103\"),\"//arr[@name='str_s']/str[.='EMPTY']\");\n    assertQ(req(\"id:104\"),\"//arr[@name='str_s']/str[.='a\\\\\\\\b']\");\n\n    // test no escaping + double encapsulator escaping by default\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\ string\\\"\\n\"\n            +\"101,unquoted \\\"\\\" \\\\ string\\n\"     // double encap shouldn't be an escape outside encap\n            +\"102,end quote \\\\\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='quoted \\\" \\\\ string']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\\ string']\");\n    assertQ(req(\"id:102\"),\"//arr[@name='str_s']/str[.='end quote \\\\']\");\n\n\n    // setting an escape should disable encapsulator\n    makeFile(\"id,str_s\\n\"\n            +\"100,\\\"quoted \\\"\\\" \\\\\\\" \\\\\\\\ string\\\"\\n\"  // quotes should be part of value\n            +\"101,unquoted \\\"\\\" \\\\\\\" \\\\, \\\\\\\\ string\\n\"\n    );\n    loadLocal(\"commit\",\"true\"\n            ,\"escape\",\"\\\\\"\n    );\n    assertQ(req(\"id:100\"),\"//arr[@name='str_s']/str[.='\\\"quoted \\\"\\\" \\\" \\\\ string\\\"']\");\n    assertQ(req(\"id:101\"),\"//arr[@name='str_s']/str[.='unquoted \\\"\\\" \\\" , \\\\ string']\");\n\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":["042e4d934397657ba04c82b46cc5665076bc5c58","19275ba31e621f6da1b83bf13af75233876fd3d4"],"042e4d934397657ba04c82b46cc5665076bc5c58":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["042e4d934397657ba04c82b46cc5665076bc5c58"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["19275ba31e621f6da1b83bf13af75233876fd3d4"]},"commit2Childs":{"716d18f3a9b0993bc679d7fa7abdc9bfb03411ec":[],"042e4d934397657ba04c82b46cc5665076bc5c58":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","19275ba31e621f6da1b83bf13af75233876fd3d4"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"c26f00b574427b55127e869b935845554afde1fa":["042e4d934397657ba04c82b46cc5665076bc5c58"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["716d18f3a9b0993bc679d7fa7abdc9bfb03411ec","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}