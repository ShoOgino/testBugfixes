{"path":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","commits":[{"id":"8bc9f3cab5bcaa03021a8677cda720596f0da2f8","date":1383747827,"type":0,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"/dev/null","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", \"./core1\", true, true);\n      createViaAdmin(cc, \"core2\", \"./core2\", true, false);\n      createViaAdmin(cc, \"core3\", \"./core3\", true, true);\n      createViaAdmin(cc, \"core4\", \"./core4\", true, false);\n      createViaAdmin(cc, \"core5\", \"./core5\", true, false);\n\n      SolrCore c1 = cc.getCore(\"core1\");\n      SolrCore c2 = cc.getCore(\"core2\");\n      SolrCore c3 = cc.getCore(\"core3\");\n      SolrCore c4 = cc.getCore(\"core4\");\n      SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collectionLazy2\", \"collectionLazy3\", \"collectionLazy4\", \"collectionLazy6\"\n          , \"collectionLazy7\", \"collectionLazy8\", \"collectionLazy9\");\n\n      checkInCores(cc, \"collection1\", \"collectionLazy5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      c1.close();\n      c2.close();\n      c3.close();\n      c4.close();\n      c5.close();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["625b61328a0889d9b3d61cdcbfc490339f61096e"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4bf7f9f53612fef6f228670ddd031bbdfaa1218b","date":1383842832,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", \"./core1\", true, true);\n      createViaAdmin(cc, \"core2\", \"./core2\", true, false);\n      createViaAdmin(cc, \"core3\", \"./core3\", true, true);\n      createViaAdmin(cc, \"core4\", \"./core4\", true, false);\n      createViaAdmin(cc, \"core5\", \"./core5\", true, false);\n\n      SolrCore c1 = cc.getCore(\"core1\");\n      SolrCore c2 = cc.getCore(\"core2\");\n      SolrCore c3 = cc.getCore(\"core3\");\n      SolrCore c4 = cc.getCore(\"core4\");\n      SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collectionLazy2\", \"collectionLazy3\", \"collectionLazy4\", \"collectionLazy6\"\n          , \"collectionLazy7\", \"collectionLazy8\", \"collectionLazy9\");\n\n      checkInCores(cc, \"collection1\", \"collectionLazy5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      c1.close();\n      c2.close();\n      c3.close();\n      c4.close();\n      c5.close();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", \"./core1\", true, true);\n      createViaAdmin(cc, \"core2\", \"./core2\", true, false);\n      createViaAdmin(cc, \"core3\", \"./core3\", true, true);\n      createViaAdmin(cc, \"core4\", \"./core4\", true, false);\n      createViaAdmin(cc, \"core5\", \"./core5\", true, false);\n\n      SolrCore c1 = cc.getCore(\"core1\");\n      SolrCore c2 = cc.getCore(\"core2\");\n      SolrCore c3 = cc.getCore(\"core3\");\n      SolrCore c4 = cc.getCore(\"core4\");\n      SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collectionLazy2\", \"collectionLazy3\", \"collectionLazy4\", \"collectionLazy6\"\n          , \"collectionLazy7\", \"collectionLazy8\", \"collectionLazy9\");\n\n      checkInCores(cc, \"collection1\", \"collectionLazy5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      c1.close();\n      c2.close();\n      c3.close();\n      c4.close();\n      c5.close();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11d8a050b7d5f98040f790d32ec1cfd2fc3490e3","date":1448892165,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      SolrCore c1 = cc.getCore(\"core1\");\n      SolrCore c2 = cc.getCore(\"core2\");\n      SolrCore c3 = cc.getCore(\"core3\");\n      SolrCore c4 = cc.getCore(\"core4\");\n      SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      c1.close();\n      c2.close();\n      c3.close();\n      c4.close();\n      c5.close();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", \"./core1\", true, true);\n      createViaAdmin(cc, \"core2\", \"./core2\", true, false);\n      createViaAdmin(cc, \"core3\", \"./core3\", true, true);\n      createViaAdmin(cc, \"core4\", \"./core4\", true, false);\n      createViaAdmin(cc, \"core5\", \"./core5\", true, false);\n\n      SolrCore c1 = cc.getCore(\"core1\");\n      SolrCore c2 = cc.getCore(\"core2\");\n      SolrCore c3 = cc.getCore(\"core3\");\n      SolrCore c4 = cc.getCore(\"core4\");\n      SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collectionLazy2\", \"collectionLazy3\", \"collectionLazy4\", \"collectionLazy6\"\n          , \"collectionLazy7\", \"collectionLazy8\", \"collectionLazy9\");\n\n      checkInCores(cc, \"collection1\", \"collectionLazy5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      c1.close();\n      c2.close();\n      c3.close();\n      c4.close();\n      c5.close();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"625b61328a0889d9b3d61cdcbfc490339f61096e","date":1452790491,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to preceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      SolrCore c1 = cc.getCore(\"core1\");\n      SolrCore c2 = cc.getCore(\"core2\");\n      SolrCore c3 = cc.getCore(\"core3\");\n      SolrCore c4 = cc.getCore(\"core4\");\n      SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      c1.close();\n      c2.close();\n      c3.close();\n      c4.close();\n      c5.close();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":["8bc9f3cab5bcaa03021a8677cda720596f0da2f8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz KrasiÅ„ski","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to preceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to preceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to preceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7871f9c286dce2a9370bcf517a3e7d12e3bd9602","date":1498708934,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30c8e5574b55d57947e989443dfde611646530ee","date":1499131153,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, \"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\");\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad026d488f8fbf9ab33e5232d3343395c19b6cc8","date":1507308872,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n\n        @Override\n        public void run() {\n\n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \" + sleep_millis + \" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          } catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \" + ie + \" whilst sleeping for \" + sleep_millis + \" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      }\n      ;\n\n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n\n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"48e6317c36b128552eaed2363bb069267defb0e0","date":1507335877,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","pathOld":"solr/core/src/test/org/apache/solr/core/TestLazyCores#testCreateTransientFromAdmin().mjava","sourceNew":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n        \n        @Override\n        public void run() {\n          \n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \"+sleep_millis+\" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          }\n          catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \"+ie+\" whilst sleeping for \"+sleep_millis+\" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      };\n      \n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n      \n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","sourceOld":"  // Make sure that creating a transient core from the admin handler correctly respects the transient limits etc.\n  @Test\n  public void testCreateTransientFromAdmin() throws Exception {\n    final CoreContainer cc = init();\n    try {\n      copyMinConf(new File(solrHomeDirectory, \"core1\"));\n      copyMinConf(new File(solrHomeDirectory, \"core2\"));\n      copyMinConf(new File(solrHomeDirectory, \"core3\"));\n      copyMinConf(new File(solrHomeDirectory, \"core4\"));\n      copyMinConf(new File(solrHomeDirectory, \"core5\"));\n\n      createViaAdmin(cc, \"core1\", true, true);\n      createViaAdmin(cc, \"core2\", true, false);\n      createViaAdmin(cc, \"core3\", true, true);\n      createViaAdmin(cc, \"core4\", true, false);\n      createViaAdmin(cc, \"core5\", true, false);\n\n      final SolrCore c1 = cc.getCore(\"core1\");\n      final SolrCore c2 = cc.getCore(\"core2\");\n      final SolrCore c3 = cc.getCore(\"core3\");\n      final SolrCore c4 = cc.getCore(\"core4\");\n      final SolrCore c5 = cc.getCore(\"core5\");\n\n      checkNotInCores(cc, Arrays.asList(\"core1\", \"collection2\", \"collection3\", \"collection4\", \"collection6\"\n          , \"collection7\", \"collection8\", \"collection9\"));\n\n      checkInCores(cc, \"collection1\", \"collection5\", \"core2\", \"core3\", \"core4\", \"core5\");\n\n      // While we're at it, a test for SOLR-5366, unloading transient core that's been unloaded b/c it's\n      // transient generates a \"too many closes\" errorl\n\n      class TestThread extends Thread {\n\n        @Override\n        public void run() {\n\n          final int sleep_millis = random().nextInt(1000);\n          try {\n            if (sleep_millis > 0) {\n              if (VERBOSE) {\n                System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run sleeping for \" + sleep_millis + \" ms\");\n              }\n              Thread.sleep(sleep_millis);\n            }\n          } catch (InterruptedException ie) {\n            if (VERBOSE) {\n              System.out.println(\"TestLazyCores.testCreateTransientFromAdmin Thread.run caught \" + ie + \" whilst sleeping for \" + sleep_millis + \" ms\");\n            }\n          }\n\n          c1.close();\n          c2.close();\n          c3.close();\n          c4.close();\n          c5.close();\n        }\n      }\n      ;\n\n      // with SOLR-6279 UNLOAD will wait for the core's reference count to have reached zero\n      // hence cN.close() need to proceed or run in parallel with unloadViaAdmin(...)\n      final TestThread cThread = new TestThread();\n      cThread.start();\n\n      unloadViaAdmin(cc, \"core1\");\n      unloadViaAdmin(cc, \"core2\");\n      unloadViaAdmin(cc, \"core3\");\n      unloadViaAdmin(cc, \"core4\");\n      unloadViaAdmin(cc, \"core5\");\n\n      cThread.join();\n\n    } finally {\n      cc.shutdown();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7871f9c286dce2a9370bcf517a3e7d12e3bd9602":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"30c8e5574b55d57947e989443dfde611646530ee":["d470c8182e92b264680e34081b75e70a9f2b3c89","28288370235ed02234a64753cdbf0c6ec096304a"],"ad026d488f8fbf9ab33e5232d3343395c19b6cc8":["28288370235ed02234a64753cdbf0c6ec096304a"],"28288370235ed02234a64753cdbf0c6ec096304a":["d470c8182e92b264680e34081b75e70a9f2b3c89","7871f9c286dce2a9370bcf517a3e7d12e3bd9602"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["625b61328a0889d9b3d61cdcbfc490339f61096e","d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["625b61328a0889d9b3d61cdcbfc490339f61096e","0158ced21948b6626f733c1c42c1e18d94449789"],"11d8a050b7d5f98040f790d32ec1cfd2fc3490e3":["4bf7f9f53612fef6f228670ddd031bbdfaa1218b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4bf7f9f53612fef6f228670ddd031bbdfaa1218b":["8bc9f3cab5bcaa03021a8677cda720596f0da2f8"],"625b61328a0889d9b3d61cdcbfc490339f61096e":["11d8a050b7d5f98040f790d32ec1cfd2fc3490e3"],"8bc9f3cab5bcaa03021a8677cda720596f0da2f8":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["48e6317c36b128552eaed2363bb069267defb0e0"],"48e6317c36b128552eaed2363bb069267defb0e0":["ad026d488f8fbf9ab33e5232d3343395c19b6cc8"],"0158ced21948b6626f733c1c42c1e18d94449789":["625b61328a0889d9b3d61cdcbfc490339f61096e"]},"commit2Childs":{"7871f9c286dce2a9370bcf517a3e7d12e3bd9602":["28288370235ed02234a64753cdbf0c6ec096304a"],"30c8e5574b55d57947e989443dfde611646530ee":[],"ad026d488f8fbf9ab33e5232d3343395c19b6cc8":["48e6317c36b128552eaed2363bb069267defb0e0"],"28288370235ed02234a64753cdbf0c6ec096304a":["30c8e5574b55d57947e989443dfde611646530ee","ad026d488f8fbf9ab33e5232d3343395c19b6cc8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["7871f9c286dce2a9370bcf517a3e7d12e3bd9602","30c8e5574b55d57947e989443dfde611646530ee","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"11d8a050b7d5f98040f790d32ec1cfd2fc3490e3":["625b61328a0889d9b3d61cdcbfc490339f61096e"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["8bc9f3cab5bcaa03021a8677cda720596f0da2f8"],"4bf7f9f53612fef6f228670ddd031bbdfaa1218b":["11d8a050b7d5f98040f790d32ec1cfd2fc3490e3"],"625b61328a0889d9b3d61cdcbfc490339f61096e":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"8bc9f3cab5bcaa03021a8677cda720596f0da2f8":["4bf7f9f53612fef6f228670ddd031bbdfaa1218b"],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"48e6317c36b128552eaed2363bb069267defb0e0":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["30c8e5574b55d57947e989443dfde611646530ee","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}