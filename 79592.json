{"path":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int).mjava","commits":[{"id":"c6691cb6747f9e850337c706c06b92e9ddf816e1","date":1077044431,"type":0,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int).mjava","pathOld":"/dev/null","sourceNew":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.SCORE:  comparer = ScoreDocComparator.RELEVANCE; break;\n\t\t\tcase SortField.DOC:    comparer = ScoreDocComparator.INDEXORDER; break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"35c39157e8b6bc585e3a07e703d75db0f2ad56b2","date":1082672595,"type":5,"author":"Tim Jones","isMerge":false,"pathNew":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int,SortComparatorSource).mjava","pathOld":"src/java/org/apache/lucene/search/FieldSortedHitQueue#getCachedComparator(IndexReader,String,int).mjava","sourceNew":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type, final SortComparatorSource factory)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.SCORE:  comparer = ScoreDocComparator.RELEVANCE; break;\n\t\t\tcase SortField.DOC:    comparer = ScoreDocComparator.INDEXORDER; break;\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.CUSTOM: comparer = factory.newComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","sourceOld":"\t/**\n\t * Returns a comparator for the given field.  If there is already one in the cache, it is returned.\n\t * Otherwise one is created and put into the cache.  If <code>reader</code> is different than the\n\t * one used for the current cache, or has changed size, the cache is cleared first.\n\t * @param reader  Index to use.\n\t * @param field   Field to sort by.\n\t * @return  Comparator; never <code>null</code>.\n\t * @throws IOException  If an error occurs reading the index.\n\t * @see #determineComparator\n\t */\n\tstatic ScoreDocComparator getCachedComparator (final IndexReader reader, final String field, final int type)\n\tthrows IOException {\n\n\t\tif (type == SortField.DOC) return ScoreDocComparator.INDEXORDER;\n\t\tif (type == SortField.SCORE) return ScoreDocComparator.RELEVANCE;\n\n\t\t// see if we have already generated a comparator for this field\n\t\tif (reader.hashCode() == lastReaderHash) {\n\t\t\tScoreDocLookupComparator comparer = (ScoreDocLookupComparator) fieldCache.get (field);\n\t\t\tif (comparer != null && comparer.sizeMatches(reader.maxDoc())) {\n\t\t\t\treturn comparer;\n\t\t\t}\n\t\t} else {\n\t\t\tlastReaderHash = reader.hashCode();\n\t\t\tfieldCache.clear();\n\t\t}\n\n\t\tScoreDocComparator comparer = null;\n\t\tswitch (type) {\n\t\t\tcase SortField.SCORE:  comparer = ScoreDocComparator.RELEVANCE; break;\n\t\t\tcase SortField.DOC:    comparer = ScoreDocComparator.INDEXORDER; break;\n\t\t\tcase SortField.INT:    comparer = IntegerSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.FLOAT:  comparer = FloatSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.STRING: comparer = StringSortedHitQueue.comparator (reader, field); break;\n\t\t\tcase SortField.AUTO:   comparer = determineComparator (reader, field); break;\n\t\t\tdefault:\n\t\t\t\tthrow new RuntimeException (\"invalid sort field type: \"+type);\n\t\t}\n\n\t\t// store the comparator in the cache for reuse\n\t\tfieldCache.put (field, comparer);\n\n\t\treturn comparer;\n\t}\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c6691cb6747f9e850337c706c06b92e9ddf816e1":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"35c39157e8b6bc585e3a07e703d75db0f2ad56b2":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["35c39157e8b6bc585e3a07e703d75db0f2ad56b2"]},"commit2Childs":{"c6691cb6747f9e850337c706c06b92e9ddf816e1":["35c39157e8b6bc585e3a07e703d75db0f2ad56b2"],"35c39157e8b6bc585e3a07e703d75db0f2ad56b2":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c6691cb6747f9e850337c706c06b92e9ddf816e1"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}