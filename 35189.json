{"path":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","commits":[{"id":"22a2e66dfda83847e80095b8693c660742ab3e9c","date":1408628796,"type":1,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentReader#initDocValuesProducers(Codec).mjava","sourceNew":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    Version ver = si.info.getVersion();\n    if (ver != null && ver.onOrAfter(Version.LUCENE_4_9_0)) {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    } else {\n      // For pre-4.9 indexes, especially with doc-values updates, multiple\n      // FieldInfos could belong to the same dvGen. Therefore need to make sure\n      // we initialize each DocValuesProducer once per gen.\n      Map<Long,List<FieldInfo>> genInfos = new HashMap<>();\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        List<FieldInfo> genFieldInfos = genInfos.get(fi.getDocValuesGen());\n        if (genFieldInfos == null) {\n          genFieldInfos = new ArrayList<>();\n          genInfos.put(fi.getDocValuesGen(), genFieldInfos);\n        }\n        genFieldInfos.add(fi);\n      }\n      \n      for (Map.Entry<Long,List<FieldInfo>> e : genInfos.entrySet()) {\n        long docValuesGen = e.getKey();\n        List<FieldInfo> infos = e.getValue();\n        final DocValuesProducer dvp;\n        if (docValuesGen == -1) {\n          // we need to send all FieldInfos to gen=-1, but later we need to\n          // record the DVP only for the \"true\" gen=-1 fields (not updated)\n          dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n        } else {\n          dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(infos.toArray(new FieldInfo[infos.size()])));\n        }\n        dvGens.add(docValuesGen);\n        dvProducers.add(dvp);\n        for (FieldInfo fi : infos) {\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  // initialize the per-field DocValuesProducer\n  @SuppressWarnings(\"deprecation\")\n  private void initDocValuesProducers(Codec codec) throws IOException {\n    final Directory dir = core.cfsReader != null ? core.cfsReader : si.info.dir;\n    final DocValuesFormat dvFormat = codec.docValuesFormat();\n\n    if (!si.hasFieldUpdates()) {\n      // simple case, no DocValues updates\n      final DocValuesProducer dvp = segDocValues.getDocValuesProducer(-1L, si, IOContext.READ, dir, dvFormat, fieldInfos);\n      dvGens.add(-1L);\n      dvProducers.add(dvp);\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        assert fi.getDocValuesGen() == -1;\n        dvProducersByField.put(fi.name, dvp);\n      }\n      return;\n    }\n\n    Version ver = si.info.getVersion();\n    if (ver != null && ver.onOrAfter(Version.LUCENE_4_9_0)) {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n//        System.out.println(\"[\" + Thread.currentThread().getName() + \"] SR.initDocValuesProducers: segInfo=\" + si + \"; gen=\" + docValuesGen + \"; field=\" + fi.name);\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n//        System.out.println(\"[\" + Thread.currentThread().getName() + \"] SR.initDocValuesProducers: segInfo=\" + si + \"; gen=\" + docValuesGen + \"; field=\" + fi.name);\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n//        System.out.println(\"[\" + Thread.currentThread().getName() + \"] SR.initDocValuesProducers: segInfo=\" + si + \"; gen=\" + docValuesGen + \"; field=\" + fi.name);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    } else {\n      // For pre-4.9 indexes, especially with doc-values updates, multiple\n      // FieldInfos could belong to the same dvGen. Therefore need to make sure\n      // we initialize each DocValuesProducer once per gen.\n      Map<Long,List<FieldInfo>> genInfos = new HashMap<>();\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        List<FieldInfo> genFieldInfos = genInfos.get(fi.getDocValuesGen());\n        if (genFieldInfos == null) {\n          genFieldInfos = new ArrayList<>();\n          genInfos.put(fi.getDocValuesGen(), genFieldInfos);\n        }\n        genFieldInfos.add(fi);\n      }\n      \n      for (Map.Entry<Long,List<FieldInfo>> e : genInfos.entrySet()) {\n        long docValuesGen = e.getKey();\n        List<FieldInfo> infos = e.getValue();\n        final DocValuesProducer dvp;\n        if (docValuesGen == -1) {\n          // we need to send all FieldInfos to gen=-1, but later we need to\n          // record the DVP only for the \"true\" gen=-1 fields (not updated)\n          dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n        } else {\n          dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(infos.toArray(new FieldInfo[infos.size()])));\n        }\n        dvGens.add(docValuesGen);\n        dvProducers.add(dvp);\n        for (FieldInfo fi : infos) {\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23d7b31d77deb1b1da7cdcc84bcfeafc3f9ab5cb","date":1408659301,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","sourceNew":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      Version ver = si.info.getVersion();\n      if (ver != null && ver.onOrAfter(Version.LUCENE_4_9_0)) {\n        DocValuesProducer baseProducer = null;\n        for (FieldInfo fi : fieldInfos) {\n          if (!fi.hasDocValues()) {\n            continue;\n          }\n          long docValuesGen = fi.getDocValuesGen();\n          if (docValuesGen == -1) {\n            if (baseProducer == null) {\n              // the base producer gets all the fields, so the Codec can validate properly\n              baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n              dvGens.add(docValuesGen);\n              dvProducers.add(baseProducer);\n            }\n            dvProducersByField.put(fi.name, baseProducer);\n          } else {\n            assert !dvGens.contains(docValuesGen);\n            final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n            dvGens.add(docValuesGen);\n            dvProducers.add(dvp);\n            dvProducersByField.put(fi.name, dvp);\n          }\n        }\n      } else {\n        // For pre-4.9 indexes, especially with doc-values updates, multiple\n        // FieldInfos could belong to the same dvGen. Therefore need to make sure\n        // we initialize each DocValuesProducer once per gen.\n        Map<Long,List<FieldInfo>> genInfos = new HashMap<>();\n        for (FieldInfo fi : fieldInfos) {\n          if (!fi.hasDocValues()) {\n            continue;\n          }\n          List<FieldInfo> genFieldInfos = genInfos.get(fi.getDocValuesGen());\n          if (genFieldInfos == null) {\n            genFieldInfos = new ArrayList<>();\n            genInfos.put(fi.getDocValuesGen(), genFieldInfos);\n          }\n          genFieldInfos.add(fi);\n        }\n      \n        for (Map.Entry<Long,List<FieldInfo>> e : genInfos.entrySet()) {\n          long docValuesGen = e.getKey();\n          List<FieldInfo> infos = e.getValue();\n          final DocValuesProducer dvp;\n          if (docValuesGen == -1) {\n            // we need to send all FieldInfos to gen=-1, but later we need to\n            // record the DVP only for the \"true\" gen=-1 fields (not updated)\n            dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n          } else {\n            dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(infos.toArray(new FieldInfo[infos.size()])));\n          }\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          for (FieldInfo fi : infos) {\n            dvProducersByField.put(fi.name, dvp);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    Version ver = si.info.getVersion();\n    if (ver != null && ver.onOrAfter(Version.LUCENE_4_9_0)) {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    } else {\n      // For pre-4.9 indexes, especially with doc-values updates, multiple\n      // FieldInfos could belong to the same dvGen. Therefore need to make sure\n      // we initialize each DocValuesProducer once per gen.\n      Map<Long,List<FieldInfo>> genInfos = new HashMap<>();\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) continue;\n        List<FieldInfo> genFieldInfos = genInfos.get(fi.getDocValuesGen());\n        if (genFieldInfos == null) {\n          genFieldInfos = new ArrayList<>();\n          genInfos.put(fi.getDocValuesGen(), genFieldInfos);\n        }\n        genFieldInfos.add(fi);\n      }\n      \n      for (Map.Entry<Long,List<FieldInfo>> e : genInfos.entrySet()) {\n        long docValuesGen = e.getKey();\n        List<FieldInfo> infos = e.getValue();\n        final DocValuesProducer dvp;\n        if (docValuesGen == -1) {\n          // we need to send all FieldInfos to gen=-1, but later we need to\n          // record the DVP only for the \"true\" gen=-1 fields (not updated)\n          dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n        } else {\n          dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(infos.toArray(new FieldInfo[infos.size()])));\n        }\n        dvGens.add(docValuesGen);\n        dvProducers.add(dvp);\n        for (FieldInfo fi : infos) {\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71387d8cb6923eb831b17a8b734608ba2e21c653","date":1414126093,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","sourceNew":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      Version ver = si.info.getVersion();\n      if (ver != null && ver.onOrAfter(Version.LUCENE_4_9_0)) {\n        DocValuesProducer baseProducer = null;\n        for (FieldInfo fi : fieldInfos) {\n          if (!fi.hasDocValues()) {\n            continue;\n          }\n          long docValuesGen = fi.getDocValuesGen();\n          if (docValuesGen == -1) {\n            if (baseProducer == null) {\n              // the base producer gets all the fields, so the Codec can validate properly\n              baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n              dvGens.add(docValuesGen);\n              dvProducers.add(baseProducer);\n            }\n            dvProducersByField.put(fi.name, baseProducer);\n          } else {\n            assert !dvGens.contains(docValuesGen);\n            final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n            dvGens.add(docValuesGen);\n            dvProducers.add(dvp);\n            dvProducersByField.put(fi.name, dvp);\n          }\n        }\n      } else {\n        // For pre-4.9 indexes, especially with doc-values updates, multiple\n        // FieldInfos could belong to the same dvGen. Therefore need to make sure\n        // we initialize each DocValuesProducer once per gen.\n        Map<Long,List<FieldInfo>> genInfos = new HashMap<>();\n        for (FieldInfo fi : fieldInfos) {\n          if (!fi.hasDocValues()) {\n            continue;\n          }\n          List<FieldInfo> genFieldInfos = genInfos.get(fi.getDocValuesGen());\n          if (genFieldInfos == null) {\n            genFieldInfos = new ArrayList<>();\n            genInfos.put(fi.getDocValuesGen(), genFieldInfos);\n          }\n          genFieldInfos.add(fi);\n        }\n      \n        for (Map.Entry<Long,List<FieldInfo>> e : genInfos.entrySet()) {\n          long docValuesGen = e.getKey();\n          List<FieldInfo> infos = e.getValue();\n          final DocValuesProducer dvp;\n          if (docValuesGen == -1) {\n            // we need to send all FieldInfos to gen=-1, but later we need to\n            // record the DVP only for the \"true\" gen=-1 fields (not updated)\n            dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n          } else {\n            dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(infos.toArray(new FieldInfo[infos.size()])));\n          }\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          for (FieldInfo fi : infos) {\n            dvProducersByField.put(fi.name, dvp);\n          }\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"556a4aab886d75371b2af129d87be3c2795cea76","date":1414954991,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","sourceNew":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (!fi.hasDocValues()) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"240c2c222c1b7eb253bd7e596c2d4731355836ef","date":1416366514,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,FieldInfos,SegmentDocValues).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/SegmentDocValuesProducer#SegmentDocValuesProducer(SegmentCommitInfo,Directory,FieldInfos,SegmentDocValues,DocValuesFormat).mjava","sourceNew":"  /**\n   * Creates a new producer that handles updated docvalues fields\n   * @param si commit point\n   * @param dir directory\n   * @param coreInfos fieldinfos for the segment\n   * @param allInfos all fieldinfos including updated ones\n   * @param segDocValues producer map\n   */\n  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos coreInfos, FieldInfos allInfos, SegmentDocValues segDocValues) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : allInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets the original fieldinfos it wrote\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, dir, coreInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          // otherwise, producer sees only the one fieldinfo it wrote\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, dir, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","sourceOld":"  SegmentDocValuesProducer(SegmentCommitInfo si, Directory dir, FieldInfos fieldInfos, SegmentDocValues segDocValues, DocValuesFormat dvFormat) throws IOException {\n    boolean success = false;\n    try {\n      DocValuesProducer baseProducer = null;\n      for (FieldInfo fi : fieldInfos) {\n        if (fi.getDocValuesType() == DocValuesType.NONE) {\n          continue;\n        }\n        long docValuesGen = fi.getDocValuesGen();\n        if (docValuesGen == -1) {\n          if (baseProducer == null) {\n            // the base producer gets all the fields, so the Codec can validate properly\n            baseProducer = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, fieldInfos);\n            dvGens.add(docValuesGen);\n            dvProducers.add(baseProducer);\n          }\n          dvProducersByField.put(fi.name, baseProducer);\n        } else {\n          assert !dvGens.contains(docValuesGen);\n          final DocValuesProducer dvp = segDocValues.getDocValuesProducer(docValuesGen, si, IOContext.READ, dir, dvFormat, new FieldInfos(new FieldInfo[] { fi }));\n          dvGens.add(docValuesGen);\n          dvProducers.add(dvp);\n          dvProducersByField.put(fi.name, dvp);\n        }\n      }\n      success = true;\n    } finally {\n      if (success == false) {\n        try {\n          segDocValues.decRef(dvGens);\n        } catch (Throwable t) {\n          // Ignore so we keep throwing first exception\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22a2e66dfda83847e80095b8693c660742ab3e9c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"240c2c222c1b7eb253bd7e596c2d4731355836ef":["556a4aab886d75371b2af129d87be3c2795cea76"],"556a4aab886d75371b2af129d87be3c2795cea76":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["23d7b31d77deb1b1da7cdcc84bcfeafc3f9ab5cb"],"23d7b31d77deb1b1da7cdcc84bcfeafc3f9ab5cb":["22a2e66dfda83847e80095b8693c660742ab3e9c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["240c2c222c1b7eb253bd7e596c2d4731355836ef"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["22a2e66dfda83847e80095b8693c660742ab3e9c"],"22a2e66dfda83847e80095b8693c660742ab3e9c":["23d7b31d77deb1b1da7cdcc84bcfeafc3f9ab5cb"],"240c2c222c1b7eb253bd7e596c2d4731355836ef":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"556a4aab886d75371b2af129d87be3c2795cea76":["240c2c222c1b7eb253bd7e596c2d4731355836ef"],"71387d8cb6923eb831b17a8b734608ba2e21c653":["556a4aab886d75371b2af129d87be3c2795cea76"],"23d7b31d77deb1b1da7cdcc84bcfeafc3f9ab5cb":["71387d8cb6923eb831b17a8b734608ba2e21c653"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}