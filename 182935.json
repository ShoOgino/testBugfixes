{"path":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","commits":[{"id":"91109046a59c58ee0ee5d0d2767b08d1f30d6702","date":1000830588,"type":0,"author":"Jason van Zyl","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"/dev/null","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException, SecurityException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % INDEX_INTERVAL == 0)\n      other.add(lastTerm, lastTi);\t\t  // add an index term\n\n    writeTerm(term);\t\t\t\t  // write term\n    output.writeVInt(ti.docFreq);\t\t  // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"03ae70812bc33b0270c1366378b2c2da95fe86a6","date":1036648540,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % INDEX_INTERVAL == 0)\n      other.add(lastTerm, lastTi);\t\t  // add an index term\n\n    writeTerm(term);\t\t\t\t  // write term\n    output.writeVInt(ti.docFreq);\t\t  // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException, SecurityException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % INDEX_INTERVAL == 0)\n      other.add(lastTerm, lastTi);\t\t  // add an index term\n\n    writeTerm(term);\t\t\t\t  // write term\n    output.writeVInt(ti.docFreq);\t\t  // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"15c469602973ef1a33c9a07367a380d278ffab20","date":1074206555,"type":3,"author":"Doug Cutting","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);\t\t  // add an index term\n\n    writeTerm(term);\t\t\t\t  // write term\n    output.writeVInt(ti.docFreq);\t\t  // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (!isIndex) {\n      if (ti.docFreq > skipInterval) {\n        output.writeVInt(ti.skipOffset);\n      }\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % INDEX_INTERVAL == 0)\n      other.add(lastTerm, lastTi);\t\t  // add an index term\n\n    writeTerm(term);\t\t\t\t  // write term\n    output.writeVInt(ti.docFreq);\t\t  // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"23b8dd5490763d8f75b016adcb74ba1c2baa5227","date":1080222589,"type":3,"author":"Otis Gospodnetic","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (!isIndex) {\n      if (ti.docFreq > skipInterval) {\n        output.writeVInt(ti.skipOffset);\n      }\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);\t\t  // add an index term\n\n    writeTerm(term);\t\t\t\t  // write term\n    output.writeVInt(ti.docFreq);\t\t  // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (!isIndex) {\n      if (ti.docFreq > skipInterval) {\n        output.writeVInt(ti.skipOffset);\n      }\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f5cf8ed8dfc080044944e2cabac618bc36199013","date":1082468878,"type":3,"author":"Christoph Goller","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (ti.docFreq >= skipInterval) {\n      output.writeVInt(ti.skipOffset);\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (!isIndex) {\n      if (ti.docFreq > skipInterval) {\n        output.writeVInt(ti.skipOffset);\n      }\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fd205ba0d3dbba4ae2679d527c2c864d6a8293b8","date":1147467840,"type":3,"author":"Daniel Naber","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order (\\\"\" + term + \n          \"\\\".compareTo(\\\"\" + lastTerm + \"\\\") <= 0)\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order (\" + ti.freqPointer +\n          \" < \" + lastTi.freqPointer + \")\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order (\" + ti.proxPointer + \n          \" < \" + lastTi.proxPointer + \")\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (ti.docFreq >= skipInterval) {\n      output.writeVInt(ti.skipOffset);\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (ti.docFreq >= skipInterval) {\n      output.writeVInt(ti.skipOffset);\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":null,"bugIntro":["1b54a9bc667895a2095a886184bf69a3179e63df"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b54a9bc667895a2095a886184bf69a3179e63df","date":1172088096,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws CorruptIndexException, IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new CorruptIndexException(\"term out of order (\\\"\" + term + \n          \"\\\".compareTo(\\\"\" + lastTerm + \"\\\") <= 0)\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new CorruptIndexException(\"freqPointer out of order (\" + ti.freqPointer +\n          \" < \" + lastTi.freqPointer + \")\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new CorruptIndexException(\"proxPointer out of order (\" + ti.proxPointer + \n          \" < \" + lastTi.proxPointer + \")\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (ti.docFreq >= skipInterval) {\n      output.writeVInt(ti.skipOffset);\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new IOException(\"term out of order (\\\"\" + term + \n          \"\\\".compareTo(\\\"\" + lastTerm + \"\\\") <= 0)\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new IOException(\"freqPointer out of order (\" + ti.freqPointer +\n          \" < \" + lastTi.freqPointer + \")\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new IOException(\"proxPointer out of order (\" + ti.proxPointer + \n          \" < \" + lastTi.proxPointer + \")\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (ti.docFreq >= skipInterval) {\n      output.writeVInt(ti.skipOffset);\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":["03ae70812bc33b0270c1366378b2c2da95fe86a6","fd205ba0d3dbba4ae2679d527c2c864d6a8293b8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c1f822dcb4624ad203d96e63bcb23b498e1bd0a","date":1199647785,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  void add(Term term, TermInfo ti) throws IOException {\n\n    final int length = term.text.length();\n    if (termTextBuffer.length < length)\n      termTextBuffer = new char[(int) (length*1.25)];\n\n    term.text.getChars(0, length, termTextBuffer, 0);\n\n    add(fieldInfos.fieldNumber(term.field), termTextBuffer, 0, length, ti);\n  }\n\n","sourceOld":"  /** Adds a new <Term, TermInfo> pair to the set.\n    Term must be lexicographically greater than all previous Terms added.\n    TermInfo pointers must be positive and greater than all previous.*/\n  final void add(Term term, TermInfo ti)\n       throws CorruptIndexException, IOException {\n    if (!isIndex && term.compareTo(lastTerm) <= 0)\n      throw new CorruptIndexException(\"term out of order (\\\"\" + term + \n          \"\\\".compareTo(\\\"\" + lastTerm + \"\\\") <= 0)\");\n    if (ti.freqPointer < lastTi.freqPointer)\n      throw new CorruptIndexException(\"freqPointer out of order (\" + ti.freqPointer +\n          \" < \" + lastTi.freqPointer + \")\");\n    if (ti.proxPointer < lastTi.proxPointer)\n      throw new CorruptIndexException(\"proxPointer out of order (\" + ti.proxPointer + \n          \" < \" + lastTi.proxPointer + \")\");\n\n    if (!isIndex && size % indexInterval == 0)\n      other.add(lastTerm, lastTi);                      // add an index term\n\n    writeTerm(term);                                    // write term\n    output.writeVInt(ti.docFreq);                       // write doc freq\n    output.writeVLong(ti.freqPointer - lastTi.freqPointer); // write pointers\n    output.writeVLong(ti.proxPointer - lastTi.proxPointer);\n\n    if (ti.docFreq >= skipInterval) {\n      output.writeVInt(ti.skipOffset);\n    }\n\n    if (isIndex) {\n      output.writeVLong(other.output.getFilePointer() - lastIndexPointer);\n      lastIndexPointer = other.output.getFilePointer(); // write pointer\n    }\n\n    lastTi.set(ti);\n    size++;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4","date":1206538765,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  void add(Term term, TermInfo ti) throws IOException {\n    UnicodeUtil.UTF16toUTF8(term.text, 0, term.text.length(), utf8Result);\n    add(fieldInfos.fieldNumber(term.field), utf8Result.result, utf8Result.length, ti);\n  }\n\n","sourceOld":"  void add(Term term, TermInfo ti) throws IOException {\n\n    final int length = term.text.length();\n    if (termTextBuffer.length < length)\n      termTextBuffer = new char[(int) (length*1.25)];\n\n    term.text.getChars(0, length, termTextBuffer, 0);\n\n    add(fieldInfos.fieldNumber(term.field), termTextBuffer, 0, length, ti);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","pathOld":"src/java/org/apache/lucene/index/TermInfosWriter#add(Term,TermInfo).mjava","sourceNew":"  void add(Term term, TermInfo ti) throws IOException {\n    UnicodeUtil.UTF16toUTF8(term.text, 0, term.text.length(), utf8Result);\n    add(fieldInfos.fieldNumber(term.field), utf8Result.result, utf8Result.length, ti);\n  }\n\n","sourceOld":"  void add(Term term, TermInfo ti) throws IOException {\n    UnicodeUtil.UTF16toUTF8(term.text, 0, term.text.length(), utf8Result);\n    add(fieldInfos.fieldNumber(term.field), utf8Result.result, utf8Result.length, ti);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7c1f822dcb4624ad203d96e63bcb23b498e1bd0a":["1b54a9bc667895a2095a886184bf69a3179e63df"],"1b54a9bc667895a2095a886184bf69a3179e63df":["fd205ba0d3dbba4ae2679d527c2c864d6a8293b8"],"fd205ba0d3dbba4ae2679d527c2c864d6a8293b8":["f5cf8ed8dfc080044944e2cabac618bc36199013"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4":["7c1f822dcb4624ad203d96e63bcb23b498e1bd0a"],"23b8dd5490763d8f75b016adcb74ba1c2baa5227":["15c469602973ef1a33c9a07367a380d278ffab20"],"f5cf8ed8dfc080044944e2cabac618bc36199013":["23b8dd5490763d8f75b016adcb74ba1c2baa5227"],"03ae70812bc33b0270c1366378b2c2da95fe86a6":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4"],"15c469602973ef1a33c9a07367a380d278ffab20":["03ae70812bc33b0270c1366378b2c2da95fe86a6"]},"commit2Childs":{"91109046a59c58ee0ee5d0d2767b08d1f30d6702":["03ae70812bc33b0270c1366378b2c2da95fe86a6"],"7c1f822dcb4624ad203d96e63bcb23b498e1bd0a":["dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4"],"1b54a9bc667895a2095a886184bf69a3179e63df":["7c1f822dcb4624ad203d96e63bcb23b498e1bd0a"],"fd205ba0d3dbba4ae2679d527c2c864d6a8293b8":["1b54a9bc667895a2095a886184bf69a3179e63df"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["91109046a59c58ee0ee5d0d2767b08d1f30d6702"],"dbb7b6f10bff9eedd5c9bc6cf9222ffbb2df74d4":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"23b8dd5490763d8f75b016adcb74ba1c2baa5227":["f5cf8ed8dfc080044944e2cabac618bc36199013"],"f5cf8ed8dfc080044944e2cabac618bc36199013":["fd205ba0d3dbba4ae2679d527c2c864d6a8293b8"],"03ae70812bc33b0270c1366378b2c2da95fe86a6":["15c469602973ef1a33c9a07367a380d278ffab20"],"15c469602973ef1a33c9a07367a380d278ffab20":["23b8dd5490763d8f75b016adcb74ba1c2baa5227"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9454a6510e2db155fb01faa5c049b06ece95fab9":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}