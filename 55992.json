{"path":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","commits":[{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min != null && min.length == 0 && minInclusive == true) {\n      // Silly empty string corner case:\n      min = null;\n    }\n\n    if (min == null) {\n      if (max == null) {\n        // Accepts all terms:\n        return makeAnyBinary();\n      }\n      min = new BytesRef();\n      minInclusive = true;\n    }\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n    }\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min != null && min.length == 0 && minInclusive == true) {\n      // Silly empty string corner case:\n      min = null;\n    }\n\n    if (min == null) {\n      if (max == null) {\n        // Accepts all terms:\n        return makeAnyBinary();\n      }\n      min = new BytesRef();\n      minInclusive = true;\n    }\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n    }\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b84dfbbd8247c0cc3aaaa5a56dbdf7ea3bfe2624","date":1428311015,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","sourceNew":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min == null) {\n      min = new BytesRef();\n      minInclusive = true;\n    }\n\n    // Empty string corner case:\n    if (max != null && maxInclusive == false && max.length == 1 && max.bytes[max.offset] == 0) {\n      max = new BytesRef();\n      maxInclusive = true;\n    }\n\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n      if (min.length == 0 && minInclusive) {\n        return makeAnyBinary();\n      }\n    }\n\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","sourceOld":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min != null && min.length == 0 && minInclusive == true) {\n      // Silly empty string corner case:\n      min = null;\n    }\n\n    if (min == null) {\n      if (max == null) {\n        // Accepts all terms:\n        return makeAnyBinary();\n      }\n      min = new BytesRef();\n      minInclusive = true;\n    }\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n    }\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f29e599388a71a6e72ae2b7156b50e7570a9ac8a","date":1428569163,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","sourceNew":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min == null) {\n      min = new BytesRef();\n      minInclusive = true;\n    }\n\n    // Empty string corner cases:\n    if (max != null && maxInclusive == false && max.length == 1 && max.bytes[max.offset] == 0) {\n      max = new BytesRef();\n      maxInclusive = true;\n    }\n\n    if (min != null && minInclusive == false && min.length == 0) {\n      min = new BytesRef(new byte[1]);\n      minInclusive = true;\n    }\n\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n      if (min.length == 0 && minInclusive) {\n        return makeAnyBinary();\n      }\n    }\n\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","sourceOld":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min == null) {\n      min = new BytesRef();\n      minInclusive = true;\n    }\n\n    // Empty string corner case:\n    if (max != null && maxInclusive == false && max.length == 1 && max.bytes[max.offset] == 0) {\n      max = new BytesRef();\n      maxInclusive = true;\n    }\n\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n      if (min.length == 0 && minInclusive) {\n        return makeAnyBinary();\n      }\n    }\n\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6652cc2bf75afdcb0c22e7b20d7708f365d20416","date":1428845341,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/automaton/Automata#makeBinaryInterval(BytesRef,boolean,BytesRef,boolean).mjava","sourceNew":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min == null) {\n      min = new BytesRef();\n      minInclusive = true;\n    }\n\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n      if (min.length == 0 && minInclusive) {\n        return makeAnyBinary();\n      }\n    }\n\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    if (max != null &&\n        StringHelper.startsWith(max, min) &&\n        suffixIsZeros(max, min.length)) {\n\n      // Finite case: no sink state!\n\n      int maxLength = max.length;\n\n      // the == case was handled above\n      assert maxLength > min.length;\n\n      //  bar -> bar\\0+\n      if (maxInclusive == false) {\n        maxLength--;\n      }\n\n      if (maxLength == min.length) {\n        if (minInclusive == false) {\n          return makeEmpty();\n        } else {\n          return makeBinary(min);\n        }\n      }\n\n      Automaton a = new Automaton();\n      int lastState = a.createState();\n      for (int i=0;i<min.length;i++) {\n        int state = a.createState();\n        int label = min.bytes[min.offset+i] & 0xff;\n        a.addTransition(lastState, state, label);\n        lastState = state;\n      }\n\n      if (minInclusive) {\n        a.setAccept(lastState, true);\n      }\n\n      for(int i=min.length;i<maxLength;i++) {\n        int state = a.createState();\n        a.addTransition(lastState, state, 0);\n        a.setAccept(state, true);\n        lastState = state;\n      }\n      a.finishState();\n      return a;\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","sourceOld":"  /** Creates a new deterministic, minimal automaton accepting\n   *  all binary terms in the specified interval.  Note that unlike\n   *  {@link #makeDecimalInterval}, the returned automaton is infinite,\n   *  because terms behave like floating point numbers leading with\n   *  a decimal point.  However, in the special case where min == max,\n   *  and both are inclusive, the automata will be finite and accept\n   *  exactly one term. */\n  public static Automaton makeBinaryInterval(BytesRef min, boolean minInclusive, BytesRef max, boolean maxInclusive) {\n\n    if (min == null && minInclusive == false) {\n      throw new IllegalArgumentException(\"minInclusive must be true when min is null (open ended)\");\n    }\n\n    if (max == null && maxInclusive == false) {\n      throw new IllegalArgumentException(\"maxInclusive must be true when max is null (open ended)\");\n    }\n\n    if (min == null) {\n      min = new BytesRef();\n      minInclusive = true;\n    }\n\n    // Empty string corner cases:\n    if (max != null && maxInclusive == false && max.length == 1 && max.bytes[max.offset] == 0) {\n      max = new BytesRef();\n      maxInclusive = true;\n    }\n\n    if (min != null && minInclusive == false && min.length == 0) {\n      min = new BytesRef(new byte[1]);\n      minInclusive = true;\n    }\n\n    int cmp;\n    if (max != null) {\n      cmp = min.compareTo(max);\n    } else {\n      cmp = -1;\n      if (min.length == 0 && minInclusive) {\n        return makeAnyBinary();\n      }\n    }\n\n    if (cmp == 0) {\n      if (minInclusive == false || maxInclusive == false) {\n        return makeEmpty();\n      } else {\n        return makeBinary(min);\n      }\n    } else if (cmp > 0) {\n      // max > min\n      return makeEmpty();\n    }\n\n    Automaton a = new Automaton();\n    int startState = a.createState();\n    int sinkState = a.createState();\n    a.setAccept(sinkState, true);\n\n    // This state accepts all suffixes:\n    a.addTransition(sinkState, sinkState, 0, 255);\n\n    boolean equalPrefix = true;\n    int lastState = startState;\n    int firstMaxState = -1;\n    int sharedPrefixLength = 0;\n    for(int i=0;i<min.length;i++) {\n      int minLabel = min.bytes[min.offset+i] & 0xff;\n\n      int maxLabel;\n      if (max != null && equalPrefix && i < max.length) {\n        maxLabel = max.bytes[max.offset+i] & 0xff;\n      } else {\n        maxLabel = -1;\n      }\n\n      int nextState;\n      if (minInclusive && i == min.length-1 && (equalPrefix == false || minLabel != maxLabel)) {\n        nextState = sinkState;\n      } else {\n        nextState = a.createState();\n      }\n\n      if (equalPrefix) {\n\n        if (minLabel == maxLabel) {\n          // Still in shared prefix\n          a.addTransition(lastState, nextState, minLabel);\n        } else if (max == null) {\n          equalPrefix = false;\n          sharedPrefixLength = 0;\n          a.addTransition(lastState, sinkState, minLabel+1, 0xff);\n          a.addTransition(lastState, nextState, minLabel);\n        } else {\n          // This is the first point where min & max diverge:\n          assert maxLabel > minLabel;\n\n          a.addTransition(lastState, nextState, minLabel);\n\n          if (maxLabel > minLabel + 1) {\n            a.addTransition(lastState, sinkState, minLabel+1, maxLabel-1);\n          }\n\n          // Now fork off path for max:\n          if (maxInclusive || i < max.length-1) {\n            firstMaxState = a.createState();\n            if (i < max.length-1) {\n              a.setAccept(firstMaxState, true);\n            }\n            a.addTransition(lastState, firstMaxState, maxLabel);\n          }\n          equalPrefix = false;\n          sharedPrefixLength = i;\n        }\n      } else {\n        // OK, already diverged:\n        a.addTransition(lastState, nextState, minLabel);\n        if (minLabel < 255) {\n          a.addTransition(lastState, sinkState, minLabel+1, 255);\n        }\n      }\n      lastState = nextState;\n    }\n\n    // Accept any suffix appended to the min term:\n    if (equalPrefix == false && lastState != sinkState && lastState != startState) {\n      a.addTransition(lastState, sinkState, 0, 255);\n    }\n\n    if (minInclusive) {\n      // Accept exactly the min term:\n      a.setAccept(lastState, true);\n    }\n\n    if (max != null) {\n\n      // Now do max:\n      if (firstMaxState == -1) {\n        // Min was a full prefix of max\n        sharedPrefixLength = min.length;\n      } else {\n        lastState = firstMaxState;\n        sharedPrefixLength++;\n      }\n      for(int i=sharedPrefixLength;i<max.length;i++) {\n        int maxLabel = max.bytes[max.offset+i]&0xff;\n        if (maxLabel > 0) {\n          a.addTransition(lastState, sinkState, 0, maxLabel-1);\n        }\n        if (maxInclusive || i < max.length-1) {\n          int nextState = a.createState();\n          if (i < max.length-1) {\n            a.setAccept(nextState, true);\n          }\n          a.addTransition(lastState, nextState, maxLabel);\n          lastState = nextState;\n        }\n      }\n\n      if (maxInclusive) {\n        a.setAccept(lastState, true);\n      }\n    }\n\n    a.finishState();\n\n    assert a.isDeterministic(): a.toDot();\n\n    return a;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3e8715d826e588419327562287d5d6a8040d63d6"],"6652cc2bf75afdcb0c22e7b20d7708f365d20416":["f29e599388a71a6e72ae2b7156b50e7570a9ac8a"],"f29e599388a71a6e72ae2b7156b50e7570a9ac8a":["b84dfbbd8247c0cc3aaaa5a56dbdf7ea3bfe2624"],"3e8715d826e588419327562287d5d6a8040d63d6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["6652cc2bf75afdcb0c22e7b20d7708f365d20416"],"b84dfbbd8247c0cc3aaaa5a56dbdf7ea3bfe2624":["3e8715d826e588419327562287d5d6a8040d63d6"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"6652cc2bf75afdcb0c22e7b20d7708f365d20416":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f29e599388a71a6e72ae2b7156b50e7570a9ac8a":["6652cc2bf75afdcb0c22e7b20d7708f365d20416"],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","b84dfbbd8247c0cc3aaaa5a56dbdf7ea3bfe2624"],"b84dfbbd8247c0cc3aaaa5a56dbdf7ea3bfe2624":["f29e599388a71a6e72ae2b7156b50e7570a9ac8a"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}