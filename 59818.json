{"path":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","commits":[{"id":"b1777912fb613f51063554d81f71c1b70d6bcd77","date":1470897768,"type":0,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public Object call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"going to create replica {}\", Utils.toJSONString(sourceReplica));\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              log.warn(\"failed to create : \" + Utils.toJSONString(msg));\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", \"Could not create copy of replica \" + Utils.toJSONString(sourceReplica));\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.info(\"successfully created : \" + Utils.toJSONString(msg));\n\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.info(\"Waiting for creates to complete \");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.info(\"Waiting over for creates to complete \");\n\n    if (anyOneFailed.get()) {\n      log.info(\"failed to create some cores delete all \" + Utils.toJSONString(createdReplicas));\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"could not cleanup, because  : \" + deleteResult.get(\"failure\") + \"  \" + Utils.toJSONString(createdReplica));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.info(\"Error deleting \", e);\n        } catch (Exception e) {\n          log.error(\"Unknown Error deleteing\", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return null;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh);\n    results.add(\"success\", \"REPLACENODE completed successfully from  : \" + source + \" to : \" + target);\n    return null;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9fac11578d87e86ac41841e07ba8db185cedf92c","date":1471085468,"type":3,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public Object call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"going to create replica {}\", Utils.toJSONString(sourceReplica));\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              log.warn(\"failed to create : \" + Utils.toJSONString(msg));\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", \"Could not create copy of replica \" + Utils.toJSONString(sourceReplica));\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.info(\"successfully created : \" + Utils.toJSONString(msg));\n\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.info(\"Waiting for creates to complete \");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.info(\"Waiting over for creates to complete \");\n\n    if (anyOneFailed.get()) {\n      log.info(\"failed to create some cores delete all \" + Utils.toJSONString(createdReplicas));\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"could not cleanup, because  : \" + deleteResult.get(\"failure\") + \"  \" + Utils.toJSONString(createdReplica));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.info(\"Error deleting \", e);\n        } catch (Exception e) {\n          log.error(\"Unknown Error deleteing\", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return null;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh);\n    results.add(\"success\", \"REPLACENODE completed successfully from  : \" + source + \" to : \" + target);\n    return null;\n  }\n\n","bugFix":null,"bugIntro":["ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","date":1471496851,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public Object call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"going to create replica {}\", Utils.toJSONString(sourceReplica));\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              log.warn(\"failed to create : \" + Utils.toJSONString(msg));\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", \"Could not create copy of replica \" + Utils.toJSONString(sourceReplica));\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.info(\"successfully created : \" + Utils.toJSONString(msg));\n\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.info(\"Waiting for creates to complete \");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.info(\"Waiting over for creates to complete \");\n\n    if (anyOneFailed.get()) {\n      log.info(\"failed to create some cores delete all \" + Utils.toJSONString(createdReplicas));\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"could not cleanup, because  : \" + deleteResult.get(\"failure\") + \"  \" + Utils.toJSONString(createdReplica));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.info(\"Error deleting \", e);\n        } catch (Exception e) {\n          log.error(\"Unknown Error deleteing\", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return null;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh);\n    results.add(\"success\", \"REPLACENODE completed successfully from  : \" + source + \" to : \" + target);\n    return null;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"403d05f7f8d69b65659157eff1bc1d2717f04c66","date":1471692961,"type":0,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858","date":1472733239,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":["9fac11578d87e86ac41841e07ba8db185cedf92c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bc8f206328a706450934717bec7ccc22ad166fc0","date":1473142172,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"17e5da53e4e5bd659e22add9bba1cfa222e7e30d","date":1475435902,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0e8270c911ac3f2780a5d8660bd53be1aa142ad8","date":1497368366,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n        String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n        String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n        String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n        String key = collectionName + \"_\" + replicaName;\n        RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName, replicasToRecover);\n        watchers.put(key, watcher);\n        zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n      }\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","date":1498028748,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n        String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n        String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n        String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n        String key = collectionName + \"_\" + replicaName;\n        RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName, replicasToRecover);\n        watchers.put(key, watcher);\n        zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n      }\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n        String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n        String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n        String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n        String key = collectionName + \"_\" + replicaName;\n        RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName, replicasToRecover);\n        watchers.put(key, watcher);\n        zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n      }\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replace node action to complete\");\n    countDownLatch.await(5, TimeUnit.MINUTES);\n    log.debug(\"Finished waiting for replace node action to complete\");\n\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ecb39e783dd104116a9502e8b0ab3df89f35ac19","date":1499167547,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n        String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n        String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n        String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n        String key = collectionName + \"_\" + replicaName;\n        RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName, replicasToRecover);\n        watchers.put(key, watcher);\n        zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n      }\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2ea161f828a3a7a6eb9410a431aecda6d7ab1065","date":1499213384,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n        String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n        String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n        String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n        String key = collectionName + \"_\" + replicaName;\n        RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName, replicasToRecover);\n        watchers.put(key, watcher);\n        zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n      }\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e","date":1500089733,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"aaf90fc29510e72665ac7934f34c3d1c25efad64","date":1500354819,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    ocmh.checkRequired(message, \"source\", \"target\");\n    String source = message.getStr(\"source\");\n    String target = message.getStr(\"target\");\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2bcfee499548996a6e5448bbf93b8f276d010270","date":1508336936,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false)) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, RecoveryWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false)) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          RecoveryWatcher watcher = new RecoveryWatcher(collectionName, shardName, replicaName,\n              addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          watchers.put(key, watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (RecoveryWatcher watcher : watchers.values()) {\n      zkStateReader.removeCollectionStateWatcher(watcher.collectionId, watcher);\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"67e503ef0f418bc92404ff5d55694087c23d48eb","date":1509025368,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    CountDownLatch countDownLatch = new CountDownLatch(sourceReplicas.size());\n\n    CountDownLatch replicasToRecover = new CountDownLatch(numLeaders);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      CountDownLatch cleanupLatch = new CountDownLatch(createdReplicas.size());\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/cloud/api/collections/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/ReplaceNodeCmd#call(ClusterState,ZkNodeProps,NamedList).mjava","sourceNew":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","sourceOld":"  @Override\n  public void call(ClusterState state, ZkNodeProps message, NamedList results) throws Exception {\n    ZkStateReader zkStateReader = ocmh.zkStateReader;\n    String source = message.getStr(CollectionParams.SOURCE_NODE, message.getStr(\"source\"));\n    String target = message.getStr(CollectionParams.TARGET_NODE, message.getStr(\"target\"));\n    boolean waitForFinalState = message.getBool(CommonAdminParams.WAIT_FOR_FINAL_STATE, false);\n    if (source == null || target == null) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"sourceNode and targetNode are required params\" );\n    }\n    String async = message.getStr(\"async\");\n    int timeout = message.getInt(\"timeout\", 10 * 60); // 10 minutes\n    boolean parallel = message.getBool(\"parallel\", false);\n    ClusterState clusterState = zkStateReader.getClusterState();\n\n    if (!clusterState.liveNodesContain(source)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Source Node: \" + source + \" is not live\");\n    }\n    if (!clusterState.liveNodesContain(target)) {\n      throw new SolrException(SolrException.ErrorCode.BAD_REQUEST, \"Target Node: \" + target + \" is not live\");\n    }\n    List<ZkNodeProps> sourceReplicas = getReplicasOfNode(source, clusterState);\n    // how many leaders are we moving? for these replicas we have to make sure that either:\n    // * another existing replica can become a leader, or\n    // * we wait until the newly created replica completes recovery (and can become the new leader)\n    // If waitForFinalState=true we wait for all replicas\n    int numLeaders = 0;\n    for (ZkNodeProps props : sourceReplicas) {\n      if (props.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n        numLeaders++;\n      }\n    }\n    // map of collectionName_coreNodeName to watchers\n    Map<String, CollectionStateWatcher> watchers = new HashMap<>();\n    List<ZkNodeProps> createdReplicas = new ArrayList<>();\n\n    AtomicBoolean anyOneFailed = new AtomicBoolean(false);\n    SolrCloseableLatch countDownLatch = new SolrCloseableLatch(sourceReplicas.size(), ocmh);\n\n    SolrCloseableLatch replicasToRecover = new SolrCloseableLatch(numLeaders, ocmh);\n\n    for (ZkNodeProps sourceReplica : sourceReplicas) {\n      NamedList nl = new NamedList();\n      log.info(\"Going to create replica for collection={} shard={} on node={}\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n      ZkNodeProps msg = sourceReplica.plus(\"parallel\", String.valueOf(parallel)).plus(CoreAdminParams.NODE, target);\n      if(async!=null) msg.getProperties().put(ASYNC, async);\n      final ZkNodeProps addedReplica = ocmh.addReplica(clusterState,\n          msg, nl, () -> {\n            countDownLatch.countDown();\n            if (nl.get(\"failure\") != null) {\n              String errorString = String.format(Locale.ROOT, \"Failed to create replica for collection=%s shard=%s\" +\n                  \" on node=%s\", sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n              log.warn(errorString);\n              // one replica creation failed. Make the best attempt to\n              // delete all the replicas created so far in the target\n              // and exit\n              synchronized (results) {\n                results.add(\"failure\", errorString);\n                anyOneFailed.set(true);\n              }\n            } else {\n              log.debug(\"Successfully created replica for collection={} shard={} on node={}\",\n                  sourceReplica.getStr(COLLECTION_PROP), sourceReplica.getStr(SHARD_ID_PROP), target);\n            }\n          });\n\n      if (addedReplica != null) {\n        createdReplicas.add(addedReplica);\n        if (sourceReplica.getBool(ZkStateReader.LEADER_PROP, false) || waitForFinalState) {\n          String shardName = sourceReplica.getStr(SHARD_ID_PROP);\n          String replicaName = sourceReplica.getStr(ZkStateReader.REPLICA_PROP);\n          String collectionName = sourceReplica.getStr(COLLECTION_PROP);\n          String key = collectionName + \"_\" + replicaName;\n          CollectionStateWatcher watcher;\n          if (waitForFinalState) {\n            watcher = new ActiveReplicaWatcher(collectionName, null,\n                Collections.singletonList(addedReplica.getStr(ZkStateReader.CORE_NAME_PROP)), replicasToRecover);\n          } else {\n            watcher = new LeaderRecoveryWatcher(collectionName, shardName, replicaName,\n                addedReplica.getStr(ZkStateReader.CORE_NAME_PROP), replicasToRecover);\n          }\n          watchers.put(key, watcher);\n          log.debug(\"--- adding \" + key + \", \" + watcher);\n          zkStateReader.registerCollectionStateWatcher(collectionName, watcher);\n        } else {\n          log.debug(\"--- not waiting for \" + addedReplica);\n        }\n      }\n    }\n\n    log.debug(\"Waiting for replicas to be added\");\n    if (!countDownLatch.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for replicas to be added\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for replicas to be added\");\n    }\n\n    // now wait for leader replicas to recover\n    log.debug(\"Waiting for \" + numLeaders + \" leader replicas to recover\");\n    if (!replicasToRecover.await(timeout, TimeUnit.SECONDS)) {\n      log.info(\"Timed out waiting for \" + replicasToRecover.getCount() + \" leader replicas to recover\");\n      anyOneFailed.set(true);\n    } else {\n      log.debug(\"Finished waiting for leader replicas to recover\");\n    }\n    // remove the watchers, we're done either way\n    for (Map.Entry<String, CollectionStateWatcher> e : watchers.entrySet()) {\n      zkStateReader.removeCollectionStateWatcher(e.getKey(), e.getValue());\n    }\n    if (anyOneFailed.get()) {\n      log.info(\"Failed to create some replicas. Cleaning up all replicas on target node\");\n      SolrCloseableLatch cleanupLatch = new SolrCloseableLatch(createdReplicas.size(), ocmh);\n      for (ZkNodeProps createdReplica : createdReplicas) {\n        NamedList deleteResult = new NamedList();\n        try {\n          ocmh.deleteReplica(zkStateReader.getClusterState(), createdReplica.plus(\"parallel\", \"true\"), deleteResult, () -> {\n            cleanupLatch.countDown();\n            if (deleteResult.get(\"failure\") != null) {\n              synchronized (results) {\n                results.add(\"failure\", \"Could not cleanup, because of : \" + deleteResult.get(\"failure\"));\n              }\n            }\n          });\n        } catch (KeeperException e) {\n          cleanupLatch.countDown();\n          log.warn(\"Error deleting replica \", e);\n        } catch (Exception e) {\n          log.warn(\"Error deleting replica \", e);\n          cleanupLatch.countDown();\n          throw e;\n        }\n      }\n      cleanupLatch.await(5, TimeUnit.MINUTES);\n      return;\n    }\n\n\n    // we have reached this far means all replicas could be recreated\n    //now cleanup the replicas in the source node\n    DeleteNodeCmd.cleanupReplicas(results, state, sourceReplicas, ocmh, source, async);\n    results.add(\"success\", \"REPLACENODE action completed successfully from  : \" + source + \" to : \" + target);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["67e503ef0f418bc92404ff5d55694087c23d48eb","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"2bcfee499548996a6e5448bbf93b8f276d010270":["541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e":["ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"0e8270c911ac3f2780a5d8660bd53be1aa142ad8":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["b1777912fb613f51063554d81f71c1b70d6bcd77","9fac11578d87e86ac41841e07ba8db185cedf92c"],"b1777912fb613f51063554d81f71c1b70d6bcd77":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"9fac11578d87e86ac41841e07ba8db185cedf92c":["b1777912fb613f51063554d81f71c1b70d6bcd77"],"bc8f206328a706450934717bec7ccc22ad166fc0":["403d05f7f8d69b65659157eff1bc1d2717f04c66","ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858"],"28288370235ed02234a64753cdbf0c6ec096304a":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","0e8270c911ac3f2780a5d8660bd53be1aa142ad8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"ecb39e783dd104116a9502e8b0ab3df89f35ac19":["28288370235ed02234a64753cdbf0c6ec096304a"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9","ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065","541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e"],"67e503ef0f418bc92404ff5d55694087c23d48eb":["2bcfee499548996a6e5448bbf93b8f276d010270"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["403d05f7f8d69b65659157eff1bc1d2717f04c66","ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858"],"ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["17e5da53e4e5bd659e22add9bba1cfa222e7e30d","0e8270c911ac3f2780a5d8660bd53be1aa142ad8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"2bcfee499548996a6e5448bbf93b8f276d010270":["67e503ef0f418bc92404ff5d55694087c23d48eb"],"403d05f7f8d69b65659157eff1bc1d2717f04c66":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d","ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858"],"541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e":["2bcfee499548996a6e5448bbf93b8f276d010270","aaf90fc29510e72665ac7934f34c3d1c25efad64"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"0e8270c911ac3f2780a5d8660bd53be1aa142ad8":["28288370235ed02234a64753cdbf0c6ec096304a","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"2c8bedceb91e64a3f0e831450058fc4a76d2c0a6":["403d05f7f8d69b65659157eff1bc1d2717f04c66"],"b1777912fb613f51063554d81f71c1b70d6bcd77":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6","9fac11578d87e86ac41841e07ba8db185cedf92c"],"9fac11578d87e86ac41841e07ba8db185cedf92c":["2c8bedceb91e64a3f0e831450058fc4a76d2c0a6"],"bc8f206328a706450934717bec7ccc22ad166fc0":[],"28288370235ed02234a64753cdbf0c6ec096304a":["ecb39e783dd104116a9502e8b0ab3df89f35ac19"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"ecb39e783dd104116a9502e8b0ab3df89f35ac19":["541d16fbfc627e2eeecfb3eb40fe384fa8c75b4e","2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"2ea161f828a3a7a6eb9410a431aecda6d7ab1065":["aaf90fc29510e72665ac7934f34c3d1c25efad64"],"aaf90fc29510e72665ac7934f34c3d1c25efad64":[],"67e503ef0f418bc92404ff5d55694087c23d48eb":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["403d05f7f8d69b65659157eff1bc1d2717f04c66","b1777912fb613f51063554d81f71c1b70d6bcd77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"17e5da53e4e5bd659e22add9bba1cfa222e7e30d":["0e8270c911ac3f2780a5d8660bd53be1aa142ad8","28288370235ed02234a64753cdbf0c6ec096304a","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9"],"ce0735cbef33a0057ccb0f6ccc3caaf1bd95e858":["bc8f206328a706450934717bec7ccc22ad166fc0","17e5da53e4e5bd659e22add9bba1cfa222e7e30d"],"2a3ed3f77cdd034e789d00d1ca8bb7054c9fb8e9":["2ea161f828a3a7a6eb9410a431aecda6d7ab1065"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["bc8f206328a706450934717bec7ccc22ad166fc0","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","aaf90fc29510e72665ac7934f34c3d1c25efad64","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}