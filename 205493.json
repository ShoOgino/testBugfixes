{"path":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","commits":[{"id":"9454a6510e2db155fb01faa5c049b06ece95fab9","date":1453508333,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c125dddafda5f2d3113008e968b4d5696d8140ce","date":1289497056,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85a883878c0af761245ab048babc63d099f835f3","date":1289553330,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5390d5f5bc8bf5d65eff4c1d596cf9547ead0c56","date":1290598569,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(makeOneMerge(infos, infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"38a62612cfa4e104080d89d7751a8f1a258ac335","date":1291442315,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(makeOneMerge(infos, infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3bb13258feba31ab676502787ab2e1779f129b7a","date":1291596436,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(makeOneMerge(infos, infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","date":1291833341,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(makeOneMerge(infos, infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel < levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end), useCompoundFile));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e623f9a0e45508ab149c2fb3e0fd0c2503f98186","date":1295889977,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n      message(\"seg \" + info.name + \" level=\" + levels[i]);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb9b72f7c3d7827c64dd4ec580ded81778da361d","date":1295897920,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n      message(\"seg \" + info.name + \" level=\" + levels[i]);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c19f985e36a65cc969e8e564fe337a0d41512075","date":1296330536,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    SegmentInfoAndLevel[] levels = new SegmentInfoAndLevel[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      message(\"seg \" + info.name + \" level=\" + levels[i].level + \" size=\" + size);\n    }\n\n    if (!requireContiguousMerge) {\n      Arrays.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start].level;\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i].level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto].level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels[i].info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Arrays.sort(levels, start, end, sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels[i].info);\n            assert infos.contains(levels[i].info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n      message(\"seg \" + info.name + \" level=\" + levels[i]);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":["867c1d467255521b6a85a819a2097440670b7cc9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"867c1d467255521b6a85a819a2097440670b7cc9","date":1296856472,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      levels.add(new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i));\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + levels.get(i).level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    SegmentInfoAndLevel[] levels = new SegmentInfoAndLevel[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      message(\"seg \" + info.name + \" level=\" + levels[i].level + \" size=\" + size);\n    }\n\n    if (!requireContiguousMerge) {\n      Arrays.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start].level;\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i].level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto].level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels[i].info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Arrays.sort(levels, start, end, sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels[i].info);\n            assert infos.contains(levels[i].info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":["b1405362241b561f5590ff4a87d5d6e173bcd9cf","c19f985e36a65cc969e8e564fe337a0d41512075"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      levels.add(new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i));\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + levels.get(i).level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f490004e1864ff366db97f6c3a68d031c3787ed","date":1297332083,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      levels.add(new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i));\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + levels.get(i).level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f1bdbf92da222965b46c0a942c3857ba56e5c638","date":1298297608,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      levels.add(new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i));\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + levels.get(i).level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"bde51b089eb7f86171eb3406e38a274743f9b7ac","date":1298336439,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    float[] levels = new float[numSegments];\n    final float norm = (float) Math.log(mergeFactor);\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1)\n        size = 1;\n      levels[i] = (float) Math.log(size)/norm;\n      message(\"seg \" + info.name + \" level=\" + levels[i]);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    int start = 0;\n    while(start < numSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels[start];\n      for(int i=1+start;i<numSegments;i++) {\n        final float level = levels[i];\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numSegments-1;\n      while(upto >= start) {\n        if (levels[upto] >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = infos.info(i);\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose())\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          spec.add(new OneMerge(infos.range(start, end)));\n        } else if (verbose())\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"01e5948db9a07144112d2f08f28ca2e3cd880348","date":1301759232,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"45669a651c970812a680841b97a77cce06af559f","date":1301922222,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"135621f3a0670a9394eb563224a3b76cc4dddc0f","date":1304344257,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5270fb4f55a1b77663dda53cb8090c083f0a23b3","date":1305050821,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c700f8d0842d3e52bb2bdfbfdc046a137e836edb","date":1305285499,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3776dccca01c11e7046323cfad46a3b4a471233","date":1306100719,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // When we require contiguous merge, we still add the\n      // segment to levels to avoid merging \"across\" a set\n      // of segment being merged:\n      if (!requireContiguousMerge && mergingSegments.contains(info)) {\n        if (verbose()) {\n          message(\"seg \" + info.name + \" already being merged; skip\");\n        }\n        continue;\n      }\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n      if (verbose()) {\n        message(\"seg \" + info.name + \" level=\" + infoLevel.level + \" size=\" + size);\n      }\n    }\n\n    if (!requireContiguousMerge) {\n      Collections.sort(levels);\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n        }\n\n        if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          if (verbose()) {\n            message(\"    \" + start + \" to \" + end + \": add this merge\");\n          }\n          Collections.sort(levels.subList(start, end), sortByIndex);\n          final SegmentInfos mergeInfos = new SegmentInfos();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5df35ab57c223ea11aec64b53bf611904f3dced","date":1323640545,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose()) {\n      message(\"findMerges: \" + numSegments + \" segments\");\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose()) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","date":1323720782,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose()) {\n      message(\"findMerges: \" + numSegments + \" segments\");\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose()) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose())\n      message(\"findMerges: \" + numSegments + \" segments\");\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose())\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/LogMergePolicy#findMerges(SegmentInfos).mjava","sourceNew":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose()) {\n      message(\"findMerges: \" + numSegments + \" segments\");\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose()) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","sourceOld":"  /** Checks if any merges are now necessary and returns a\n   *  {@link MergePolicy.MergeSpecification} if so.  A merge\n   *  is necessary when there are more than {@link\n   *  #setMergeFactor} segments at a given level.  When\n   *  multiple levels have too many segments, this method\n   *  will return multiple merges, allowing the {@link\n   *  MergeScheduler} to use concurrency. */\n  @Override\n  public MergeSpecification findMerges(SegmentInfos infos) throws IOException {\n\n    final int numSegments = infos.size();\n    if (verbose()) {\n      message(\"findMerges: \" + numSegments + \" segments\");\n    }\n\n    // Compute levels, which is just log (base mergeFactor)\n    // of the size of each segment\n    final List<SegmentInfoAndLevel> levels = new ArrayList<SegmentInfoAndLevel>();\n    final float norm = (float) Math.log(mergeFactor);\n\n    final Collection<SegmentInfo> mergingSegments = writer.get().getMergingSegments();\n\n    for(int i=0;i<numSegments;i++) {\n      final SegmentInfo info = infos.info(i);\n      long size = size(info);\n\n      // Floor tiny segments\n      if (size < 1) {\n        size = 1;\n      }\n\n      final SegmentInfoAndLevel infoLevel = new SegmentInfoAndLevel(info, (float) Math.log(size)/norm, i);\n      levels.add(infoLevel);\n\n      if (verbose()) {\n        final long segBytes = sizeBytes(info);\n        String extra = mergingSegments.contains(info) ? \" [merging]\" : \"\";\n        if (size >= maxMergeSize) {\n          extra += \" [skip: too large]\";\n        }\n        message(\"seg=\" + writer.get().segString(info) + \" level=\" + infoLevel.level + \" size=\" + String.format(\"%.3f MB\", segBytes/1024/1024.) + extra);\n      }\n    }\n\n    final float levelFloor;\n    if (minMergeSize <= 0)\n      levelFloor = (float) 0.0;\n    else\n      levelFloor = (float) (Math.log(minMergeSize)/norm);\n\n    // Now, we quantize the log values into levels.  The\n    // first level is any segment whose log size is within\n    // LEVEL_LOG_SPAN of the max size, or, who has such as\n    // segment \"to the right\".  Then, we find the max of all\n    // other segments and use that to define the next level\n    // segment, etc.\n\n    MergeSpecification spec = null;\n\n    final int numMergeableSegments = levels.size();\n\n    int start = 0;\n    while(start < numMergeableSegments) {\n\n      // Find max level of all segments not already\n      // quantized.\n      float maxLevel = levels.get(start).level;\n      for(int i=1+start;i<numMergeableSegments;i++) {\n        final float level = levels.get(i).level;\n        if (level > maxLevel)\n          maxLevel = level;\n      }\n\n      // Now search backwards for the rightmost segment that\n      // falls into this level:\n      float levelBottom;\n      if (maxLevel <= levelFloor)\n        // All remaining segments fall into the min level\n        levelBottom = -1.0F;\n      else {\n        levelBottom = (float) (maxLevel - LEVEL_LOG_SPAN);\n\n        // Force a boundary at the level floor\n        if (levelBottom < levelFloor && maxLevel >= levelFloor)\n          levelBottom = levelFloor;\n      }\n\n      int upto = numMergeableSegments-1;\n      while(upto >= start) {\n        if (levels.get(upto).level >= levelBottom) {\n          break;\n        }\n        upto--;\n      }\n      if (verbose()) {\n        message(\"  level \" + levelBottom + \" to \" + maxLevel + \": \" + (1+upto-start) + \" segments\");\n      }\n\n      // Finally, record all merges that are viable at this level:\n      int end = start + mergeFactor;\n      while(end <= 1+upto) {\n        boolean anyTooLarge = false;\n        boolean anyMerging = false;\n        for(int i=start;i<end;i++) {\n          final SegmentInfo info = levels.get(i).info;\n          anyTooLarge |= (size(info) >= maxMergeSize || sizeDocs(info) >= maxMergeDocs);\n          if (mergingSegments.contains(info)) {\n            anyMerging = true;\n            break;\n          }\n        }\n\n        if (anyMerging) {\n          // skip\n        } else if (!anyTooLarge) {\n          if (spec == null)\n            spec = new MergeSpecification();\n          final List<SegmentInfo> mergeInfos = new ArrayList<SegmentInfo>();\n          for(int i=start;i<end;i++) {\n            mergeInfos.add(levels.get(i).info);\n            assert infos.contains(levels.get(i).info);\n          }\n          if (verbose()) {\n            message(\"  add merge=\" + writer.get().segString(mergeInfos) + \" start=\" + start + \" end=\" + end);\n          }\n          spec.add(new OneMerge(mergeInfos));\n        } else if (verbose()) {\n          message(\"    \" + start + \" to \" + end + \": contains segment over maxMergeSize or maxMergeDocs; skipping\");\n        }\n\n        start = end;\n        end = start + mergeFactor;\n      }\n\n      start = 1+upto;\n    }\n\n    return spec;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["29ef99d61cda9641b6250bf9567329a6e65f901d","6f490004e1864ff366db97f6c3a68d031c3787ed"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["c5df35ab57c223ea11aec64b53bf611904f3dced"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":["5270fb4f55a1b77663dda53cb8090c083f0a23b3","c5df35ab57c223ea11aec64b53bf611904f3dced"],"e623f9a0e45508ab149c2fb3e0fd0c2503f98186":["38a62612cfa4e104080d89d7751a8f1a258ac335"],"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e":["3bb13258feba31ab676502787ab2e1779f129b7a"],"5390d5f5bc8bf5d65eff4c1d596cf9547ead0c56":["c125dddafda5f2d3113008e968b4d5696d8140ce"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["9454a6510e2db155fb01faa5c049b06ece95fab9","38a62612cfa4e104080d89d7751a8f1a258ac335"],"c19f985e36a65cc969e8e564fe337a0d41512075":["e623f9a0e45508ab149c2fb3e0fd0c2503f98186"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","e623f9a0e45508ab149c2fb3e0fd0c2503f98186"],"01e5948db9a07144112d2f08f28ca2e3cd880348":["6f490004e1864ff366db97f6c3a68d031c3787ed"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["4a69e5860d014751cc9329dfeb441a6d8fd1ed8e","867c1d467255521b6a85a819a2097440670b7cc9"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"6f490004e1864ff366db97f6c3a68d031c3787ed":["867c1d467255521b6a85a819a2097440670b7cc9"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["bb9b72f7c3d7827c64dd4ec580ded81778da361d","6f490004e1864ff366db97f6c3a68d031c3787ed"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"38a62612cfa4e104080d89d7751a8f1a258ac335":["5390d5f5bc8bf5d65eff4c1d596cf9547ead0c56"],"867c1d467255521b6a85a819a2097440670b7cc9":["c19f985e36a65cc969e8e564fe337a0d41512075"],"85a883878c0af761245ab048babc63d099f835f3":["9454a6510e2db155fb01faa5c049b06ece95fab9","c125dddafda5f2d3113008e968b4d5696d8140ce"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["f1bdbf92da222965b46c0a942c3857ba56e5c638","01e5948db9a07144112d2f08f28ca2e3cd880348"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["01e5948db9a07144112d2f08f28ca2e3cd880348"],"c125dddafda5f2d3113008e968b4d5696d8140ce":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"a3776dccca01c11e7046323cfad46a3b4a471233":["6f490004e1864ff366db97f6c3a68d031c3787ed","5270fb4f55a1b77663dda53cb8090c083f0a23b3"],"45669a651c970812a680841b97a77cce06af559f":["bde51b089eb7f86171eb3406e38a274743f9b7ac","01e5948db9a07144112d2f08f28ca2e3cd880348"],"3bb13258feba31ab676502787ab2e1779f129b7a":["85a883878c0af761245ab048babc63d099f835f3","5390d5f5bc8bf5d65eff4c1d596cf9547ead0c56"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"]},"commit2Childs":{"c5df35ab57c223ea11aec64b53bf611904f3dced":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c"],"f1bdbf92da222965b46c0a942c3857ba56e5c638":["135621f3a0670a9394eb563224a3b76cc4dddc0f"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"93ccd971aca7fb61b7f1b946e44714cfc80bfc7c":[],"e623f9a0e45508ab149c2fb3e0fd0c2503f98186":["c19f985e36a65cc969e8e564fe337a0d41512075","bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"4a69e5860d014751cc9329dfeb441a6d8fd1ed8e":["29ef99d61cda9641b6250bf9567329a6e65f901d"],"5390d5f5bc8bf5d65eff4c1d596cf9547ead0c56":["38a62612cfa4e104080d89d7751a8f1a258ac335","3bb13258feba31ab676502787ab2e1779f129b7a"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["bb9b72f7c3d7827c64dd4ec580ded81778da361d"],"c19f985e36a65cc969e8e564fe337a0d41512075":["867c1d467255521b6a85a819a2097440670b7cc9"],"bb9b72f7c3d7827c64dd4ec580ded81778da361d":["bde51b089eb7f86171eb3406e38a274743f9b7ac"],"01e5948db9a07144112d2f08f28ca2e3cd880348":["135621f3a0670a9394eb563224a3b76cc4dddc0f","5270fb4f55a1b77663dda53cb8090c083f0a23b3","45669a651c970812a680841b97a77cce06af559f"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["f1bdbf92da222965b46c0a942c3857ba56e5c638"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9454a6510e2db155fb01faa5c049b06ece95fab9"],"c700f8d0842d3e52bb2bdfbfdc046a137e836edb":[],"6f490004e1864ff366db97f6c3a68d031c3787ed":["f1bdbf92da222965b46c0a942c3857ba56e5c638","01e5948db9a07144112d2f08f28ca2e3cd880348","bde51b089eb7f86171eb3406e38a274743f9b7ac","a3776dccca01c11e7046323cfad46a3b4a471233"],"bde51b089eb7f86171eb3406e38a274743f9b7ac":["45669a651c970812a680841b97a77cce06af559f"],"9454a6510e2db155fb01faa5c049b06ece95fab9":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","85a883878c0af761245ab048babc63d099f835f3","c125dddafda5f2d3113008e968b4d5696d8140ce"],"38a62612cfa4e104080d89d7751a8f1a258ac335":["e623f9a0e45508ab149c2fb3e0fd0c2503f98186","7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"867c1d467255521b6a85a819a2097440670b7cc9":["29ef99d61cda9641b6250bf9567329a6e65f901d","6f490004e1864ff366db97f6c3a68d031c3787ed"],"135621f3a0670a9394eb563224a3b76cc4dddc0f":["c700f8d0842d3e52bb2bdfbfdc046a137e836edb"],"85a883878c0af761245ab048babc63d099f835f3":["3bb13258feba31ab676502787ab2e1779f129b7a"],"5270fb4f55a1b77663dda53cb8090c083f0a23b3":["c5df35ab57c223ea11aec64b53bf611904f3dced","93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","a3776dccca01c11e7046323cfad46a3b4a471233"],"c125dddafda5f2d3113008e968b4d5696d8140ce":["5390d5f5bc8bf5d65eff4c1d596cf9547ead0c56","85a883878c0af761245ab048babc63d099f835f3"],"a3776dccca01c11e7046323cfad46a3b4a471233":[],"45669a651c970812a680841b97a77cce06af559f":[],"3bb13258feba31ab676502787ab2e1779f129b7a":["4a69e5860d014751cc9329dfeb441a6d8fd1ed8e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["93ccd971aca7fb61b7f1b946e44714cfc80bfc7c","c700f8d0842d3e52bb2bdfbfdc046a137e836edb","a3776dccca01c11e7046323cfad46a3b4a471233","45669a651c970812a680841b97a77cce06af559f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}