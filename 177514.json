{"path":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","commits":[{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":1,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","sourceOld":"  @Test\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":1,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","sourceOld":"  @Test\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"43ad790248d7f7daee5d9cced548c546f37c7218","date":1527269998,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","sourceOld":"  @Test\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2d6b868457b26b5a2145b8441b1cfcfc0692b02","date":1534307099,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  //commented 9-Aug-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","sourceOld":"  @Test\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cba13865da71de3b9b0937fcbc66d726089356d","date":1537507909,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  //commented 9-Aug-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Sep-2018\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","sourceOld":"  @Test\n  //commented 9-Aug-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bb222a3f9d9421d5c95afce73013fbd8de07ea1f","date":1543514331,"type":3,"author":"markrmiller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  public void testAsyncRequests() throws Exception {\n    boolean legacy = random().nextBoolean();\n    if (legacy) {\n      CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, \"true\").process(cluster.getSolrClient());\n    } else {\n      CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, \"false\").process(cluster.getSolrClient());\n    }\n    \n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    \n    cluster.waitForActiveCollection(collection, 1, 1);\n    \n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    client.getZkStateReader().forceUpdateCollection(collection);\n    \n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    client.getZkStateReader().waitForState(collection, 20, TimeUnit.SECONDS, (n, c) -> {\n      if (c == null)\n        return false;\n      Slice slice = c.getSlice(\"shard1\");\n      if (slice == null) {\n        return false;\n      }\n\n      if (slice.getReplicas().size() == 2) {\n        return true;\n      }\n\n      return false;\n    });\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n    \n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n    client.getZkStateReader().forceUpdateCollection(collection);\n    \n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    if (!legacy) {\n      state = CollectionAdminRequest.deleteCollection(collection)\n          .processAndWait(client, MAX_TIMEOUT_SECONDS);\n      assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n    }\n  }\n\n","sourceOld":"  @Test\n  //commented 9-Aug-2018  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 21-May-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // added 20-Sep-2018\n  public void testAsyncRequests() throws Exception {\n\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    int count = 0;\n    while (shard1.getReplicas().size() != 2) {\n      if (count++ > 1000) {\n        fail(\"2nd Replica not reflecting in the cluster state\");\n      }\n      Thread.sleep(100);\n    }\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n\n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","bugFix":["3088cdaa24ffe3ef44713ac9484114bd56eca2af","4cba13865da71de3b9b0937fcbc66d726089356d","344b0840364d990b29b97467bfcc766ff8325d11","3bbb741690cdafda7f1f7549c26351c912917a69","861a8940601b61a2fd5427f7187314d516ef1586","d2d6b868457b26b5a2145b8441b1cfcfc0692b02","b54504c5305a6cc48f59c627c9c8dd727e2a8f0b","ac97ea104d893f16aab430d9904473bc1f233f3c"],"bugIntro":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/api/collections/CollectionsAPIAsyncDistributedZkTest#testAsyncRequests().mjava","sourceNew":"  @Test\n  public void testAsyncRequests() throws Exception {\n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    \n    cluster.waitForActiveCollection(collection, 1, 1);\n    \n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    client.getZkStateReader().forceUpdateCollection(collection);\n    \n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    client.getZkStateReader().waitForState(collection, 20, TimeUnit.SECONDS, (n, c) -> {\n      if (c == null)\n        return false;\n      Slice slice = c.getSlice(\"shard1\");\n      if (slice == null) {\n        return false;\n      }\n\n      if (slice.getReplicas().size() == 2) {\n        return true;\n      }\n\n      return false;\n    });\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n    \n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n    client.getZkStateReader().forceUpdateCollection(collection);\n    \n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.deleteCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n  }\n\n","sourceOld":"  @Test\n  public void testAsyncRequests() throws Exception {\n    boolean legacy = random().nextBoolean();\n    if (legacy) {\n      CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, \"true\").process(cluster.getSolrClient());\n    } else {\n      CollectionAdminRequest.setClusterProperty(ZkStateReader.LEGACY_CLOUD, \"false\").process(cluster.getSolrClient());\n    }\n    \n    final String collection = \"testAsyncOperations\";\n    final CloudSolrClient client = cluster.getSolrClient();\n\n    RequestStatusState state = CollectionAdminRequest.createCollection(collection,\"conf1\",1,1)\n        .setRouterName(\"implicit\")\n        .setShards(\"shard1\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateCollection task did not complete!\", RequestStatusState.COMPLETED, state);\n\n    \n    cluster.waitForActiveCollection(collection, 1, 1);\n    \n    //Add a few documents to shard1\n    int numDocs = TestUtil.nextInt(random(), 10, 100);\n    List<SolrInputDocument> docs = new ArrayList<>(numDocs);\n    for (int i=0; i<numDocs; i++) {\n      SolrInputDocument doc = new SolrInputDocument();\n      doc.addField(\"id\", i);\n      doc.addField(\"_route_\", \"shard1\");\n      docs.add(doc);\n    }\n    client.add(collection, docs);\n    client.commit(collection);\n\n    SolrQuery query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.reloadCollection(collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"ReloadCollection did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.createShard(collection,\"shard2\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    client.getZkStateReader().forceUpdateCollection(collection);\n    \n    //Add a doc to shard2 to make sure shard2 was created properly\n    SolrInputDocument doc = new SolrInputDocument();\n    doc.addField(\"id\", numDocs + 1);\n    doc.addField(\"_route_\", \"shard2\");\n    client.add(collection, doc);\n    client.commit(collection);\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard2\");\n    assertEquals(1, client.query(collection, query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteShard(collection,\"shard2\").processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteShard did not complete\", RequestStatusState.COMPLETED, state);\n\n    state = CollectionAdminRequest.addReplicaToShard(collection, \"shard1\")\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"AddReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    //cloudClient watch might take a couple of seconds to reflect it\n    client.getZkStateReader().waitForState(collection, 20, TimeUnit.SECONDS, (n, c) -> {\n      if (c == null)\n        return false;\n      Slice slice = c.getSlice(\"shard1\");\n      if (slice == null) {\n        return false;\n      }\n\n      if (slice.getReplicas().size() == 2) {\n        return true;\n      }\n\n      return false;\n    });\n\n    state = CollectionAdminRequest.createAlias(\"myalias\",collection)\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"CreateAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    query = new SolrQuery(\"*:*\");\n    query.set(\"shards\", \"shard1\");\n    assertEquals(numDocs, client.query(\"myalias\", query).getResults().getNumFound());\n\n    state = CollectionAdminRequest.deleteAlias(\"myalias\")\n        .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteAlias did not complete\", RequestStatusState.COMPLETED, state);\n\n    try {\n      client.query(\"myalias\", query);\n      fail(\"Alias should not exist\");\n    } catch (SolrException e) {\n      //expected\n    }\n    \n    Slice shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    Replica replica = shard1.getReplicas().iterator().next();\n    for (String liveNode : client.getZkStateReader().getClusterState().getLiveNodes()) {\n      if (!replica.getNodeName().equals(liveNode)) {\n        state = new CollectionAdminRequest.MoveReplica(collection, replica.getName(), liveNode)\n            .processAndWait(client, MAX_TIMEOUT_SECONDS);\n        assertSame(\"MoveReplica did not complete\", RequestStatusState.COMPLETED, state);\n        break;\n      }\n    }\n    client.getZkStateReader().forceUpdateCollection(collection);\n    \n    shard1 = client.getZkStateReader().getClusterState().getCollection(collection).getSlice(\"shard1\");\n    String replicaName = shard1.getReplicas().iterator().next().getName();\n    state = CollectionAdminRequest.deleteReplica(collection, \"shard1\", replicaName)\n      .processAndWait(client, MAX_TIMEOUT_SECONDS);\n    assertSame(\"DeleteReplica did not complete\", RequestStatusState.COMPLETED, state);\n\n    if (!legacy) {\n      state = CollectionAdminRequest.deleteCollection(collection)\n          .processAndWait(client, MAX_TIMEOUT_SECONDS);\n      assertSame(\"DeleteCollection did not complete\", RequestStatusState.COMPLETED, state);\n    }\n  }\n\n","bugFix":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d2d6b868457b26b5a2145b8441b1cfcfc0692b02":["43ad790248d7f7daee5d9cced548c546f37c7218"],"b94236357aaa22b76c10629851fe4e376e0cea82":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["4cba13865da71de3b9b0937fcbc66d726089356d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4cba13865da71de3b9b0937fcbc66d726089356d":["d2d6b868457b26b5a2145b8441b1cfcfc0692b02"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"43ad790248d7f7daee5d9cced548c546f37c7218":["b94236357aaa22b76c10629851fe4e376e0cea82"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"d2d6b868457b26b5a2145b8441b1cfcfc0692b02":["4cba13865da71de3b9b0937fcbc66d726089356d"],"b94236357aaa22b76c10629851fe4e376e0cea82":["43ad790248d7f7daee5d9cced548c546f37c7218"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"bb222a3f9d9421d5c95afce73013fbd8de07ea1f":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"4cba13865da71de3b9b0937fcbc66d726089356d":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"43ad790248d7f7daee5d9cced548c546f37c7218":["d2d6b868457b26b5a2145b8441b1cfcfc0692b02"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}