{"path":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","commits":[{"id":"9ce667c6d3400b22523701c549c0d35e26da8b46","date":1324405053,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,SegmentReader).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, SegmentReader mergedReader) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + merge.segString(directory) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skipping merge \" + merge.segString(directory) + \": it was aborted\");\n      }\n      return false;\n    }\n\n    commitMergedDeletes(merge, mergedReader);\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = mergedReader.numDocs() == 0;\n\n    if (allDeleted) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n    }\n    \n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    // If the merged segments had pending changes, clear\n    // them so that they don't bother writing them to\n    // disk, updating SegmentInfo, etc.:\n    readerPool.clear(merge.segments);\n\n    if (merge.maxNumSegments != -1) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"97becc6f32abceab12335ac4802f448ed88a318b","date":1326903017,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":["ae695f21c50b03702b5d0fa2543d5af844bb7cd3","ae695f21c50b03702b5d0fa2543d5af844bb7cd3"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a16d06e7522604de20b2d758d9b9464bb30fe02","date":1327070101,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e98320bb37cc6d20300ebef2f838ed11df399902","date":1327606217,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb","date":1327773585,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge,MergeState).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge, MergeState mergeState) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge, mergeState);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd92b8bcc88e969302510acf77bd6970da3994c4","date":1327839530,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n    \n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    closeMergeReaders(merge, false);\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#commitMerge(MergePolicy.OneMerge).mjava","sourceNew":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","sourceOld":"  synchronized private boolean commitMerge(MergePolicy.OneMerge merge) throws IOException {\n\n    assert testPoint(\"startCommitMerge\");\n\n    if (hitOOM) {\n      throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete merge\");\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"commitMerge: \" + segString(merge.segments) + \" index=\" + segString());\n    }\n\n    assert merge.registerDone;\n\n    // If merge was explicitly aborted, or, if rollback() or\n    // rollbackTransaction() had been called since our merge\n    // started (which results in an unqualified\n    // deleter.refresh() call that will remove any index\n    // file that current segments does not reference), we\n    // abort this merge\n    if (merge.isAborted()) {\n      if (infoStream.isEnabled(\"IW\")) {\n        infoStream.message(\"IW\", \"commitMerge: skip: it was aborted\");\n      }\n      return false;\n    }\n\n    final ReadersAndLiveDocs mergedDeletes = commitMergedDeletes(merge);\n\n    assert mergedDeletes == null || mergedDeletes.pendingDeleteCount != 0;\n\n    // If the doc store we are using has been closed and\n    // is in now compound format (but wasn't when we\n    // started), then we will switch to the compound\n    // format as well:\n\n    assert !segmentInfos.contains(merge.info);\n\n    final boolean allDeleted = merge.segments.size() == 0 ||\n      merge.info.docCount == 0 ||\n      (mergedDeletes != null &&\n       mergedDeletes.pendingDeleteCount == merge.info.docCount);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      if (allDeleted) {\n        infoStream.message(\"IW\", \"merged segment \" + merge.info + \" is 100% deleted\" +  (keepFullyDeletedSegments ? \"\" : \"; skipping insert\"));\n      }\n    }\n\n    final boolean dropSegment = allDeleted && !keepFullyDeletedSegments;\n\n    // If we merged no segments then we better be dropping\n    // the new segment:\n    assert merge.segments.size() > 0 || dropSegment;\n\n    assert merge.info.docCount != 0 || keepFullyDeletedSegments || dropSegment;\n\n    segmentInfos.applyMergeChanges(merge, dropSegment);\n    \n    if (dropSegment) {\n      readerPool.drop(merge.info);\n      deleter.deleteNewFiles(merge.info.files());\n      assert !segmentInfos.contains(merge.info);\n    } else {\n      if (mergedDeletes != null && !poolReaders) {\n        mergedDeletes.writeLiveDocs(directory);\n        readerPool.drop(merge.info);\n      }\n    }\n\n    // Must close before checkpoint, otherwise IFD won't be\n    // able to delete the held-open files from the merge\n    // readers:\n    closeMergeReaders(merge, false);\n\n    // Must note the change to segmentInfos so any commits\n    // in-flight don't lose it:\n    checkpoint();\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"after commit: \" + segString());\n    }\n\n    if (merge.maxNumSegments != -1 && !dropSegment) {\n      // cascade the forceMerge:\n      if (!segmentsToMerge.containsKey(merge.info)) {\n        segmentsToMerge.put(merge.info, Boolean.FALSE);\n      }\n    }\n\n    return true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"97becc6f32abceab12335ac4802f448ed88a318b":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["e98320bb37cc6d20300ebef2f838ed11df399902"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"fd92b8bcc88e969302510acf77bd6970da3994c4":["97becc6f32abceab12335ac4802f448ed88a318b","e98320bb37cc6d20300ebef2f838ed11df399902"],"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb":["8a16d06e7522604de20b2d758d9b9464bb30fe02"],"e98320bb37cc6d20300ebef2f838ed11df399902":["97becc6f32abceab12335ac4802f448ed88a318b"],"9ce667c6d3400b22523701c549c0d35e26da8b46":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"8a16d06e7522604de20b2d758d9b9464bb30fe02":["97becc6f32abceab12335ac4802f448ed88a318b"]},"commit2Childs":{"97becc6f32abceab12335ac4802f448ed88a318b":["fd92b8bcc88e969302510acf77bd6970da3994c4","e98320bb37cc6d20300ebef2f838ed11df399902","8a16d06e7522604de20b2d758d9b9464bb30fe02"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9ce667c6d3400b22523701c549c0d35e26da8b46"],"fd92b8bcc88e969302510acf77bd6970da3994c4":[],"32feb7c2c571b402d2e231bd8e3b6add4af6d6eb":[],"9ce667c6d3400b22523701c549c0d35e26da8b46":["97becc6f32abceab12335ac4802f448ed88a318b"],"e98320bb37cc6d20300ebef2f838ed11df399902":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","fd92b8bcc88e969302510acf77bd6970da3994c4"],"8a16d06e7522604de20b2d758d9b9464bb30fe02":["32feb7c2c571b402d2e231bd8e3b6add4af6d6eb"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["fd92b8bcc88e969302510acf77bd6970da3994c4","32feb7c2c571b402d2e231bd8e3b6add4af6d6eb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}