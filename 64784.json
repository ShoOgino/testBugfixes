{"path":"src/java/org/apache/lucene/index/IndexWriter#syncPause(long).mjava","commits":[{"id":"e82780afe6097066eb5befb86e9432f077667e3d","date":1202756169,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#syncPause(long).mjava","pathOld":"/dev/null","sourceNew":"  /** Pauses before syncing.  On Windows, at least, it's\n   *  best (performance-wise) to pause in order to let OS\n   *  flush writes to disk on its own, before forcing a\n   *  sync.\n   * @deprecated -- this will be removed in 3.0 when\n   * autoCommit is hardwired to false */\n  private void syncPause(long sizeInBytes) {\n    if (mergeScheduler instanceof ConcurrentMergeScheduler && maxSyncPauseSeconds > 0) {\n      // Rough heuristic: for every 10 MB, we pause for 1\n      // second, up until the max\n      long pauseTime = (long) (1000*sizeInBytes/10/1024/1024);\n      final long maxPauseTime = (long) (maxSyncPauseSeconds*1000);\n      if (pauseTime > maxPauseTime)\n        pauseTime = maxPauseTime;\n      final int sleepCount = (int) (pauseTime / 100);\n      for(int i=0;i<sleepCount;i++) {\n        synchronized(this) {\n          if (stopMerges || closing)\n            break;\n        }\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ba7fd1181f778e9954547e8e6a47587ebf08e3fb","date":1238267455,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"src/java/org/apache/lucene/index/IndexWriter#syncPause(long).mjava","pathOld":"src/java/org/apache/lucene/index/IndexWriter#syncPause(long).mjava","sourceNew":"  /** Pauses before syncing.  On Windows, at least, it's\n   *  best (performance-wise) to pause in order to let OS\n   *  flush writes to disk on its own, before forcing a\n   *  sync.\n   * @deprecated -- this will be removed in 3.0 when\n   * autoCommit is hardwired to false */\n  private void syncPause(long sizeInBytes) {\n    if (mergeScheduler instanceof ConcurrentMergeScheduler && maxSyncPauseSeconds > 0) {\n      // Rough heuristic: for every 10 MB, we pause for 1\n      // second, up until the max\n      long pauseTime = (long) (1000*sizeInBytes/10/1024/1024);\n      final long maxPauseTime = (long) (maxSyncPauseSeconds*1000);\n      if (pauseTime > maxPauseTime)\n        pauseTime = maxPauseTime;\n      final int sleepCount = (int) (pauseTime / 100);\n      for(int i=0;i<sleepCount;i++) {\n        synchronized(this) {\n          if (stopMerges || closing)\n            break;\n        }\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException ie) {\n          // In 3.0 we will change this to throw\n          // InterruptedException instead\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(ie);\n        }\n      }\n    }\n  }\n\n","sourceOld":"  /** Pauses before syncing.  On Windows, at least, it's\n   *  best (performance-wise) to pause in order to let OS\n   *  flush writes to disk on its own, before forcing a\n   *  sync.\n   * @deprecated -- this will be removed in 3.0 when\n   * autoCommit is hardwired to false */\n  private void syncPause(long sizeInBytes) {\n    if (mergeScheduler instanceof ConcurrentMergeScheduler && maxSyncPauseSeconds > 0) {\n      // Rough heuristic: for every 10 MB, we pause for 1\n      // second, up until the max\n      long pauseTime = (long) (1000*sizeInBytes/10/1024/1024);\n      final long maxPauseTime = (long) (maxSyncPauseSeconds*1000);\n      if (pauseTime > maxPauseTime)\n        pauseTime = maxPauseTime;\n      final int sleepCount = (int) (pauseTime / 100);\n      for(int i=0;i<sleepCount;i++) {\n        synchronized(this) {\n          if (stopMerges || closing)\n            break;\n        }\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException ie) {\n          Thread.currentThread().interrupt();\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8","date":1255049357,"type":4,"author":"Michael McCandless","isMerge":false,"pathNew":"/dev/null","pathOld":"src/java/org/apache/lucene/index/IndexWriter#syncPause(long).mjava","sourceNew":null,"sourceOld":"  /** Pauses before syncing.  On Windows, at least, it's\n   *  best (performance-wise) to pause in order to let OS\n   *  flush writes to disk on its own, before forcing a\n   *  sync.\n   * @deprecated -- this will be removed in 3.0 when\n   * autoCommit is hardwired to false */\n  private void syncPause(long sizeInBytes) {\n    if (mergeScheduler instanceof ConcurrentMergeScheduler && maxSyncPauseSeconds > 0) {\n      // Rough heuristic: for every 10 MB, we pause for 1\n      // second, up until the max\n      long pauseTime = (long) (1000*sizeInBytes/10/1024/1024);\n      final long maxPauseTime = (long) (maxSyncPauseSeconds*1000);\n      if (pauseTime > maxPauseTime)\n        pauseTime = maxPauseTime;\n      final int sleepCount = (int) (pauseTime / 100);\n      for(int i=0;i<sleepCount;i++) {\n        synchronized(this) {\n          if (stopMerges || closing)\n            break;\n        }\n        try {\n          Thread.sleep(100);\n        } catch (InterruptedException ie) {\n          // In 3.0 we will change this to throw\n          // InterruptedException instead\n          Thread.currentThread().interrupt();\n          throw new RuntimeException(ie);\n        }\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"e82780afe6097066eb5befb86e9432f077667e3d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["e82780afe6097066eb5befb86e9432f077667e3d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e82780afe6097066eb5befb86e9432f077667e3d"],"ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"e82780afe6097066eb5befb86e9432f077667e3d":["ba7fd1181f778e9954547e8e6a47587ebf08e3fb"],"ba7fd1181f778e9954547e8e6a47587ebf08e3fb":["ce99e2b80b5a9cb2b9b59c01219e5397b081dcd8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}