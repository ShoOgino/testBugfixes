{"path":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#stream().mjava","commits":[{"id":"6bb1e55267dc3975be328fddeb53509a50d37457","date":1561474467,"type":0,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#stream().mjava","pathOld":"/dev/null","sourceNew":"    private void stream() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6dc613ed6f75d1988140301ee8de8fdb056fa337","date":1588034757,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#stream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#stream().mjava","sourceNew":"    private void stream() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream: {}\", id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream: {}\", id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream: {}\",  id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream: {}\", id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:{}\", id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:{}\", id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    private void stream() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream:\" + id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream:\" + id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream:\" + id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream:\" + id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:\" + id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:\"+id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"804a8d5358fe7b7563b85ee7838714d720b89272","date":1591624987,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#stream().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/client/solrj/io/stream/DaemonStream.StreamRunner#stream().mjava","sourceNew":"    private void stream() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.getFields().containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream: {}\", id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream: {}\", id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream: {}\",  id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream: {}\", id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:{}\", id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        try {\n          queue.put(Tuple.EOF());\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:{}\", id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","sourceOld":"    private void stream() {\n      int errors = 0;\n      setStartTime(new Date().getTime());\n      OUTER:\n      while (!getShutdown()) {\n        long now = new Date().getTime();\n        if ((now - lastRun) > this.runInterval) {\n          lastRun = now;\n          try {\n            tupleStream.open();\n            INNER:\n            while (true) {\n              Tuple tuple = tupleStream.read();\n              if (tuple.EOF) {\n                errors = 0; // Reset errors on successful run.\n                if (tuple.fields.containsKey(\"sleepMillis\")) {\n                  this.sleepMillis = tuple.getLong(\"sleepMillis\");\n\n                  if(terminate && sleepMillis > 0) {\n                    //TopicStream provides sleepMillis > 0 if the last run had no Tuples.\n                    //This means the topic queue is empty. Time to terminate.\n                    //Remove ourselves from the daemons map.\n                    if(daemons != null) {\n                      daemons.remove(id);\n                    }\n                    //Break out of the thread loop and end the run.\n                    break OUTER;\n                  }\n\n                  this.runInterval = -1;\n                }\n                break INNER;\n              } else if (!eatTuples) {\n                try {\n                  queue.put(tuple);\n                } catch (InterruptedException e) {\n                  break OUTER;\n                }\n              }\n            }\n          } catch (IOException e) {\n            exception = e;\n            log.error(\"Error in DaemonStream: {}\", id, e);\n            ++errors;\n            if (errors > 100) {\n              log.error(\"Too many consecutive errors. Stopping DaemonStream: {}\", id);\n              break OUTER;\n            }\n          } catch (Throwable t) {\n            log.error(\"Fatal Error in DaemonStream: {}\",  id, t);\n            //For anything other then IOException break out of the loop and shutdown the thread.\n            break OUTER;\n          } finally {\n            try {\n              tupleStream.close();\n            } catch (IOException e1) {\n              if (exception == null) {\n                exception = e1;\n                log.error(\"Error in DaemonStream: {}\", id, e1);\n                break OUTER;\n              }\n            }\n          }\n        }\n        iterations.incrementAndGet();\n\n        if (sleepMillis > 0) {\n          try {\n            Thread.sleep(sleepMillis);\n          } catch (InterruptedException e) {\n            log.error(\"Error in DaemonStream:{}\", id, e);\n            break OUTER;\n          }\n        }\n      }\n\n      if(!eatTuples) {\n        Map m = new HashMap();\n        m.put(\"EOF\", true);\n        Tuple tuple = new Tuple(m);\n        try {\n          queue.put(tuple);\n        } catch (InterruptedException e) {\n          log.error(\"Error in DaemonStream:{}\", id, e);\n        }\n      }\n      setStopTime(new Date().getTime());\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["6bb1e55267dc3975be328fddeb53509a50d37457"],"6bb1e55267dc3975be328fddeb53509a50d37457":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"804a8d5358fe7b7563b85ee7838714d720b89272":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["804a8d5358fe7b7563b85ee7838714d720b89272"]},"commit2Childs":{"6dc613ed6f75d1988140301ee8de8fdb056fa337":["804a8d5358fe7b7563b85ee7838714d720b89272"],"6bb1e55267dc3975be328fddeb53509a50d37457":["6dc613ed6f75d1988140301ee8de8fdb056fa337"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6bb1e55267dc3975be328fddeb53509a50d37457"],"804a8d5358fe7b7563b85ee7838714d720b89272":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}