{"path":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","commits":[{"id":"893269407f5c988a4b2ee13c7ffc01ec43136c1d","date":1268598046,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","date":1268599006,"type":4,"author":"Mark Robert Miller","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":null,"sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ad94625fb8d088209f46650c8097196fec67f00c","date":1453508319,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1da8d55113b689b06716246649de6f62430f15c0","date":1453508340,"type":0,"author":"Dawid Weiss","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8b61dd7a57cd877fdc056d71912c8813a4c2d4e6","date":1277932343,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f4e87790277826a2aea119328600dfb07761f32","date":1279827275,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( ENABLE, true ) ) {\n      return;\n    }\n\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      BooleanQuery newq = new BooleanQuery( true );\n      newq.add( query, BooleanClause.Occur.SHOULD );\n      newq.add( booster.include, BooleanClause.Occur.SHOULD );\n      if( booster.exclude != null ) {\n        for( BooleanClause bq : booster.exclude ) {\n          newq.add( bq );\n        }\n      }\n      rb.setQuery( newq );\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"cd00dd91853514614379b0e680d65bd19cac0f30","date":1283087816,"type":3,"author":"Grant Ingersoll","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","date":1292920096,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      rb.addDebugInfo( \"queryBoosting\", dbg );\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c220849f876de24a79f756f65b3eb045db59f63f","date":1294902803,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"868da859b43505d9d2a023bfeae6dd0c795f5295","date":1294948401,"type":3,"author":"Michael Busch","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"29ef99d61cda9641b6250bf9567329a6e65f901d","date":1297244127,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"090a0320e4de4a3674376aef96b9701f47564f86","date":1308707325,"type":3,"author":"Christopher John Male","isMerge":false,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2553b00f699380c64959ccb27991289aae87be2e","date":1309290151,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":5,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":5,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","pathOld":"solr/src/java/org/apache/solr/handler/component/QueryElevationComponent#prepare(ResponseBuilder).mjava","sourceNew":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","sourceOld":"  @Override\n  public void prepare(ResponseBuilder rb) throws IOException\n  {\n    SolrQueryRequest req = rb.req;\n    SolrParams params = req.getParams();\n    // A runtime param can skip \n    if( !params.getBool( QueryElevationParams.ENABLE, true ) ) {\n      return;\n    }\n\n    boolean exclusive = params.getBool(QueryElevationParams.EXCLUSIVE, false);\n    // A runtime parameter can alter the config value for forceElevation\n    boolean force = params.getBool( QueryElevationParams.FORCE_ELEVATION, forceElevation );\n    \n    Query query = rb.getQuery();\n    String qstr = rb.getQueryString();\n    if( query == null || qstr == null) {\n      return;\n    }\n\n    qstr = getAnalyzedQuery(qstr);\n    IndexReader reader = req.getSearcher().getIndexReader();\n    ElevationObj booster = null;\n    try {\n      booster = getElevationMap( reader, req.getCore() ).get( qstr );\n    }\n    catch( Exception ex ) {\n      throw new SolrException( SolrException.ErrorCode.SERVER_ERROR,\n          \"Error loading elevation\", ex );      \n    }\n    \n    if( booster != null ) {\n      // Change the query to insert forced documents\n      if (exclusive == true){\n        //we only want these results\n        rb.setQuery(booster.include);\n      } else {\n        BooleanQuery newq = new BooleanQuery( true );\n        newq.add( query, BooleanClause.Occur.SHOULD );\n        newq.add( booster.include, BooleanClause.Occur.SHOULD );\n        if( booster.exclude != null ) {\n          for( BooleanClause bq : booster.exclude ) {\n            newq.add( bq );\n          }\n        }\n        rb.setQuery( newq );\n      }\n\n      \n      // if the sort is 'score desc' use a custom sorting method to \n      // insert documents in their proper place \n      SortSpec sortSpec = rb.getSortSpec();\n      if( sortSpec.getSort() == null ) {\n        sortSpec.setSort( new Sort( new SortField[] {\n            new SortField(idField, booster.comparatorSource, false ),\n            new SortField(null, SortField.Type.SCORE, false)\n        }));\n      }\n      else {\n        // Check if the sort is based on score\n        boolean modify = false;\n        SortField[] current = sortSpec.getSort().getSort();\n        ArrayList<SortField> sorts = new ArrayList<SortField>( current.length + 1 );\n        // Perhaps force it to always sort by score\n        if( force && current[0].getType() != SortField.Type.SCORE ) {\n          sorts.add( new SortField(idField, booster.comparatorSource, false ) );\n          modify = true;\n        }\n        for( SortField sf : current ) {\n          if( sf.getType() == SortField.Type.SCORE ) {\n            sorts.add( new SortField(idField, booster.comparatorSource, sf.getReverse() ) );\n            modify = true;\n          }\n          sorts.add( sf );\n        }\n        if( modify ) {\n          sortSpec.setSort( new Sort( sorts.toArray( new SortField[sorts.size()] ) ) );\n        }\n      }\n    }\n    \n    // Add debugging information\n    if( rb.isDebug() ) {\n      List<String> match = null;\n      if( booster != null ) {\n        // Extract the elevated terms into a list\n        match = new ArrayList<String>(booster.priority.size());\n        for( Object o : booster.include.clauses() ) {\n          TermQuery tq = (TermQuery)((BooleanClause)o).getQuery();\n          match.add( tq.getTerm().text() );\n        }\n      }\n      \n      SimpleOrderedMap<Object> dbg = new SimpleOrderedMap<Object>();\n      dbg.add( \"q\", qstr );\n      dbg.add( \"match\", match );\n      if (rb.isDebugQuery()) {\n        rb.addDebugInfo(\"queryBoosting\", dbg );\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"c26f00b574427b55127e869b935845554afde1fa":["090a0320e4de4a3674376aef96b9701f47564f86","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":[],"5f4e87790277826a2aea119328600dfb07761f32":["1da8d55113b689b06716246649de6f62430f15c0","8b61dd7a57cd877fdc056d71912c8813a4c2d4e6"],"2553b00f699380c64959ccb27991289aae87be2e":["c220849f876de24a79f756f65b3eb045db59f63f","090a0320e4de4a3674376aef96b9701f47564f86"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["5f4e87790277826a2aea119328600dfb07761f32","cd00dd91853514614379b0e680d65bd19cac0f30"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["c220849f876de24a79f756f65b3eb045db59f63f","090a0320e4de4a3674376aef96b9701f47564f86"],"090a0320e4de4a3674376aef96b9701f47564f86":["c220849f876de24a79f756f65b3eb045db59f63f"],"cd00dd91853514614379b0e680d65bd19cac0f30":["8b61dd7a57cd877fdc056d71912c8813a4c2d4e6"],"1da8d55113b689b06716246649de6f62430f15c0":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8","ad94625fb8d088209f46650c8097196fec67f00c"],"c220849f876de24a79f756f65b3eb045db59f63f":["cd00dd91853514614379b0e680d65bd19cac0f30"],"8b61dd7a57cd877fdc056d71912c8813a4c2d4e6":["1da8d55113b689b06716246649de6f62430f15c0"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["2553b00f699380c64959ccb27991289aae87be2e"],"29ef99d61cda9641b6250bf9567329a6e65f901d":["cd00dd91853514614379b0e680d65bd19cac0f30","c220849f876de24a79f756f65b3eb045db59f63f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":["090a0320e4de4a3674376aef96b9701f47564f86"],"ad94625fb8d088209f46650c8097196fec67f00c":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b"],"868da859b43505d9d2a023bfeae6dd0c795f5295":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c220849f876de24a79f756f65b3eb045db59f63f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["c26f00b574427b55127e869b935845554afde1fa"]},"commit2Childs":{"893269407f5c988a4b2ee13c7ffc01ec43136c1d":["a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8"],"a89acb2b4321b599bbfa1e802c00c4dbbc8ee6b8":["1da8d55113b689b06716246649de6f62430f15c0"],"c26f00b574427b55127e869b935845554afde1fa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b":["ad94625fb8d088209f46650c8097196fec67f00c"],"5f4e87790277826a2aea119328600dfb07761f32":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a"],"2553b00f699380c64959ccb27991289aae87be2e":["c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a":["868da859b43505d9d2a023bfeae6dd0c795f5295"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"090a0320e4de4a3674376aef96b9701f47564f86":["c26f00b574427b55127e869b935845554afde1fa","2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","a258fbb26824fd104ed795e5d9033d2d040049ee"],"cd00dd91853514614379b0e680d65bd19cac0f30":["7c65bc241a96282ca59ae736b4ffb5b7e5eeb23a","c220849f876de24a79f756f65b3eb045db59f63f","29ef99d61cda9641b6250bf9567329a6e65f901d"],"1da8d55113b689b06716246649de6f62430f15c0":["5f4e87790277826a2aea119328600dfb07761f32","8b61dd7a57cd877fdc056d71912c8813a4c2d4e6"],"c220849f876de24a79f756f65b3eb045db59f63f":["2553b00f699380c64959ccb27991289aae87be2e","d083e83f225b11e5fdd900e83d26ddb385b6955c","090a0320e4de4a3674376aef96b9701f47564f86","29ef99d61cda9641b6250bf9567329a6e65f901d","868da859b43505d9d2a023bfeae6dd0c795f5295"],"8b61dd7a57cd877fdc056d71912c8813a4c2d4e6":["5f4e87790277826a2aea119328600dfb07761f32","cd00dd91853514614379b0e680d65bd19cac0f30"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"29ef99d61cda9641b6250bf9567329a6e65f901d":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["893269407f5c988a4b2ee13c7ffc01ec43136c1d"],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"ad94625fb8d088209f46650c8097196fec67f00c":["1da8d55113b689b06716246649de6f62430f15c0"],"868da859b43505d9d2a023bfeae6dd0c795f5295":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","29ef99d61cda9641b6250bf9567329a6e65f901d","a258fbb26824fd104ed795e5d9033d2d040049ee","868da859b43505d9d2a023bfeae6dd0c795f5295","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["3cdb369a6112bacd5f5fc1d4e022bed2f8bffb9b","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}