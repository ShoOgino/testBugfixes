{"path":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","commits":[{"id":"6ce825e9276493231308229152c48f755ce1a0a5","date":1348871483,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"/dev/null","sourceNew":"  /** Enumerates all paths in the automaton that also\n   *  intersect the FST, accumulating the FST end node and\n   *  output for each path. */\n  public static<T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst) throws IOException {\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n\n    queue.add(new Path<T>(a.getInitialState(),\n                          fst.getFirstArc(new FST.Arc<T>()),       \n                          fst.outputs.getNoOutput(),\n                          new IntsRef()));\n\n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    //System.out.println(\"fst/a intersect\");\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size()-1);\n      //System.out.println(\"  cycle path=\" + path);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n      }\n\n      IntsRef currentInput = path.input;\n      for(Transition t : path.state.getTransitions()) {\n        \n        // TODO: we can fix this if necessary:\n        if (t.getMin() != t.getMax()) {\n          throw new IllegalStateException(\"can only handle Transitions that match one character\");\n        }\n\n        //System.out.println(\"    t=\" + (char) t.getMin());\n\n        final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(), path.fstNode, scratchArc, fstReader);\n        if (nextArc != null) {\n          //System.out.println(\"      fst matches\");\n          // Path continues:\n          IntsRef newInput = new IntsRef(currentInput.length + 1);\n          newInput.copyInts(currentInput);\n          newInput.ints[currentInput.length] = t.getMin();\n          newInput.length = currentInput.length + 1;\n\n          queue.add(new Path<T>(t.getDest(),\n                                new FST.Arc<T>().copyFrom(nextArc),\n                                fst.outputs.add(path.output, nextArc.output),\n                                newInput));\n        }\n      }\n    }\n\n    return endNodes;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc41b743423981e7ec17a024ce7e107096e472fe","date":1349975327,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * nocommit javadoc\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst) throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        continue;\n      }\n//      System.out.println(UnicodeUtil.newString(path.input.ints, path.input.offset, path.input.length));\n\n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        \n        if (t.getMin() == t.getMax()) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n//            if (t.getDest().isAccept()) {\n//              System.out.println(UnicodeUtil.newString(newInput.ints, newInput.offset, newInput.length));              \n//            }\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: \n          // if we accept the entire range possible in the FST (ie. 0 to 256)\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the\n          // ranges and terminate early here?\n          FST.Arc<T> nextArc = Util.readCeilArc(t.getMin(), fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= t.getMax()) {\n            assert nextArc.label <= t.getMax();\n            assert nextArc.label >= t.getMin() : nextArc.label + \" \"\n                + t.getMin();\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n//            if (t.getDest().isAccept()) {\n//              System.out.println(UnicodeUtil.newString(newInput.ints, newInput.offset, newInput.length));              \n//            }\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    //System.out.println();\n    \n    for (Path<T> path2 : endNodes) {\n      if (\"poales\".equals(UnicodeUtil.newString(path2.input.ints, path2.input.offset, path2.input.length)))\n        System.out.println(UnicodeUtil.newString(path2.input.ints, path2.input.offset, path2.input.length));\n    }\n      return endNodes;\n    }\n\n","sourceOld":"  /** Enumerates all paths in the automaton that also\n   *  intersect the FST, accumulating the FST end node and\n   *  output for each path. */\n  public static<T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst) throws IOException {\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n\n    queue.add(new Path<T>(a.getInitialState(),\n                          fst.getFirstArc(new FST.Arc<T>()),       \n                          fst.outputs.getNoOutput(),\n                          new IntsRef()));\n\n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    //System.out.println(\"fst/a intersect\");\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size()-1);\n      //System.out.println(\"  cycle path=\" + path);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n      }\n\n      IntsRef currentInput = path.input;\n      for(Transition t : path.state.getTransitions()) {\n        \n        // TODO: we can fix this if necessary:\n        if (t.getMin() != t.getMax()) {\n          throw new IllegalStateException(\"can only handle Transitions that match one character\");\n        }\n\n        //System.out.println(\"    t=\" + (char) t.getMin());\n\n        final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(), path.fstNode, scratchArc, fstReader);\n        if (nextArc != null) {\n          //System.out.println(\"      fst matches\");\n          // Path continues:\n          IntsRef newInput = new IntsRef(currentInput.length + 1);\n          newInput.copyInts(currentInput);\n          newInput.ints[currentInput.length] = t.getMin();\n          newInput.length = currentInput.length + 1;\n\n          queue.add(new Path<T>(t.getDest(),\n                                new FST.Arc<T>().copyFrom(nextArc),\n                                fst.outputs.add(path.output, nextArc.output),\n                                newInput));\n        }\n      }\n    }\n\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8","date":1350576194,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO:\n          // if we accept the entire range possible in the FST (ie. 0 to 256)\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the\n          // ranges and terminate early here?\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * nocommit javadoc\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst) throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        continue;\n      }\n//      System.out.println(UnicodeUtil.newString(path.input.ints, path.input.offset, path.input.length));\n\n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        \n        if (t.getMin() == t.getMax()) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n//            if (t.getDest().isAccept()) {\n//              System.out.println(UnicodeUtil.newString(newInput.ints, newInput.offset, newInput.length));              \n//            }\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: \n          // if we accept the entire range possible in the FST (ie. 0 to 256)\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the\n          // ranges and terminate early here?\n          FST.Arc<T> nextArc = Util.readCeilArc(t.getMin(), fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= t.getMax()) {\n            assert nextArc.label <= t.getMax();\n            assert nextArc.label >= t.getMin() : nextArc.label + \" \"\n                + t.getMin();\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n//            if (t.getDest().isAccept()) {\n//              System.out.println(UnicodeUtil.newString(newInput.ints, newInput.offset, newInput.length));              \n//            }\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    //System.out.println();\n    \n    for (Path<T> path2 : endNodes) {\n      if (\"poales\".equals(UnicodeUtil.newString(path2.input.ints, path2.input.offset, path2.input.length)))\n        System.out.println(UnicodeUtil.newString(path2.input.ints, path2.input.offset, path2.input.length));\n    }\n      return endNodes;\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e70d31b054fdad6f9d128fd421df6506f724b91","date":1350995421,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO:\n          // if we accept the entire range possible in the FST (ie. 0 to 256)\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the\n          // ranges and terminate early here?\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","date":1351615637,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /** Enumerates all paths in the automaton that also\n   *  intersect the FST, accumulating the FST end node and\n   *  output for each path. */\n  public static<T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst) throws IOException {\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n\n    queue.add(new Path<T>(a.getInitialState(),\n                          fst.getFirstArc(new FST.Arc<T>()),       \n                          fst.outputs.getNoOutput(),\n                          new IntsRef()));\n\n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n\n    //System.out.println(\"fst/a intersect\");\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size()-1);\n      //System.out.println(\"  cycle path=\" + path);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n      }\n\n      IntsRef currentInput = path.input;\n      for(Transition t : path.state.getTransitions()) {\n        \n        // TODO: we can fix this if necessary:\n        if (t.getMin() != t.getMax()) {\n          throw new IllegalStateException(\"can only handle Transitions that match one character\");\n        }\n\n        //System.out.println(\"    t=\" + (char) t.getMin());\n\n        final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(), path.fstNode, scratchArc, fstReader);\n        if (nextArc != null) {\n          //System.out.println(\"      fst matches\");\n          // Path continues:\n          IntsRef newInput = new IntsRef(currentInput.length + 1);\n          newInput.copyInts(currentInput);\n          newInput.ints[currentInput.length] = t.getMin();\n          newInput.length = currentInput.length + 1;\n\n          queue.add(new Path<T>(t.getDest(),\n                                new FST.Arc<T>().copyFrom(nextArc),\n                                fst.outputs.add(path.output, nextArc.output),\n                                newInput));\n        }\n      }\n    }\n\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"82557a475db3e0849171dc0be5b02e3ae0745ddb","date":1358195918,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c4015cd39dff8d4dec562d909f9766debac53aa6","date":1358548736,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader(0);\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<Path<T>>();\n    final List<Path<T>> endNodes = new ArrayList<Path<T>>();\n    queue.add(new Path<T>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<T>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<T>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"75ac8571c2d82c574e446c3729251b994c69a55c","date":1402523781,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert BasicOperations.isDeterministic(a);\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    LightAutomaton.Transition t = new LightAutomaton.Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4ca1c732df8923f5624f6c06b1dcca9e69d98c96","date":1402957391,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(LightAutomaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(LightAutomaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5c84485629d80d203608e8975a1139de9933cc38","date":1403166128,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    queue.add(new Path<>(a.getInitialState(), fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n    \n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (path.state.isAccept()) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      for (Transition t : path.state.getTransitions()) {\n        final int min = t.getMin();\n        final int max = t.getMax();\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.getMin(),\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.getMin();\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.getDest(), new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRefBuilder()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRefBuilder currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(t.min);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(nextArc.label);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRef()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRef currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = t.min;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRef newInput = new IntsRef(currentInput.length + 1);\n            newInput.copyInts(currentInput);\n            newInput.ints[currentInput.length] = nextArc.label;\n            newInput.length = currentInput.length + 1;\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":["6ce825e9276493231308229152c48f755ce1a0a5","cc41b743423981e7ec17a024ce7e107096e472fe","75ac8571c2d82c574e446c3729251b994c69a55c"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"54204c8a3ca26aeafd273139fc29baf70d0f6786","date":1564170395,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRefBuilder()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRefBuilder currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(t.min);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output()), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label() <= max) {\n            assert nextArc.label() <=  max;\n            assert nextArc.label() >= min : nextArc.label() + \" \"\n                + min;\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(nextArc.label());\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output()), newInput));\n            final int label = nextArc.label(); // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label() : \"last: \" + label\n                + \" next: \" + nextArc.label();\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRefBuilder()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRefBuilder currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(t.min);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(nextArc.label);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f8061ddd97f3352007d927dae445884a6f3d857b","date":1564988276,"type":3,"author":"Atri Sharma","isMerge":true,"pathNew":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","pathOld":"lucene/suggest/src/java/org/apache/lucene/search/suggest/analyzing/FSTUtil#[T]_intersectPrefixPaths(Automaton,FST[T]).mjava","sourceNew":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRefBuilder()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRefBuilder currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(t.min);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output()), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label() <= max) {\n            assert nextArc.label() <=  max;\n            assert nextArc.label() >= min : nextArc.label() + \" \"\n                + min;\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(nextArc.label());\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output()), newInput));\n            final int label = nextArc.label(); // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label() : \"last: \" + label\n                + \" next: \" + nextArc.label();\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","sourceOld":"  /**\n   * Enumerates all minimal prefix paths in the automaton that also intersect the FST,\n   * accumulating the FST end node and output for each path.\n   */\n  public static <T> List<Path<T>> intersectPrefixPaths(Automaton a, FST<T> fst)\n      throws IOException {\n    assert a.isDeterministic();\n    final List<Path<T>> queue = new ArrayList<>();\n    final List<Path<T>> endNodes = new ArrayList<>();\n    if (a.getNumStates() == 0) {\n      return endNodes;\n    }\n\n    queue.add(new Path<>(0, fst\n        .getFirstArc(new FST.Arc<T>()), fst.outputs.getNoOutput(),\n        new IntsRefBuilder()));\n    \n    final FST.Arc<T> scratchArc = new FST.Arc<>();\n    final FST.BytesReader fstReader = fst.getBytesReader();\n\n    Transition t = new Transition();\n\n    while (queue.size() != 0) {\n      final Path<T> path = queue.remove(queue.size() - 1);\n      if (a.isAccept(path.state)) {\n        endNodes.add(path);\n        // we can stop here if we accept this path,\n        // we accept all further paths too\n        continue;\n      }\n      \n      IntsRefBuilder currentInput = path.input;\n      int count = a.initTransition(path.state, t);\n      for (int i=0;i<count;i++) {\n        a.getNextTransition(t);\n        final int min = t.min;\n        final int max = t.max;\n        if (min == max) {\n          final FST.Arc<T> nextArc = fst.findTargetArc(t.min,\n              path.fstNode, scratchArc, fstReader);\n          if (nextArc != null) {\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(t.min);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n          }\n        } else {\n          // TODO: if this transition's TO state is accepting, and\n          // it accepts the entire range possible in the FST (ie. 0 to 255),\n          // we can simply use the prefix as the accepted state instead of\n          // looking up all the ranges and terminate early\n          // here.  This just shifts the work from one queue\n          // (this one) to another (the completion search\n          // done in AnalyzingSuggester).\n          FST.Arc<T> nextArc = Util.readCeilArc(min, fst, path.fstNode,\n              scratchArc, fstReader);\n          while (nextArc != null && nextArc.label <= max) {\n            assert nextArc.label <=  max;\n            assert nextArc.label >= min : nextArc.label + \" \"\n                + min;\n            final IntsRefBuilder newInput = new IntsRefBuilder();\n            newInput.copyInts(currentInput.get());\n            newInput.append(nextArc.label);\n            queue.add(new Path<>(t.dest, new FST.Arc<T>()\n                .copyFrom(nextArc), fst.outputs\n                .add(path.output, nextArc.output), newInput));\n            final int label = nextArc.label; // used in assert\n            nextArc = nextArc.isLast() ? null : fst.readNextRealArc(nextArc,\n                fstReader);\n            assert nextArc == null || label < nextArc.label : \"last: \" + label\n                + \" next: \" + nextArc.label;\n          }\n        }\n      }\n    }\n    return endNodes;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"75ac8571c2d82c574e446c3729251b994c69a55c":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["82557a475db3e0849171dc0be5b02e3ae0745ddb"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"c4015cd39dff8d4dec562d909f9766debac53aa6":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","82557a475db3e0849171dc0be5b02e3ae0745ddb"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["5c84485629d80d203608e8975a1139de9933cc38"],"f8061ddd97f3352007d927dae445884a6f3d857b":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["6ce825e9276493231308229152c48f755ce1a0a5","1e70d31b054fdad6f9d128fd421df6506f724b91"],"cc41b743423981e7ec17a024ce7e107096e472fe":["6ce825e9276493231308229152c48f755ce1a0a5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["75ac8571c2d82c574e446c3729251b994c69a55c"],"6ce825e9276493231308229152c48f755ce1a0a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"1e70d31b054fdad6f9d128fd421df6506f724b91":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"5c84485629d80d203608e8975a1139de9933cc38":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["cc41b743423981e7ec17a024ce7e107096e472fe"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["54204c8a3ca26aeafd273139fc29baf70d0f6786"]},"commit2Childs":{"75ac8571c2d82c574e446c3729251b994c69a55c":["4ca1c732df8923f5624f6c06b1dcca9e69d98c96"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["75ac8571c2d82c574e446c3729251b994c69a55c","5c84485629d80d203608e8975a1139de9933cc38"],"82557a475db3e0849171dc0be5b02e3ae0745ddb":["634f330c54fd3f9f491d52036dc3f40b4f4d8934","c4015cd39dff8d4dec562d909f9766debac53aa6"],"c4015cd39dff8d4dec562d909f9766debac53aa6":[],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f8061ddd97f3352007d927dae445884a6f3d857b","54204c8a3ca26aeafd273139fc29baf70d0f6786"],"f8061ddd97f3352007d927dae445884a6f3d857b":[],"54204c8a3ca26aeafd273139fc29baf70d0f6786":["f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b":["82557a475db3e0849171dc0be5b02e3ae0745ddb","c4015cd39dff8d4dec562d909f9766debac53aa6"],"cc41b743423981e7ec17a024ce7e107096e472fe":["212b08d3e511c7623bf4c1af7a834f0d0bee0dc8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["6ce825e9276493231308229152c48f755ce1a0a5"],"4ca1c732df8923f5624f6c06b1dcca9e69d98c96":["5c84485629d80d203608e8975a1139de9933cc38"],"6ce825e9276493231308229152c48f755ce1a0a5":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b","cc41b743423981e7ec17a024ce7e107096e472fe"],"1e70d31b054fdad6f9d128fd421df6506f724b91":["4f3db1dca4ec6d06e771211e9f7c4ae5d8e5758b"],"5c84485629d80d203608e8975a1139de9933cc38":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"212b08d3e511c7623bf4c1af7a834f0d0bee0dc8":["1e70d31b054fdad6f9d128fd421df6506f724b91"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c4015cd39dff8d4dec562d909f9766debac53aa6","f8061ddd97f3352007d927dae445884a6f3d857b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}