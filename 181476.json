{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","commits":[{"id":"06805da26538ed636bd89b10c2699cc3834032ae","date":1395132972,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. This method can be used to 'unset' a document's\n   * value by passing {@code null} as the new value. Also, you can only update\n   * fields that already exist in the index, not add new fields through this\n   * method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * <p>\n   * <b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateBinaryDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30d3ec601cbd11cf056b7336f0e03f688ebcd9f7","date":1401116050,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * <p>\n   * <b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateBinaryDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. This method can be used to 'unset' a document's\n   * value by passing {@code null} as the new value. Also, you can only update\n   * fields that already exist in the index, not add new fields through this\n   * method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * <p>\n   * <b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateBinaryDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"70285ef5917fa2c8feec026d4be4d9c20fa89162","date":1401366288,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * <p>\n   * <b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * <p>\n   * <b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateBinaryDocValue(term, field, value)) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * <p>\n   * <b>NOTE:</b> if this method hits an OutOfMemoryError you should immediately\n   * close the writer. See <a href=\"#OOME\">above</a> for details.\n   * </p>\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      handleOOM(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":["c48871ed951104729f5e17a8ee1091b43fa18980"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c48871ed951104729f5e17a8ee1091b43fa18980","date":1446564542,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (OutOfMemoryError oom) {\n      tragicEvent(oom, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":["949847c0040cd70a68222d526cb0da7bf6cbb3c2","06805da26538ed636bd89b10c2699cc3834032ae"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"23a29a4862e38cc3b9bff14a888901c7c878885b","date":1464135767,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"16ebfabc294f23b88b6a39722a02c9d39b353195","date":1464343867,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6483e4260c08168709c02238ae083a51519a28dd","date":1465117546,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"191128ac5b85671b1671e2c857437694283b6ebf","date":1465297861,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public void updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      if (docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value))) {\n        processEvents(true, false);\n      }\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true, false);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n\n      // dead code but javac disagrees:\n      return -1;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a9b6ed5e493fd780f940f307e17673df92a4419","date":1583776063,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#updateBinaryDocValue(Term,String,BytesRef).mjava","sourceNew":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      return maybeProcessEvents(docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value)));\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n      throw tragedy;\n    }\n  }\n\n","sourceOld":"  /**\n   * Updates a document's {@link BinaryDocValues} for <code>field</code> to the\n   * given <code>value</code>. You can only update fields that already exist in\n   * the index, not add new fields through this method.\n   * \n   * <p>\n   * <b>NOTE:</b> this method currently replaces the existing value of all\n   * affected documents with the new value.\n   * \n   * @param term\n   *          the term to identify the document(s) to be updated\n   * @param field\n   *          field name of the {@link BinaryDocValues} field\n   * @param value\n   *          new value for the field\n   *\n   * @return The <a href=\"#sequence_number\">sequence number</a>\n   * for this operation\n   *\n   * @throws CorruptIndexException\n   *           if the index is corrupt\n   * @throws IOException\n   *           if there is a low-level IO error\n   */\n  public long updateBinaryDocValue(Term term, String field, BytesRef value) throws IOException {\n    ensureOpen();\n    if (value == null) {\n      throw new IllegalArgumentException(\"cannot update a field to a null value: \" + field);\n    }\n    if (!globalFieldNumberMap.contains(field, DocValuesType.BINARY)) {\n      throw new IllegalArgumentException(\"can only update existing binary-docvalues fields!\");\n    }\n    try {\n      long seqNo = docWriter.updateDocValues(new BinaryDocValuesUpdate(term, field, value));\n      if (seqNo < 0) {\n        seqNo = -seqNo;\n        processEvents(true);\n      }\n      return seqNo;\n    } catch (VirtualMachineError tragedy) {\n      tragicEvent(tragedy, \"updateBinaryDocValue\");\n      throw tragedy;\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["191128ac5b85671b1671e2c857437694283b6ebf"],"0a9b6ed5e493fd780f940f307e17673df92a4419":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"06805da26538ed636bd89b10c2699cc3834032ae":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"23a29a4862e38cc3b9bff14a888901c7c878885b":["c48871ed951104729f5e17a8ee1091b43fa18980"],"6483e4260c08168709c02238ae083a51519a28dd":["c48871ed951104729f5e17a8ee1091b43fa18980","16ebfabc294f23b88b6a39722a02c9d39b353195"],"191128ac5b85671b1671e2c857437694283b6ebf":["c48871ed951104729f5e17a8ee1091b43fa18980","6483e4260c08168709c02238ae083a51519a28dd"],"70285ef5917fa2c8feec026d4be4d9c20fa89162":["30d3ec601cbd11cf056b7336f0e03f688ebcd9f7"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["23a29a4862e38cc3b9bff14a888901c7c878885b"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["c48871ed951104729f5e17a8ee1091b43fa18980","191128ac5b85671b1671e2c857437694283b6ebf"],"c48871ed951104729f5e17a8ee1091b43fa18980":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"30d3ec601cbd11cf056b7336f0e03f688ebcd9f7":["06805da26538ed636bd89b10c2699cc3834032ae"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["70285ef5917fa2c8feec026d4be4d9c20fa89162"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0a9b6ed5e493fd780f940f307e17673df92a4419"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["0a9b6ed5e493fd780f940f307e17673df92a4419"],"0a9b6ed5e493fd780f940f307e17673df92a4419":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"06805da26538ed636bd89b10c2699cc3834032ae":["30d3ec601cbd11cf056b7336f0e03f688ebcd9f7"],"23a29a4862e38cc3b9bff14a888901c7c878885b":["16ebfabc294f23b88b6a39722a02c9d39b353195"],"6483e4260c08168709c02238ae083a51519a28dd":["191128ac5b85671b1671e2c857437694283b6ebf"],"191128ac5b85671b1671e2c857437694283b6ebf":["845b760a99e5f369fcd0a5d723a87b8def6a3f56","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"16ebfabc294f23b88b6a39722a02c9d39b353195":["6483e4260c08168709c02238ae083a51519a28dd"],"70285ef5917fa2c8feec026d4be4d9c20fa89162":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"c48871ed951104729f5e17a8ee1091b43fa18980":["23a29a4862e38cc3b9bff14a888901c7c878885b","6483e4260c08168709c02238ae083a51519a28dd","191128ac5b85671b1671e2c857437694283b6ebf","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["06805da26538ed636bd89b10c2699cc3834032ae"],"30d3ec601cbd11cf056b7336f0e03f688ebcd9f7":["70285ef5917fa2c8feec026d4be4d9c20fa89162"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["c48871ed951104729f5e17a8ee1091b43fa18980"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}