{"path":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","commits":[{"id":"96adbab674ae121f8b6b3e10474070b4bd97a219","date":1373614333,"type":0,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"/dev/null","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrServer server = new HttpSolrServer(coreUrl);\n      QueryResponse response = server.query(query);\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["344b0840364d990b29b97467bfcc766ff8325d11"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":0,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"/dev/null","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrServer server = new HttpSolrServer(coreUrl);\n      QueryResponse response = server.query(query);\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2d750082a4223c20902ef11ff6a9831d55738ea4","date":1382309916,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrServer server = new HttpSolrServer(coreUrl);\n      QueryResponse response;\n      try {\n        response = server.query(query);\n      } finally {\n        server.shutdown();\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrServer server = new HttpSolrServer(coreUrl);\n      QueryResponse response = server.query(query);\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrClient client = new HttpSolrClient(coreUrl);\n      QueryResponse response;\n      try {\n        response = client.query(query);\n      } finally {\n        client.shutdown();\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrServer server = new HttpSolrServer(coreUrl);\n      QueryResponse response;\n      try {\n        response = server.query(query);\n      } finally {\n        server.shutdown();\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"cc3b13b430571c2e169f98fe38e1e7666f88522d","date":1422446157,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = new HttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      HttpSolrClient client = new HttpSolrClient(coreUrl);\n      QueryResponse response;\n      try {\n        response = client.query(query);\n      } finally {\n        client.shutdown();\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","date":1460069869,"type":3,"author":"Anshum Gupta","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = new HttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","date":1460110033,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = new HttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"344b0840364d990b29b97467bfcc766ff8325d11","date":1501574100,"type":3,"author":"Cao Manh Dat","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION).getSlice(shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION).getSlice(shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getSlice(AbstractDistribZkTestBase.DEFAULT_COLLECTION, shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6146c07c0dee1ae1e42926167acd127fed5ef59d","date":1516129420,"type":5,"author":"Varun Thacker","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION).getSlice(shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION).getSlice(shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b94236357aaa22b76c10629851fe4e376e0cea82","date":1516710914,"type":5,"author":"Karl Wright","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/api/collections/ShardSplitTest#checkSubShardConsistency(String).mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/ShardSplitTest#checkSubShardConsistency(String).mjava","sourceNew":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION).getSlice(shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","sourceOld":"  protected void checkSubShardConsistency(String shard) throws SolrServerException, IOException {\n    SolrQuery query = new SolrQuery(\"*:*\").setRows(1000).setFields(\"id\", \"_version_\");\n    query.set(\"distrib\", false);\n\n    ClusterState clusterState = cloudClient.getZkStateReader().getClusterState();\n    Slice slice = clusterState.getCollection(AbstractDistribZkTestBase.DEFAULT_COLLECTION).getSlice(shard);\n    long[] numFound = new long[slice.getReplicasMap().size()];\n    int c = 0;\n    for (Replica replica : slice.getReplicas()) {\n      String coreUrl = new ZkCoreNodeProps(replica).getCoreUrl();\n      QueryResponse response;\n      try (HttpSolrClient client = getHttpSolrClient(coreUrl)) {\n        response = client.query(query);\n      }\n      numFound[c++] = response.getResults().getNumFound();\n      log.info(\"Shard: \" + shard + \" Replica: {} has {} docs\", coreUrl, String.valueOf(response.getResults().getNumFound()));\n      assertTrue(\"Shard: \" + shard + \" Replica: \" + coreUrl + \" has 0 docs\", response.getResults().getNumFound() > 0);\n    }\n    for (int i = 0; i < slice.getReplicasMap().size(); i++) {\n      assertEquals(shard + \" is not consistent\", numFound[0], numFound[i]);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"b94236357aaa22b76c10629851fe4e376e0cea82":["344b0840364d990b29b97467bfcc766ff8325d11","6146c07c0dee1ae1e42926167acd127fed5ef59d"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","96adbab674ae121f8b6b3e10474070b4bd97a219"],"344b0840364d990b29b97467bfcc766ff8325d11":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["344b0840364d990b29b97467bfcc766ff8325d11"],"bafca15d8e408346a67f4282ad1143b88023893b":["2d750082a4223c20902ef11ff6a9831d55738ea4"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b","344b0840364d990b29b97467bfcc766ff8325d11"],"96adbab674ae121f8b6b3e10474070b4bd97a219":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"2d750082a4223c20902ef11ff6a9831d55738ea4":["96adbab674ae121f8b6b3e10474070b4bd97a219"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["cc3b13b430571c2e169f98fe38e1e7666f88522d","e3c94a8b8bf47db4f968d9ae510ec8bbe1372088"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["bafca15d8e408346a67f4282ad1143b88023893b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b94236357aaa22b76c10629851fe4e376e0cea82"]},"commit2Childs":{"b94236357aaa22b76c10629851fe4e376e0cea82":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"344b0840364d990b29b97467bfcc766ff8325d11":["b94236357aaa22b76c10629851fe4e376e0cea82","6146c07c0dee1ae1e42926167acd127fed5ef59d","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"e3c94a8b8bf47db4f968d9ae510ec8bbe1372088":["5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"6146c07c0dee1ae1e42926167acd127fed5ef59d":["b94236357aaa22b76c10629851fe4e376e0cea82"],"bafca15d8e408346a67f4282ad1143b88023893b":["cc3b13b430571c2e169f98fe38e1e7666f88522d"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"96adbab674ae121f8b6b3e10474070b4bd97a219":["37a0f60745e53927c4c876cfe5b5a58170f0646c","2d750082a4223c20902ef11ff6a9831d55738ea4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["37a0f60745e53927c4c876cfe5b5a58170f0646c","96adbab674ae121f8b6b3e10474070b4bd97a219"],"5bdaf2cee03ff78b0a0cbf23df0095a3590b493b":["344b0840364d990b29b97467bfcc766ff8325d11","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"2d750082a4223c20902ef11ff6a9831d55738ea4":["bafca15d8e408346a67f4282ad1143b88023893b"],"cc3b13b430571c2e169f98fe38e1e7666f88522d":["e3c94a8b8bf47db4f968d9ae510ec8bbe1372088","5bdaf2cee03ff78b0a0cbf23df0095a3590b493b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}