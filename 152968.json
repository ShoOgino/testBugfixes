{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            _TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            _TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            _TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            _TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            _TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            _TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11c6df42fb3eba174c3ca0d9a5194eaecd893b77","date":1465931757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n    \n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerMaxSize = 100;\n      private double clientExRate = 1.0, handlerExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n\n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          handlerDir.setMaxSizeInBytes(handlerMaxSize);\n          handlerDir.setRandomIOExceptionRateOnOpen(handlerExRate);\n          handlerDir.setRandomIOExceptionRate(handlerExRate);\n          handlerMaxSize *= 2;\n          handlerExRate /= 2;\n        } else {\n          // disable errors\n          handlerDir.setMaxSizeInBytes(0);\n          handlerDir.setRandomIOExceptionRate(0.0);\n          handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n        return dir;\n      }\n    };\n    \n    handler = new IndexReplicationHandler(handlerDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n    \n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          if (VERBOSE) {\n            System.out.println(\"hit exception during update: \" + t);\n            t.printStackTrace(System.out);\n          }\n          try {\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index consistency\n            TestUtil.checkIndex(handlerDir.getDelegate());\n          } catch (IOException e) {\n            // exceptions here are bad, don't ignore them\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"index\");\n\n    final Directory baseHandlerDir = handlerDir.getDelegate();\n    int numRevisions = atLeast(20);\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerDir);\n    }\n    \n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerDir.setMaxSizeInBytes(0);\n    handlerDir.setRandomIOExceptionRate(0.0);\n    handlerDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"6613659748fe4411a7dcf85266e55db1f95f7315":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["6613659748fe4411a7dcf85266e55db1f95f7315"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["6613659748fe4411a7dcf85266e55db1f95f7315","11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"]},"commit2Childs":{"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","19275ba31e621f6da1b83bf13af75233876fd3d4"],"6613659748fe4411a7dcf85266e55db1f95f7315":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}