{"path":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","commits":[{"id":"d4aa50b979cd392e00e5bc0f23f78cbd106cb968","date":1308150768,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","pathOld":"/dev/null","sourceNew":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        // TODO Java 1.6: pollFirst()\n        final MergedGroup<T> group = queue.first();\n        queue.remove(group);\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","date":1308291005,"type":0,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","pathOld":"/dev/null","sourceNew":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        // TODO Java 1.6: pollFirst()\n        final MergedGroup<T> group = queue.first();\n        queue.remove(group);\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d9b7b579125f96af579b1c85930f519dee4f32c3","date":1309436076,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","sourceNew":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        final MergedGroup<T> group = queue.pollFirst();\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","sourceOld":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        // TODO Java 1.6: pollFirst()\n        final MergedGroup<T> group = queue.first();\n        queue.remove(group);\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"817d8435e9135b756f08ce6710ab0baac51bdf88","date":1309986993,"type":3,"author":"Steven Rowe","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","sourceNew":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        final MergedGroup<T> group = queue.pollFirst();\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","sourceOld":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        // TODO Java 1.6: pollFirst()\n        final MergedGroup<T> group = queue.first();\n        queue.remove(group);\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d083e83f225b11e5fdd900e83d26ddb385b6955c","date":1310029438,"type":3,"author":"Simon Willnauer","isMerge":true,"pathNew":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","sourceNew":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        final MergedGroup<T> group = queue.pollFirst();\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","sourceOld":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        // TODO Java 1.6: pollFirst()\n        final MergedGroup<T> group = queue.first();\n        queue.remove(group);\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b89678825b68eccaf09e6ab71675fc0b0af1e099","date":1334669779,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","pathOld":"modules/grouping/src/java/org/apache/lucene/search/grouping/SearchGroup.GroupMerger#merge(List[Collection[SearchGroup[T]]],int,int).mjava","sourceNew":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        final MergedGroup<T> group = queue.pollFirst();\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","sourceOld":"    public Collection<SearchGroup<T>> merge(List<Collection<SearchGroup<T>>> shards, int offset, int topN) {\n\n      final int maxQueueSize = offset + topN;\n\n      //System.out.println(\"merge\");\n      // Init queue:\n      for(int shardIDX=0;shardIDX<shards.size();shardIDX++) {\n        final Collection<SearchGroup<T>> shard = shards.get(shardIDX);\n        if (!shard.isEmpty()) {\n          //System.out.println(\"  insert shard=\" + shardIDX);\n          updateNextGroup(maxQueueSize, new ShardIter<T>(shard, shardIDX));\n        }\n      }\n\n      // Pull merged topN groups:\n      final List<SearchGroup<T>> newTopGroups = new ArrayList<SearchGroup<T>>();\n\n      int count = 0;\n\n      while(queue.size() != 0) {\n        final MergedGroup<T> group = queue.pollFirst();\n        group.processed = true;\n        //System.out.println(\"  pop: shards=\" + group.shards + \" group=\" + (group.groupValue == null ? \"null\" : (((BytesRef) group.groupValue).utf8ToString())) + \" sortValues=\" + Arrays.toString(group.topValues));\n        if (count++ >= offset) {\n          final SearchGroup<T> newGroup = new SearchGroup<T>();\n          newGroup.groupValue = group.groupValue;\n          newGroup.sortValues = group.topValues;\n          newTopGroups.add(newGroup);\n          if (newTopGroups.size() == topN) {\n            break;\n          }\n        //} else {\n        // System.out.println(\"    skip < offset\");\n        }\n\n        // Advance all iters in this group:\n        for(ShardIter<T> shardIter : group.shards) {\n          updateNextGroup(maxQueueSize, shardIter);\n        }\n      }\n\n      if (newTopGroups.size() == 0) {\n        return null;\n      } else {\n        return newTopGroups;\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["d9b7b579125f96af579b1c85930f519dee4f32c3"],"d9b7b579125f96af579b1c85930f519dee4f32c3":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":["d4aa50b979cd392e00e5bc0f23f78cbd106cb968","d9b7b579125f96af579b1c85930f519dee4f32c3"],"817d8435e9135b756f08ce6710ab0baac51bdf88":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d9b7b579125f96af579b1c85930f519dee4f32c3"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b89678825b68eccaf09e6ab71675fc0b0af1e099"]},"commit2Childs":{"0a2903ea38ae3e636b93a08c52a5e37ae939cf6b":["817d8435e9135b756f08ce6710ab0baac51bdf88"],"b89678825b68eccaf09e6ab71675fc0b0af1e099":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d9b7b579125f96af579b1c85930f519dee4f32c3":["b89678825b68eccaf09e6ab71675fc0b0af1e099","d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d4aa50b979cd392e00e5bc0f23f78cbd106cb968"],"d4aa50b979cd392e00e5bc0f23f78cbd106cb968":["0a2903ea38ae3e636b93a08c52a5e37ae939cf6b","d9b7b579125f96af579b1c85930f519dee4f32c3","d083e83f225b11e5fdd900e83d26ddb385b6955c"],"d083e83f225b11e5fdd900e83d26ddb385b6955c":[],"817d8435e9135b756f08ce6710ab0baac51bdf88":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d083e83f225b11e5fdd900e83d26ddb385b6955c","817d8435e9135b756f08ce6710ab0baac51bdf88","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}