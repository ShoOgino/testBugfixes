{"path":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","commits":[{"id":"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","date":1342989037,"type":0,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    chaosMonkey.killJetty(shardToLeaderJetty.get(\"shard1\").jetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ca10c70cbce0d7ac8219a4adc23ed9efa79564fe","date":1342999969,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    chaosMonkey.killJetty(shardToLeaderJetty.get(\"shard1\").jetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    chaosMonkey.killJetty(shardToLeaderJetty.get(\"shard1\").jetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","date":1343059585,"type":0,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    chaosMonkey.killJetty(shardToLeaderJetty.get(\"shard1\").jetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"efee511ca1fb9a8711021d261526526cf3e84890","date":1343083460,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    JettySolrRunner leaderJetty = shardToLeaderJetty.get(\"shard1\").jetty;\n    SolrServer leaderClient = shardToLeaderClient.get(\"shard1\");\n    Set<JettySolrRunner> jetties = new HashSet<JettySolrRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i).jetty);\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    JettySolrRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.getDispatchFilter().getFilter()).getCores().getZkController().getZkStateReader().getCloudState().liveNodesContain(clientToInfo.get(new CloudSolrServerClient(leaderClient)).get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    chaosMonkey.killJetty(shardToLeaderJetty.get(\"shard1\").jetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6ef6348b84bf0f8a649826b69a70ac815ff560e2","date":1343106054,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    CloudSolrServerClient leaderClient = leaderJetty.client;\n    Set<JettySolrRunner> jetties = new HashSet<JettySolrRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i).jetty);\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    JettySolrRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.getDispatchFilter().getFilter()).getCores().getZkController().getZkStateReader().getCloudState().liveNodesContain(clientToInfo.get(leaderClient).get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    JettySolrRunner leaderJetty = shardToLeaderJetty.get(\"shard1\").jetty;\n    SolrServer leaderClient = shardToLeaderClient.get(\"shard1\");\n    Set<JettySolrRunner> jetties = new HashSet<JettySolrRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i).jetty);\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    JettySolrRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.getDispatchFilter().getFilter()).getCores().getZkController().getZkStateReader().getCloudState().liveNodesContain(clientToInfo.get(new CloudSolrServerClient(leaderClient)).get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"217c5e3cedf564c6d370670858e1b1edab16fcac","date":1343114420,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i));\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    CloudJettyRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter().getFilter());\n    \n    \n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.jetty.getDispatchFilter().getFilter())\n        .getCores().getZkController().getZkStateReader().getCloudState()\n        .liveNodesContain(leaderJetty.info.get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    CloudSolrServerClient leaderClient = leaderJetty.client;\n    Set<JettySolrRunner> jetties = new HashSet<JettySolrRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i).jetty);\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    JettySolrRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.getDispatchFilter().getFilter()).getCores().getZkController().getZkStateReader().getCloudState().liveNodesContain(clientToInfo.get(leaderClient).get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6948dfbf6c703c42e0d9831d5b2a1ce38e75abb6","date":1343134001,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i));\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    CloudJettyRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter().getFilter());\n    \n    \n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.jetty.getDispatchFilter().getFilter())\n        .getCores().getZkController().getZkStateReader().getCloudState()\n        .liveNodesContain(leaderJetty.info.get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i));\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    CloudJettyRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter().getFilter());\n    \n    \n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.jetty.getDispatchFilter().getFilter())\n        .getCores().getZkController().getZkStateReader().getCloudState()\n        .liveNodesContain(leaderJetty.info.get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"50ff0384c52eb23ed5f248f461676fd8c033c50f","date":1343188029,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i));\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    for (CloudJettyRunner cjetty : jetties) {\n      waitToSeeNotLive(((SolrDispatchFilter) cjetty.jetty.getDispatchFilter()\n          .getFilter()).getCores().getZkController().getZkStateReader(),\n          leaderJetty);\n    }\n    waitToSeeNotLive(cloudClient.getZkStateReader(), leaderJetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i));\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    CloudJettyRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter());\n    assertNotNull(upJetty.jetty.getDispatchFilter().getFilter());\n    \n    \n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.jetty.getDispatchFilter().getFilter())\n        .getCores().getZkController().getZkStateReader().getCloudState()\n        .liveNodesContain(leaderJetty.info.get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8a65836c18a62c7b1b404fcb1bba729fd4c29e81","date":1343190777,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    for (CloudJettyRunner cjetty : jetties) {\n      waitToSeeNotLive(((SolrDispatchFilter) cjetty.jetty.getDispatchFilter()\n          .getFilter()).getCores().getZkController().getZkStateReader(),\n          leaderJetty);\n    }\n    waitToSeeNotLive(cloudClient.getZkStateReader(), leaderJetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i));\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    for (CloudJettyRunner cjetty : jetties) {\n      waitToSeeNotLive(((SolrDispatchFilter) cjetty.jetty.getDispatchFilter()\n          .getFilter()).getCores().getZkController().getZkStateReader(),\n          leaderJetty);\n    }\n    waitToSeeNotLive(cloudClient.getZkStateReader(), leaderJetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","date":1343203827,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    for (CloudJettyRunner cjetty : jetties) {\n      waitToSeeNotLive(((SolrDispatchFilter) cjetty.jetty.getDispatchFilter()\n          .getFilter()).getCores().getZkController().getZkStateReader(),\n          leaderJetty);\n    }\n    waitToSeeNotLive(cloudClient.getZkStateReader(), leaderJetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    JettySolrRunner leaderJetty = shardToLeaderJetty.get(\"shard1\").jetty;\n    SolrServer leaderClient = shardToLeaderClient.get(\"shard1\");\n    Set<JettySolrRunner> jetties = new HashSet<JettySolrRunner>();\n    for (int i = 0; i < shardCount; i++) {\n      jetties.add(shardToJetty.get(\"shard1\").get(i).jetty);\n    }\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    JettySolrRunner upJetty = jetties.iterator().next();\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    int tries = 0;\n    while (((SolrDispatchFilter) upJetty.getDispatchFilter().getFilter()).getCores().getZkController().getZkStateReader().getCloudState().liveNodesContain(clientToInfo.get(new CloudSolrServerClient(leaderClient)).get(ZkStateReader.NODE_NAME_PROP))) {\n      if (tries++ == 120) {\n        fail(\"Shard still reported as live in zk\");\n      }\n      Thread.sleep(1000);\n    }\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ce9115008b2600dda16a6765e06b6b380458c02f","date":1343435746,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    \n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping the leader and one node\n    assertEquals(1, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    \n    // TODO: for now, we just check consistency -\n    // there will be 305 or 5 docs depending on who\n    // becomes the leader - eventually we want that to\n    // always be the 305\n    //checkShardConsistency(true, true);\n    checkShardConsistency(false, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n\n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    for (CloudJettyRunner cjetty : jetties) {\n      waitToSeeNotLive(((SolrDispatchFilter) cjetty.jetty.getDispatchFilter()\n          .getFilter()).getCores().getZkController().getZkStateReader(),\n          leaderJetty);\n    }\n    waitToSeeNotLive(cloudClient.getZkStateReader(), leaderJetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02","bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"aba371508186796cc6151d8223a5b4e16d02e26e","date":1343474871,"type":0,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    \n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping the leader and one node\n    assertEquals(1, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    \n    // TODO: for now, we just check consistency -\n    // there will be 305 or 5 docs depending on who\n    // becomes the leader - eventually we want that to\n    // always be the 305\n    //checkShardConsistency(true, true);\n    checkShardConsistency(false, true);\n    \n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b49f59235aa7d5bf40a55e23dc40cbc777d7506f","date":1343675311,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    \n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping the leader and one node\n    assertEquals(1, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    \n    // TODO: for now, we just check consistency -\n    // there will be 305 or 5 docs depending on who\n    // becomes the leader - eventually we want that to\n    // always be the 305\n    //checkShardConsistency(true, true);\n    checkShardConsistency(false, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    // something wrong with this?\n    //del(\"*:*\");\n    \n    List<String> skipServers = new ArrayList<String>();\n    \n    indexDoc(skipServers, id, 0, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, 1, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, 2, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id, 3, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n\n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToClient.get(\"shard1\").get(2)).getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    skipServers = new ArrayList<String>();\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(random().nextInt(shardCount)).url + \"/\");\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, 4, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    // kill the leader - new leader could have all the docs or be missing one\n    chaosMonkey.killJetty(shardToLeaderJetty.get(\"shard1\").jetty);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3f767f8c99eaedb984df754fe61f21c5de260f94","date":1344105153,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8fd5be977c105554c6a7b68afcdbc511439723ab","date":1344115570,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2c30e4c1cee08b3b229a77991882594fe7250b66","date":1344448871,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","bugFix":null,"bugIntro":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInCloudState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    \n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping the leader and one node\n    assertEquals(1, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInCloudState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    \n    // TODO: for now, we just check consistency -\n    // there will be 305 or 5 docs depending on who\n    // becomes the leader - eventually we want that to\n    // always be the 305\n    //checkShardConsistency(true, true);\n    checkShardConsistency(false, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c7869f64c874ebf7f317d22c00baf2b6857797a6","date":1344856617,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut();\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut();\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut();\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"480e4f53dbc60fbc1565d29c062ec8681c863d7f","date":1351353263,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(30);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abd13178766ec31053e070b800f34110130c6151","date":1351355196,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(45);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(30);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f2126b84bd093fa3d921582a109a0ee578c28126","date":1351522501,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(45);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a69439d0df009e0bb0038d1e427159f449dd670d","date":1355704683,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(45);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"85aa27528f7991962c33686e81d50246b97fb08d","date":1355850370,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(100);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(\n        \"shard1 shoul have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"042c474f8983c7bfede807d97ad9faf73ff694cc","date":1355859039,"type":3,"author":"Yonik Seeley","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(100);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(\n        \"shard1 shoul have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(100);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(\n        \"shard1 shoul have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bea41289768794cfe5678cbc6d737dcd240670e5","date":1355936037,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    \n    if (shardFailMessage == null) {\n      // try again\n      Thread.sleep(3000);\n      shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    }\n    \n    assertNotNull(\n        \"shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(100);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(\n        \"shard1 shoul have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"de2d2f1684b6eb1f7ede1b1ad13a34fef0dd6b40","date":1356102353,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    \n    if (shardFailMessage == null) {\n      // try again\n      Thread.sleep(3000);\n      shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    }\n    \n    assertNotNull(\n        \"shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    // we are careful to make sure the downed node is no longer in the state,\n    // because on some systems (especially freebsd w/ blackhole enabled), trying\n    // to talk to a downed node causes grief\n    waitToSeeDownInClusterState(leaderJetty, jetties);\n\n    waitForThingsToLevelOut(45);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  one nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = checkShardConsistency(\"shard1\", true);\n    assertNotNull(shardFailMessage);\n    \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitToSeeDownInClusterState(leaderJetty, jetties);\n    \n    Thread.sleep(4000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"941acc1dc75cf5303cef02bda58645d6122fdba4","date":1360264810,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02","date":1360357765,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    // give a moment to be sure it has started recovering\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(15);\n    waitForRecoveriesToFinish(false);\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":["ce9115008b2600dda16a6765e06b6b380458c02f","2c30e4c1cee08b3b229a77991882594fe7250b66","941acc1dc75cf5303cef02bda58645d6122fdba4"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d93914268f50e71bc43bc1aeefb7d21573ea1df","date":1360458703,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\" + leaderJetty.url +\n        \"skip list:\" + skipServers,\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent\",\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ff47835661df91a174abb056b009b53fba16a26","date":1360462074,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, skipServers.get(0)));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\" + leaderJetty.url +\n        \"skip list:\" + skipServers,\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<String> skipServers = new ArrayList<String>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1).url + \"/\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2).url + \"/\");\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, null));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\" + leaderJetty.url +\n        \"skip list:\" + skipServers,\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d16312ffd2ca7e3a5117030cfa8f105f00a32ddf","date":1361395023,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\" + leaderJetty.url +\n        \"skip list:\" + skipServers,\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, skipServers.get(0)));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\" + leaderJetty.url +\n        \"skip list:\" + skipServers,\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"930f2ead620d01f86f471a8f0896c0e2d9234eca","date":1363385389,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\" + leaderJetty.url +\n        \"skip list:\" + skipServers,\n        shardFailMessage); \n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"76530c83bab98ecf28c61c2b68a7151a946298f2","date":1363923567,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n    //System.out.println(\"leader:\" + leaderJetty.url);\n    //System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"849494cf2f3a96af5c8c84995108ddd8456fcd04","date":1372277913,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"37a0f60745e53927c4c876cfe5b5a58170f0646c","date":1373994005,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(15);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3c3e46d3417c353d7be14509cfab11b315927fe","date":1382292560,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(60000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e415cc960b0e7b8c945b0ed0004272b8435433ac","date":1384648739,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(15000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(60000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"74f45af4339b0daf7a95c820ab88c1aea74fbce0","date":1387475327,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(15000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    baseServer.setConnectionTimeout(15000);\n    baseServer.setSoTimeout(60000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0ab4f87da977b06208c737a8e360752d3290440b","date":1388363640,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(15000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(90);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<CloudJettyRunner>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<CloudJettyRunner>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4c7856260bc28f285ae7bfefa99b28db4dca6daf","date":1395253500,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5f6c494de6b7fddab42beeb839721ee126885db1","date":1395291794,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n\n    Thread.sleep(2000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillRecovered();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForThingsToLevelOut(120);\n    \n    Thread.sleep(2000);\n    \n    waitForRecoveriesToFinish(false);\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0962ba7d9ec0b488f485e768df5dd80b77b9f7ce","date":1397450839,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = compareResults(\n        controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound(),\n        cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertTrue(\"A test that compareResults is working correctly failed\",\n        shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    \n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4339eef0c1b12030c8590187e652cd1cd0a1f3cb","date":1397833225,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = compareResults(\n        controlClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound(),\n        cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound());\n    assertTrue(\"A test that compareResults is working correctly failed\",\n        shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"072f211dfa8387028bb978d128c35bf9a450bbbf","date":1406041363,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"QTime\", SKIPVAL);\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"bafca15d8e408346a67f4282ad1143b88023893b","date":1420034748,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrClient baseClient = new HttpSolrClient(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseClient.setConnectionTimeout(30000);\n    baseClient.request(request);\n    baseClient.shutdown();\n    baseClient = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrServer) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrServer baseServer = new HttpSolrServer(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseServer.setConnectionTimeout(30000);\n    baseServer.request(request);\n    baseServer.shutdown();\n    baseServer = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"abb23fcc2461782ab204e61213240feb77d355aa","date":1422029612,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#test().mjava","pathOld":"solr/core/src/test/org/apache/solr/cloud/SyncSliceTest#doTest().mjava","sourceNew":"  @Test\n  public void test() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrClient baseClient = new HttpSolrClient(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseClient.setConnectionTimeout(30000);\n    baseClient.request(request);\n    baseClient.shutdown();\n    baseClient = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(getShardCount() - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","sourceOld":"  @Override\n  public void doTest() throws Exception {\n    \n    handle.clear();\n    handle.put(\"timestamp\", SKIPVAL);\n    \n    waitForThingsToLevelOut(30);\n\n    del(\"*:*\");\n    List<CloudJettyRunner> skipServers = new ArrayList<>();\n    int docId = 0;\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"old haven was blue.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(1));\n    \n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"but the song was fancy.\");\n    \n    skipServers.add(shardToJetty.get(\"shard1\").get(2));\n    \n    indexDoc(skipServers, id,docId++, i1, 50, tlong, 50, t1,\n        \"under the moon and over the lake\");\n    \n    commit();\n    \n    waitForRecoveriesToFinish(false);\n\n    // shard should be inconsistent\n    String shardFailMessage = checkShardConsistency(\"shard1\", true, false);\n    assertNotNull(shardFailMessage);\n    \n    ModifiableSolrParams params = new ModifiableSolrParams();\n    params.set(\"action\", CollectionAction.SYNCSHARD.toString());\n    params.set(\"collection\", \"collection1\");\n    params.set(\"shard\", \"shard1\");\n    SolrRequest request = new QueryRequest(params);\n    request.setPath(\"/admin/collections\");\n    \n    String baseUrl = ((HttpSolrClient) shardToJetty.get(\"shard1\").get(2).client.solrClient)\n        .getBaseURL();\n    baseUrl = baseUrl.substring(0, baseUrl.length() - \"collection1\".length());\n    \n    HttpSolrClient baseClient = new HttpSolrClient(baseUrl);\n    // we only set the connect timeout, not so timeout\n    baseClient.setConnectionTimeout(30000);\n    baseClient.request(request);\n    baseClient.shutdown();\n    baseClient = null;\n    \n    waitForThingsToLevelOut(15);\n    \n    checkShardConsistency(false, true);\n    \n    long cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(4, cloudClientDocs);\n    \n    \n    // kill the leader - new leader could have all the docs or be missing one\n    CloudJettyRunner leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    \n    skipServers = getRandomOtherJetty(leaderJetty, null); // but not the leader\n    \n    // this doc won't be on one node\n    indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n        \"to come to the aid of their country.\");\n    \n    \n    Set<CloudJettyRunner> jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n    \n    chaosMonkey.killJetty(leaderJetty);\n    \n    Thread.sleep(3000);\n    \n    waitForNoShardInconsistency();\n    \n    Thread.sleep(1000);\n    \n    checkShardConsistency(false, true);\n    \n    cloudClientDocs = cloudClient.query(new SolrQuery(\"*:*\")).getResults().getNumFound();\n    assertEquals(5, cloudClientDocs);\n    \n    CloudJettyRunner deadJetty = leaderJetty;\n    \n    // let's get the latest leader\n    while (deadJetty == leaderJetty) {\n      updateMappingsFromZk(this.jettys, this.clients);\n      leaderJetty = shardToLeaderJetty.get(\"shard1\");\n    }\n    \n    // bring back dead node\n    ChaosMonkey.start(deadJetty.jetty); // he is not the leader anymore\n    \n    waitTillAllNodesActive();\n    \n    skipServers = getRandomOtherJetty(leaderJetty, deadJetty);\n    skipServers.addAll( getRandomOtherJetty(leaderJetty, deadJetty));\n    // skip list should be \n    \n//    System.out.println(\"leader:\" + leaderJetty.url);\n//    System.out.println(\"dead:\" + deadJetty.url);\n//    System.out.println(\"skip list:\" + skipServers);\n    \n    // we are skipping  2 nodes\n    assertEquals(2, skipServers.size());\n    \n    // more docs than can peer sync\n    for (int i = 0; i < 300; i++) {\n      indexDoc(skipServers, id, docId++, i1, 50, tlong, 50, t1,\n          \"to come to the aid of their country.\");\n    }\n    \n    commit();\n    \n    Thread.sleep(1000);\n    \n    waitForRecoveriesToFinish(false);\n    \n    // shard should be inconsistent\n    shardFailMessage = waitTillInconsistent();\n    assertNotNull(\n        \"Test Setup Failure: shard1 should have just been set up to be inconsistent - but it's still consistent. Leader:\"\n            + leaderJetty.url + \" Dead Guy:\" + deadJetty.url + \"skip list:\" + skipServers, shardFailMessage);\n    \n    // good place to test compareResults\n    boolean shouldFail = CloudInspectUtil.compareResults(controlClient, cloudClient);\n    assertTrue(\"A test that compareResults is working correctly failed\", shouldFail);\n    \n    jetties = new HashSet<>();\n    jetties.addAll(shardToJetty.get(\"shard1\"));\n    jetties.remove(leaderJetty);\n    assertEquals(shardCount - 1, jetties.size());\n\n    \n    // kill the current leader\n    chaosMonkey.killJetty(leaderJetty);\n    \n    waitForNoShardInconsistency();\n\n    checkShardConsistency(true, true);\n    \n    success = true;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":["76530c83bab98ecf28c61c2b68a7151a946298f2","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"930f2ead620d01f86f471a8f0896c0e2d9234eca":["d16312ffd2ca7e3a5117030cfa8f105f00a32ddf"],"a69439d0df009e0bb0038d1e427159f449dd670d":["abd13178766ec31053e070b800f34110130c6151"],"4339eef0c1b12030c8590187e652cd1cd0a1f3cb":["0962ba7d9ec0b488f485e768df5dd80b77b9f7ce"],"efee511ca1fb9a8711021d261526526cf3e84890":["ca10c70cbce0d7ac8219a4adc23ed9efa79564fe"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"ca10c70cbce0d7ac8219a4adc23ed9efa79564fe":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc"],"aba371508186796cc6151d8223a5b4e16d02e26e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ce9115008b2600dda16a6765e06b6b380458c02f"],"abd13178766ec31053e070b800f34110130c6151":["480e4f53dbc60fbc1565d29c062ec8681c863d7f"],"e415cc960b0e7b8c945b0ed0004272b8435433ac":["a3c3e46d3417c353d7be14509cfab11b315927fe"],"f2126b84bd093fa3d921582a109a0ee578c28126":["2c30e4c1cee08b3b229a77991882594fe7250b66","abd13178766ec31053e070b800f34110130c6151"],"2c30e4c1cee08b3b229a77991882594fe7250b66":["3f767f8c99eaedb984df754fe61f21c5de260f94"],"4d93914268f50e71bc43bc1aeefb7d21573ea1df":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02"],"6ef6348b84bf0f8a649826b69a70ac815ff560e2":["efee511ca1fb9a8711021d261526526cf3e84890"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["76530c83bab98ecf28c61c2b68a7151a946298f2"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"ce9115008b2600dda16a6765e06b6b380458c02f":["8a65836c18a62c7b1b404fcb1bba729fd4c29e81"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["aba371508186796cc6151d8223a5b4e16d02e26e","2c30e4c1cee08b3b229a77991882594fe7250b66"],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":["a3c3e46d3417c353d7be14509cfab11b315927fe","e415cc960b0e7b8c945b0ed0004272b8435433ac"],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["abd13178766ec31053e070b800f34110130c6151","de2d2f1684b6eb1f7ede1b1ad13a34fef0dd6b40"],"072f211dfa8387028bb978d128c35bf9a450bbbf":["4339eef0c1b12030c8590187e652cd1cd0a1f3cb"],"abb23fcc2461782ab204e61213240feb77d355aa":["bafca15d8e408346a67f4282ad1143b88023893b"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":["efee511ca1fb9a8711021d261526526cf3e84890","8a65836c18a62c7b1b404fcb1bba729fd4c29e81"],"d16312ffd2ca7e3a5117030cfa8f105f00a32ddf":["0ff47835661df91a174abb056b009b53fba16a26"],"bafca15d8e408346a67f4282ad1143b88023893b":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"85aa27528f7991962c33686e81d50246b97fb08d":["a69439d0df009e0bb0038d1e427159f449dd670d"],"8a65836c18a62c7b1b404fcb1bba729fd4c29e81":["50ff0384c52eb23ed5f248f461676fd8c033c50f"],"6948dfbf6c703c42e0d9831d5b2a1ce38e75abb6":["217c5e3cedf564c6d370670858e1b1edab16fcac"],"50ff0384c52eb23ed5f248f461676fd8c033c50f":["6948dfbf6c703c42e0d9831d5b2a1ce38e75abb6"],"0ff47835661df91a174abb056b009b53fba16a26":["4d93914268f50e71bc43bc1aeefb7d21573ea1df"],"de2d2f1684b6eb1f7ede1b1ad13a34fef0dd6b40":["bea41289768794cfe5678cbc6d737dcd240670e5"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":["8fd5be977c105554c6a7b68afcdbc511439723ab","2c30e4c1cee08b3b229a77991882594fe7250b66"],"217c5e3cedf564c6d370670858e1b1edab16fcac":["6ef6348b84bf0f8a649826b69a70ac815ff560e2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","ca10c70cbce0d7ac8219a4adc23ed9efa79564fe"],"042c474f8983c7bfede807d97ad9faf73ff694cc":["85aa27528f7991962c33686e81d50246b97fb08d"],"bea41289768794cfe5678cbc6d737dcd240670e5":["042c474f8983c7bfede807d97ad9faf73ff694cc"],"b49f59235aa7d5bf40a55e23dc40cbc777d7506f":["ce9115008b2600dda16a6765e06b6b380458c02f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["0ab4f87da977b06208c737a8e360752d3290440b"],"480e4f53dbc60fbc1565d29c062ec8681c863d7f":["2c30e4c1cee08b3b229a77991882594fe7250b66"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","3f767f8c99eaedb984df754fe61f21c5de260f94"],"a3c3e46d3417c353d7be14509cfab11b315927fe":["849494cf2f3a96af5c8c84995108ddd8456fcd04"],"0962ba7d9ec0b488f485e768df5dd80b77b9f7ce":["5f6c494de6b7fddab42beeb839721ee126885db1"],"0ab4f87da977b06208c737a8e360752d3290440b":["e415cc960b0e7b8c945b0ed0004272b8435433ac"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["b49f59235aa7d5bf40a55e23dc40cbc777d7506f"],"b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02":["941acc1dc75cf5303cef02bda58645d6122fdba4"],"76530c83bab98ecf28c61c2b68a7151a946298f2":["930f2ead620d01f86f471a8f0896c0e2d9234eca"],"941acc1dc75cf5303cef02bda58645d6122fdba4":["de2d2f1684b6eb1f7ede1b1ad13a34fef0dd6b40"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["4b51f65902cc2d20ddeb7a5b949aaddf990f31a7","b49f59235aa7d5bf40a55e23dc40cbc777d7506f"],"5f6c494de6b7fddab42beeb839721ee126885db1":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["abb23fcc2461782ab204e61213240feb77d355aa"]},"commit2Childs":{"37a0f60745e53927c4c876cfe5b5a58170f0646c":[],"930f2ead620d01f86f471a8f0896c0e2d9234eca":["76530c83bab98ecf28c61c2b68a7151a946298f2"],"a69439d0df009e0bb0038d1e427159f449dd670d":["85aa27528f7991962c33686e81d50246b97fb08d"],"4339eef0c1b12030c8590187e652cd1cd0a1f3cb":["072f211dfa8387028bb978d128c35bf9a450bbbf"],"efee511ca1fb9a8711021d261526526cf3e84890":["6ef6348b84bf0f8a649826b69a70ac815ff560e2","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b"],"933fa8f09adfcd1a858cd0fc7912e21ee993b7fc":["ca10c70cbce0d7ac8219a4adc23ed9efa79564fe"],"ca10c70cbce0d7ac8219a4adc23ed9efa79564fe":["efee511ca1fb9a8711021d261526526cf3e84890","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"aba371508186796cc6151d8223a5b4e16d02e26e":["d6f074e73200c07d54f242d3880a8da5a35ff97b"],"abd13178766ec31053e070b800f34110130c6151":["a69439d0df009e0bb0038d1e427159f449dd670d","f2126b84bd093fa3d921582a109a0ee578c28126","d3fcb70cf561547c7bb1506e0cf32ca7b1287064"],"e415cc960b0e7b8c945b0ed0004272b8435433ac":["74f45af4339b0daf7a95c820ab88c1aea74fbce0","0ab4f87da977b06208c737a8e360752d3290440b"],"f2126b84bd093fa3d921582a109a0ee578c28126":[],"2c30e4c1cee08b3b229a77991882594fe7250b66":["f2126b84bd093fa3d921582a109a0ee578c28126","d6f074e73200c07d54f242d3880a8da5a35ff97b","c7869f64c874ebf7f317d22c00baf2b6857797a6","480e4f53dbc60fbc1565d29c062ec8681c863d7f"],"4d93914268f50e71bc43bc1aeefb7d21573ea1df":["0ff47835661df91a174abb056b009b53fba16a26"],"6ef6348b84bf0f8a649826b69a70ac815ff560e2":["217c5e3cedf564c6d370670858e1b1edab16fcac"],"849494cf2f3a96af5c8c84995108ddd8456fcd04":["37a0f60745e53927c4c876cfe5b5a58170f0646c","a3c3e46d3417c353d7be14509cfab11b315927fe"],"4c7856260bc28f285ae7bfefa99b28db4dca6daf":["5f6c494de6b7fddab42beeb839721ee126885db1"],"ce9115008b2600dda16a6765e06b6b380458c02f":["aba371508186796cc6151d8223a5b4e16d02e26e","b49f59235aa7d5bf40a55e23dc40cbc777d7506f"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"74f45af4339b0daf7a95c820ab88c1aea74fbce0":[],"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"072f211dfa8387028bb978d128c35bf9a450bbbf":["bafca15d8e408346a67f4282ad1143b88023893b"],"abb23fcc2461782ab204e61213240feb77d355aa":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b":[],"d16312ffd2ca7e3a5117030cfa8f105f00a32ddf":["930f2ead620d01f86f471a8f0896c0e2d9234eca"],"bafca15d8e408346a67f4282ad1143b88023893b":["abb23fcc2461782ab204e61213240feb77d355aa"],"85aa27528f7991962c33686e81d50246b97fb08d":["042c474f8983c7bfede807d97ad9faf73ff694cc"],"8a65836c18a62c7b1b404fcb1bba729fd4c29e81":["ce9115008b2600dda16a6765e06b6b380458c02f","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b"],"6948dfbf6c703c42e0d9831d5b2a1ce38e75abb6":["50ff0384c52eb23ed5f248f461676fd8c033c50f"],"50ff0384c52eb23ed5f248f461676fd8c033c50f":["8a65836c18a62c7b1b404fcb1bba729fd4c29e81"],"0ff47835661df91a174abb056b009b53fba16a26":["d16312ffd2ca7e3a5117030cfa8f105f00a32ddf"],"de2d2f1684b6eb1f7ede1b1ad13a34fef0dd6b40":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","941acc1dc75cf5303cef02bda58645d6122fdba4"],"c7869f64c874ebf7f317d22c00baf2b6857797a6":[],"217c5e3cedf564c6d370670858e1b1edab16fcac":["6948dfbf6c703c42e0d9831d5b2a1ce38e75abb6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["933fa8f09adfcd1a858cd0fc7912e21ee993b7fc","aba371508186796cc6151d8223a5b4e16d02e26e","4b51f65902cc2d20ddeb7a5b949aaddf990f31a7"],"4b51f65902cc2d20ddeb7a5b949aaddf990f31a7":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"042c474f8983c7bfede807d97ad9faf73ff694cc":["bea41289768794cfe5678cbc6d737dcd240670e5"],"bea41289768794cfe5678cbc6d737dcd240670e5":["de2d2f1684b6eb1f7ede1b1ad13a34fef0dd6b40"],"b49f59235aa7d5bf40a55e23dc40cbc777d7506f":["3f767f8c99eaedb984df754fe61f21c5de260f94","b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["4c7856260bc28f285ae7bfefa99b28db4dca6daf"],"480e4f53dbc60fbc1565d29c062ec8681c863d7f":["abd13178766ec31053e070b800f34110130c6151"],"8fd5be977c105554c6a7b68afcdbc511439723ab":["c7869f64c874ebf7f317d22c00baf2b6857797a6"],"a3c3e46d3417c353d7be14509cfab11b315927fe":["e415cc960b0e7b8c945b0ed0004272b8435433ac","74f45af4339b0daf7a95c820ab88c1aea74fbce0"],"0962ba7d9ec0b488f485e768df5dd80b77b9f7ce":["4339eef0c1b12030c8590187e652cd1cd0a1f3cb"],"3f767f8c99eaedb984df754fe61f21c5de260f94":["2c30e4c1cee08b3b229a77991882594fe7250b66","8fd5be977c105554c6a7b68afcdbc511439723ab"],"0ab4f87da977b06208c737a8e360752d3290440b":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02":["4d93914268f50e71bc43bc1aeefb7d21573ea1df"],"76530c83bab98ecf28c61c2b68a7151a946298f2":["37a0f60745e53927c4c876cfe5b5a58170f0646c","849494cf2f3a96af5c8c84995108ddd8456fcd04"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["8fd5be977c105554c6a7b68afcdbc511439723ab"],"941acc1dc75cf5303cef02bda58645d6122fdba4":["b550b9fe8a5610e9a206849fa6e2bde1e8a2cf02"],"5f6c494de6b7fddab42beeb839721ee126885db1":["0962ba7d9ec0b488f485e768df5dd80b77b9f7ce"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["37a0f60745e53927c4c876cfe5b5a58170f0646c","f2126b84bd093fa3d921582a109a0ee578c28126","d6f074e73200c07d54f242d3880a8da5a35ff97b","74f45af4339b0daf7a95c820ab88c1aea74fbce0","d3fcb70cf561547c7bb1506e0cf32ca7b1287064","fe9077a1ed75bdcdcc7dfff6525f73941c8cf30b","c7869f64c874ebf7f317d22c00baf2b6857797a6","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}