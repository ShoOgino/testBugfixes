{"path":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","commits":[{"id":"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d","date":1336650316,"type":1,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Random,Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n      f = new DerefBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_DEREF:\n      f = new DerefBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_SORTED:\n      f = new SortedBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case FLOAT_32:\n      f = new FloatDocValuesField(name, r.nextFloat());\n      break;\n    case FLOAT_64:\n      f = new DoubleDocValuesField(name, r.nextDouble());\n      break;\n    case VAR_INTS:\n      f = new PackedLongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_16:\n      // TODO: we should test negatives too?\n      f = new ShortDocValuesField(name, (short) r.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      f = new IntDocValuesField(name, r.nextInt());\n      break;\n    case FIXED_INTS_64:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_8:  \n      // TODO: we should test negatives too?\n      f = new ByteDocValuesField(name, (byte) r.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Random random, Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[random.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n    case BYTES_FIXED_STRAIGHT:\n    case BYTES_FIXED_SORTED:\n      //make sure we use a valid unicode string with a fixed size byte length\n      final String randomUnicodeString = _TestUtil.randomFixedByteLengthUnicodeString(random, fixedBytesLength);\n      BytesRef fixedRef = new BytesRef(randomUnicodeString);\n      if (fixedRef.length > fixedBytesLength) {\n        fixedRef = new BytesRef(fixedRef.bytes, 0, fixedBytesLength);\n      } else {\n        fixedRef.grow(fixedBytesLength);\n        fixedRef.length = fixedBytesLength;\n      }\n      f = new DocValuesField(name, fixedRef, type);\n      break;\n    case BYTES_VAR_DEREF:\n    case BYTES_VAR_STRAIGHT:\n    case BYTES_VAR_SORTED:\n      f = new DocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(random, 20)), type);\n      break;\n    case FLOAT_32:\n      f = new DocValuesField(name, random.nextFloat(), type);\n      break;\n    case FLOAT_64:\n      f = new DocValuesField(name, random.nextDouble(), type);\n      break;\n    case VAR_INTS:\n      f = new DocValuesField(name, random.nextLong(), type);\n      break;\n    case FIXED_INTS_16:\n      f = new DocValuesField(name, random.nextInt(Short.MAX_VALUE), type);\n      break;\n    case FIXED_INTS_32:\n      f = new DocValuesField(name, random.nextInt(), type);\n      break;\n    case FIXED_INTS_64:\n      f = new DocValuesField(name, random.nextLong(), type);\n      break;\n    case FIXED_INTS_8:\n      f = new DocValuesField(name, random.nextInt(128), type);\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"57ae3024996ccdb3c36c42cb890e1efb37df4ce8","date":1338343651,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n      f = new DerefBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_DEREF:\n      f = new DerefBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_SORTED:\n      f = new SortedBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case FLOAT_32:\n      f = new FloatDocValuesField(name, r.nextFloat());\n      break;\n    case FLOAT_64:\n      f = new DoubleDocValuesField(name, r.nextDouble());\n      break;\n    case VAR_INTS:\n      f = new PackedLongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_16:\n      // TODO: we should test negatives too?\n      f = new ShortDocValuesField(name, (short) r.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      f = new IntDocValuesField(name, r.nextInt());\n      break;\n    case FIXED_INTS_64:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_8:  \n      // TODO: we should test negatives too?\n      f = new ByteDocValuesField(name, (byte) r.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (\"Lucene3x\".equals(codec.getName()) || doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n      f = new DerefBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_DEREF:\n      f = new DerefBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_SORTED:\n      f = new SortedBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case FLOAT_32:\n      f = new FloatDocValuesField(name, r.nextFloat());\n      break;\n    case FLOAT_64:\n      f = new DoubleDocValuesField(name, r.nextDouble());\n      break;\n    case VAR_INTS:\n      f = new PackedLongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_16:\n      // TODO: we should test negatives too?\n      f = new ShortDocValuesField(name, (short) r.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      f = new IntDocValuesField(name, r.nextInt());\n      break;\n    case FIXED_INTS_64:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_8:  \n      // TODO: we should test negatives too?\n      f = new ByteDocValuesField(name, (byte) r.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"04c9e68e2d2795065221b48a81227b65faf0a166","date":1358285913,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValuesType[] values = DocValuesType.values();\n    DocValuesType type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BINARY:\n      f = new BinaryDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case NUMERIC:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n      f = new DerefBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_DEREF:\n      f = new DerefBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_SORTED:\n      f = new SortedBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case FLOAT_32:\n      f = new FloatDocValuesField(name, r.nextFloat());\n      break;\n    case FLOAT_64:\n      f = new DoubleDocValuesField(name, r.nextDouble());\n      break;\n    case VAR_INTS:\n      f = new PackedLongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_16:\n      // TODO: we should test negatives too?\n      f = new ShortDocValuesField(name, (short) r.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      f = new IntDocValuesField(name, r.nextInt());\n      break;\n    case FIXED_INTS_64:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_8:  \n      // TODO: we should test negatives too?\n      f = new ByteDocValuesField(name, (byte) r.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"423d89a2b3cc419b647c07c2b3fdbc54311d07f9","date":1358836612,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","sourceNew":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValuesType[] values = DocValuesType.values();\n    DocValuesType type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BINARY:\n      f = new BinaryDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case SORTED:\n      f = new SortedDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case NUMERIC:\n      f = new NumericDocValuesField(name, r.nextLong());\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","sourceOld":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValuesType[] values = DocValuesType.values();\n    DocValuesType type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BINARY:\n      f = new BinaryDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case NUMERIC:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"003dc2cb64b06ce8caea28156505feb3c5059ba2","date":1359688932,"type":4,"author":"Robert Muir","isMerge":false,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","sourceNew":null,"sourceOld":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValuesType[] values = DocValuesType.values();\n    DocValuesType type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BINARY:\n      f = new BinaryDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case SORTED:\n      f = new SortedDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)));\n      break;\n    case NUMERIC:\n      f = new NumericDocValuesField(name, r.nextLong());\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4d69c535930b5cce125cff868d40f6373dc27d4","date":1360270101,"type":4,"author":"Robert Muir","isMerge":true,"pathNew":"/dev/null","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/RandomIndexWriter#randomPerDocFieldValues(Document).mjava","sourceNew":null,"sourceOld":"  private void randomPerDocFieldValues(Document doc) {\n    \n    DocValues.Type[] values = DocValues.Type.values();\n    DocValues.Type type = values[r.nextInt(values.length)];\n    String name = \"random_\" + type.name() + \"\" + docValuesFieldPrefix;\n    if (doc.getField(name) != null) {\n      return;\n    }\n    final Field f;\n    switch (type) {\n    case BYTES_FIXED_DEREF:\n      f = new DerefBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_DEREF:\n      f = new DerefBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_STRAIGHT:\n      f = new StraightBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case BYTES_FIXED_SORTED:\n      f = new SortedBytesDocValuesField(name, getFixedRandomBytes(), true);\n      break;\n    case BYTES_VAR_SORTED:\n      f = new SortedBytesDocValuesField(name, new BytesRef(_TestUtil.randomUnicodeString(r, 20)), false);\n      break;\n    case FLOAT_32:\n      f = new FloatDocValuesField(name, r.nextFloat());\n      break;\n    case FLOAT_64:\n      f = new DoubleDocValuesField(name, r.nextDouble());\n      break;\n    case VAR_INTS:\n      f = new PackedLongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_16:\n      // TODO: we should test negatives too?\n      f = new ShortDocValuesField(name, (short) r.nextInt(Short.MAX_VALUE));\n      break;\n    case FIXED_INTS_32:\n      f = new IntDocValuesField(name, r.nextInt());\n      break;\n    case FIXED_INTS_64:\n      f = new LongDocValuesField(name, r.nextLong());\n      break;\n    case FIXED_INTS_8:  \n      // TODO: we should test negatives too?\n      f = new ByteDocValuesField(name, (byte) r.nextInt(128));\n      break;\n    default:\n      throw new IllegalArgumentException(\"no such type: \" + type);\n    }\n    doc.add(f);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8","003dc2cb64b06ce8caea28156505feb3c5059ba2"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"003dc2cb64b06ce8caea28156505feb3c5059ba2":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["04c9e68e2d2795065221b48a81227b65faf0a166"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"04c9e68e2d2795065221b48a81227b65faf0a166":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d4d69c535930b5cce125cff868d40f6373dc27d4"]},"commit2Childs":{"57ae3024996ccdb3c36c42cb890e1efb37df4ce8":["d4d69c535930b5cce125cff868d40f6373dc27d4","04c9e68e2d2795065221b48a81227b65faf0a166"],"d4d69c535930b5cce125cff868d40f6373dc27d4":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["cd659803551ebd8ca09b9e4ad7abd18d3d558f9d"],"003dc2cb64b06ce8caea28156505feb3c5059ba2":["d4d69c535930b5cce125cff868d40f6373dc27d4"],"423d89a2b3cc419b647c07c2b3fdbc54311d07f9":["003dc2cb64b06ce8caea28156505feb3c5059ba2"],"cd659803551ebd8ca09b9e4ad7abd18d3d558f9d":["57ae3024996ccdb3c36c42cb890e1efb37df4ce8"],"04c9e68e2d2795065221b48a81227b65faf0a166":["423d89a2b3cc419b647c07c2b3fdbc54311d07f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}