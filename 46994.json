{"path":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                /*\n                 * Force FI to load for each segment since we could see a\n                 * segments file and load successfully above if the files are\n                 * still referenced when they are deleted and the os doesn't let\n                 * you delete them. Yet its likely that fnm files are removed\n                 * while seg file is still around Since LUCENE-2984 we need FI\n                 * to find out if a seg has vectors and prox so we need those\n                 * files to be opened for a commit point.\n                 */\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                /*\n                 * Force FI to load for each segment since we could see a\n                 * segments file and load successfully above if the files are\n                 * still referenced when they are deleted and the os doesn't let\n                 * you delete them. Yet its likely that fnm files are removed\n                 * while seg file is still around Since LUCENE-2984 we need FI\n                 * to find out if a seg has vectors and prox so we need those\n                 * files to be opened for a commit point.\n                 */\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"438e995b4e32916f631722aab36254146830fefb","date":1328903827,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                /*\n                 * Force FI to load for each segment since we could see a\n                 * segments file and load successfully above if the files are\n                 * still referenced when they are deleted and the os doesn't let\n                 * you delete them. Yet its likely that fnm files are removed\n                 * while seg file is still around Since LUCENE-2984 we need FI\n                 * to find out if a seg has vectors and prox so we need those\n                 * files to be opened for a commit point.\n                 */\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getCurrentSegmentFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                /*\n                 * Force FI to load for each segment since we could see a\n                 * segments file and load successfully above if the files are\n                 * still referenced when they are deleted and the os doesn't let\n                 * you delete them. Yet its likely that fnm files are removed\n                 * while seg file is still around Since LUCENE-2984 we need FI\n                 * to find out if a seg has vectors and prox so we need those\n                 * files to be opened for a commit point.\n                 */\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getCurrentSegmentFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d2dee33619431ada2a7a07f5fe2dbd94bac6a460","date":1337274029,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                /*\n                 * Force FI to load for each segment since we could see a\n                 * segments file and load successfully above if the files are\n                 * still referenced when they are deleted and the os doesn't let\n                 * you delete them. Yet its likely that fnm files are removed\n                 * while seg file is still around Since LUCENE-2984 we need FI\n                 * to find out if a seg has vectors and prox so we need those\n                 * files to be opened for a commit point.\n                 */\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"034b8e37ade96af2cef0172233d24b652b432f99","date":1337636665,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if ((IndexFileNameFilter.INSTANCE.accept(null, fileName)) && !fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final SegmentInfos infos = sis;\n            for (SegmentInfo segmentInfo : infos) {\n              try {\n                /*\n                 * Force FI to load for each segment since we could see a\n                 * segments file and load successfully above if the files are\n                 * still referenced when they are deleted and the os doesn't let\n                 * you delete them. Yet its likely that fnm files are removed\n                 * while seg file is still around Since LUCENE-2984 we need FI\n                 * to find out if a seg has vectors and prox so we need those\n                 * files to be opened for a commit point.\n                 */\n                segmentInfo.getFieldInfos();\n              } catch (FileNotFoundException e) {\n                refresh(segmentInfo.name);\n                sis = null;\n                if (infoStream.isEnabled(\"IFD\")) {\n                  infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n                }\n              }\n            }\n           \n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278","06584e6e98d592b34e1329b384182f368d2025e8"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"325bbca4044b6777f17a523df80a19260a80d67e","date":1341423988,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n          && (fileName.startsWith(\"_\") || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"724efd21e6b657f902571a8fbe9d7a60711bb2c0","date":1341482116,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n          && (fileName.startsWith(\"_\") || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":["0ff6d29b386d9d2fe7848cf6a9175ba42276a00b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws CorruptIndexException if the index is corrupt\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws CorruptIndexException, IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0ff6d29b386d9d2fe7848cf6a9175ba42276a00b","date":1343584789,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                // Most likely we are opening an index that\n                // has an aborted \"future\" commit, so suppress\n                // exc in this case\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":["7b91922b55d15444d554721b352861d028eb8278","06584e6e98d592b34e1329b384182f368d2025e8","58c6bbc222f074c844e736e6fb23647e3db9cfe3","fb8c6c8b35c7806f1ef4d37d52944b67158db2d1","724efd21e6b657f902571a8fbe9d7a60711bb2c0"],"bugIntro":["d1498f09c87cd5e5f3085bdcbdb9a6bc30410d52"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","date":1343768312,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                // Most likely we are opening an index that\n                // has an aborted \"future\" commit, so suppress\n                // exc in this case\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d6f074e73200c07d54f242d3880a8da5a35ff97b","date":1344507653,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                // Most likely we are opening an index that\n                // has an aborted \"future\" commit, so suppress\n                // exc in this case\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n\n    for (String fileName : files) {\n\n      if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)) {\n\n        // Add this file to refCounts with initial count 0:\n        getRefCount(fileName);\n\n        if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n\n          // This is a commit (segments or segments_N), and\n          // it's valid (<= the max gen).  Load it, then\n          // incref all files it refers to:\n          if (infoStream.isEnabled(\"IFD\")) {\n            infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n          }\n          SegmentInfos sis = new SegmentInfos();\n          try {\n            sis.read(directory, fileName);\n          } catch (FileNotFoundException e) {\n            // LUCENE-948: on NFS (and maybe others), if\n            // you have writers switching back and forth\n            // between machines, it's very likely that the\n            // dir listing will be stale and will claim a\n            // file segments_X exists when in fact it\n            // doesn't.  So, we catch this and handle it\n            // as if the file does not exist\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n            }\n            sis = null;\n          } catch (IOException e) {\n            if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n              throw e;\n            } else {\n              // Most likely we are opening an index that\n              // has an aborted \"future\" commit, so suppress\n              // exc in this case\n              sis = null;\n            }\n          }\n          if (sis != null) {\n            final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n            if (sis.getGeneration() == segmentInfos.getGeneration()) {\n              currentCommitPoint = commitPoint;\n            }\n            commits.add(commitPoint);\n            incRef(sis, true);\n\n            if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n              lastSegmentInfos = sis;\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"30e0912f3a3069b115cfea44ff612c44d6906386","date":1365631344,"type":5,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexFileDeleter#IndexFileDeleter(Directory,IndexDeletionPolicy,SegmentInfos,InfoStream,IndexWriter).mjava","sourceNew":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer, boolean initialIndexExists) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                // Most likely we are opening an index that\n                // has an aborted \"future\" commit, so suppress\n                // exc in this case\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null && initialIndexExists) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file \\\"\" + currentSegmentsFile + \"\\\"\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","sourceOld":"  /**\n   * Initialize the deleter: find all previous commits in\n   * the Directory, incref the files they reference, call\n   * the policy to let it delete commits.  This will remove\n   * any files not referenced by any of the commits.\n   * @throws IOException if there is a low-level IO error\n   */\n  public IndexFileDeleter(Directory directory, IndexDeletionPolicy policy, SegmentInfos segmentInfos,\n                          InfoStream infoStream, IndexWriter writer) throws IOException {\n    this.infoStream = infoStream;\n    this.writer = writer;\n\n    final String currentSegmentsFile = segmentInfos.getSegmentsFileName();\n\n    if (infoStream.isEnabled(\"IFD\")) {\n      infoStream.message(\"IFD\", \"init: current segments file is \\\"\" + currentSegmentsFile + \"\\\"; deletionPolicy=\" + policy);\n    }\n\n    this.policy = policy;\n    this.directory = directory;\n\n    // First pass: walk the files and initialize our ref\n    // counts:\n    long currentGen = segmentInfos.getGeneration();\n\n    CommitPoint currentCommitPoint = null;\n    String[] files = null;\n    try {\n      files = directory.listAll();\n    } catch (NoSuchDirectoryException e) {\n      // it means the directory is empty, so ignore it.\n      files = new String[0];\n    }\n    \n    if (currentSegmentsFile != null) {\n      Matcher m = IndexFileNames.CODEC_FILE_PATTERN.matcher(\"\");\n      for (String fileName : files) {\n        m.reset(fileName);\n        if (!fileName.endsWith(\"write.lock\") && !fileName.equals(IndexFileNames.SEGMENTS_GEN)\n            && (m.matches() || fileName.startsWith(IndexFileNames.SEGMENTS))) {\n          \n          // Add this file to refCounts with initial count 0:\n          getRefCount(fileName);\n          \n          if (fileName.startsWith(IndexFileNames.SEGMENTS)) {\n            \n            // This is a commit (segments or segments_N), and\n            // it's valid (<= the max gen).  Load it, then\n            // incref all files it refers to:\n            if (infoStream.isEnabled(\"IFD\")) {\n              infoStream.message(\"IFD\", \"init: load commit \\\"\" + fileName + \"\\\"\");\n            }\n            SegmentInfos sis = new SegmentInfos();\n            try {\n              sis.read(directory, fileName);\n            } catch (FileNotFoundException e) {\n              // LUCENE-948: on NFS (and maybe others), if\n              // you have writers switching back and forth\n              // between machines, it's very likely that the\n              // dir listing will be stale and will claim a\n              // file segments_X exists when in fact it\n              // doesn't.  So, we catch this and handle it\n              // as if the file does not exist\n              if (infoStream.isEnabled(\"IFD\")) {\n                infoStream.message(\"IFD\", \"init: hit FileNotFoundException when loading commit \\\"\" + fileName + \"\\\"; skipping this commit point\");\n              }\n              sis = null;\n            } catch (IOException e) {\n              if (SegmentInfos.generationFromSegmentsFileName(fileName) <= currentGen && directory.fileLength(fileName) > 0) {\n                throw e;\n              } else {\n                // Most likely we are opening an index that\n                // has an aborted \"future\" commit, so suppress\n                // exc in this case\n                sis = null;\n              }\n            }\n            if (sis != null) {\n              final CommitPoint commitPoint = new CommitPoint(commitsToDelete, directory, sis);\n              if (sis.getGeneration() == segmentInfos.getGeneration()) {\n                currentCommitPoint = commitPoint;\n              }\n              commits.add(commitPoint);\n              incRef(sis, true);\n              \n              if (lastSegmentInfos == null || sis.getGeneration() > lastSegmentInfos.getGeneration()) {\n                lastSegmentInfos = sis;\n              }\n            }\n          }\n        }\n      }\n    }\n\n    if (currentCommitPoint == null && currentSegmentsFile != null) {\n      // We did not in fact see the segments_N file\n      // corresponding to the segmentInfos that was passed\n      // in.  Yet, it must exist, because our caller holds\n      // the write lock.  This can happen when the directory\n      // listing was stale (eg when index accessed via NFS\n      // client with stale directory listing cache).  So we\n      // try now to explicitly open this commit point:\n      SegmentInfos sis = new SegmentInfos();\n      try {\n        sis.read(directory, currentSegmentsFile);\n      } catch (IOException e) {\n        throw new CorruptIndexException(\"failed to locate current segments_N file\");\n      }\n      if (infoStream.isEnabled(\"IFD\")) {\n        infoStream.message(\"IFD\", \"forced open of current segments file \" + segmentInfos.getSegmentsFileName());\n      }\n      currentCommitPoint = new CommitPoint(commitsToDelete, directory, sis);\n      commits.add(currentCommitPoint);\n      incRef(sis, true);\n    }\n\n    // We keep commits list in sorted order (oldest to newest):\n    CollectionUtil.mergeSort(commits);\n\n    // Now delete anything with ref count at 0.  These are\n    // presumably abandoned files eg due to crash of\n    // IndexWriter.\n    for(Map.Entry<String, RefCount> entry : refCounts.entrySet() ) {\n      RefCount rc = entry.getValue();\n      final String fileName = entry.getKey();\n      if (0 == rc.count) {\n        if (infoStream.isEnabled(\"IFD\")) {\n          infoStream.message(\"IFD\", \"init: removing unreferenced file \\\"\" + fileName + \"\\\"\");\n        }\n        deleteFile(fileName);\n      }\n    }\n\n    // Finally, give policy a chance to remove things on\n    // startup:\n    if (currentSegmentsFile != null) {\n      policy.onInit(commits);\n    }\n\n    // Always protect the incoming segmentInfos since\n    // sometime it may not be the most recent commit\n    checkpoint(segmentInfos, false);\n\n    startingCommitDeleted = currentCommitPoint == null ? false : currentCommitPoint.isDeleted();\n\n    deleteCommits();\n  }\n\n","bugFix":null,"bugIntro":["9a70ce9bddc6f985feb8e5e182aebe20872328d4"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"724efd21e6b657f902571a8fbe9d7a60711bb2c0":["325bbca4044b6777f17a523df80a19260a80d67e"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["438e995b4e32916f631722aab36254146830fefb"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["438e995b4e32916f631722aab36254146830fefb","034b8e37ade96af2cef0172233d24b652b432f99"],"0ff6d29b386d9d2fe7848cf6a9175ba42276a00b":["724efd21e6b657f902571a8fbe9d7a60711bb2c0"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","724efd21e6b657f902571a8fbe9d7a60711bb2c0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":["fe33227f6805edab2036cbb80645cc4e2d1fa424","0ff6d29b386d9d2fe7848cf6a9175ba42276a00b"],"325bbca4044b6777f17a523df80a19260a80d67e":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":["724efd21e6b657f902571a8fbe9d7a60711bb2c0","0ff6d29b386d9d2fe7848cf6a9175ba42276a00b"],"30e0912f3a3069b115cfea44ff612c44d6906386":["0ff6d29b386d9d2fe7848cf6a9175ba42276a00b"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"438e995b4e32916f631722aab36254146830fefb":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"034b8e37ade96af2cef0172233d24b652b432f99":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["30e0912f3a3069b115cfea44ff612c44d6906386"]},"commit2Childs":{"724efd21e6b657f902571a8fbe9d7a60711bb2c0":["0ff6d29b386d9d2fe7848cf6a9175ba42276a00b","fe33227f6805edab2036cbb80645cc4e2d1fa424","d6f074e73200c07d54f242d3880a8da5a35ff97b"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["438e995b4e32916f631722aab36254146830fefb"],"d2dee33619431ada2a7a07f5fe2dbd94bac6a460":["034b8e37ade96af2cef0172233d24b652b432f99"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["fe33227f6805edab2036cbb80645cc4e2d1fa424","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"0ff6d29b386d9d2fe7848cf6a9175ba42276a00b":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","30e0912f3a3069b115cfea44ff612c44d6906386"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f":[],"325bbca4044b6777f17a523df80a19260a80d67e":["724efd21e6b657f902571a8fbe9d7a60711bb2c0"],"d6f074e73200c07d54f242d3880a8da5a35ff97b":[],"30e0912f3a3069b115cfea44ff612c44d6906386":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["325bbca4044b6777f17a523df80a19260a80d67e"],"438e995b4e32916f631722aab36254146830fefb":["d2dee33619431ada2a7a07f5fe2dbd94bac6a460","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"034b8e37ade96af2cef0172233d24b652b432f99":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["b7cbfe9a112ef62d75f3289e4c79bbe274cb2a4f","d6f074e73200c07d54f242d3880a8da5a35ff97b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}