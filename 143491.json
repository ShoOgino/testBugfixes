{"path":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/Entity#Entity(boolean,Element,DataImporter,Entity).mjava","commits":[{"id":"4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c","date":1335805170,"type":0,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/Entity#Entity(boolean,Element,DataImporter,Entity).mjava","pathOld":"/dev/null","sourceNew":"  public Entity(boolean docRootFound, Element element, DataImporter di, Entity parent) {\n    this.parentEntity = parent;\n    \n    String modName = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.NAME, null);\n    if (modName == null) {\n      throw new DataImportHandlerException(SEVERE, \"Entity must have a name.\");\n    }\n    if (modName.indexOf(\".\") != -1) {\n      throw new DataImportHandlerException(SEVERE,\n          \"Entity name must not have period (.): '\" + modName);\n    }\n    if (ConfigNameConstants.RESERVED_WORDS.contains(modName)) {\n      throw new DataImportHandlerException(SEVERE, \"Entity name : '\" + modName\n          + \"' is a reserved keyword. Reserved words are: \" + ConfigNameConstants.RESERVED_WORDS);\n    }\n    this.name = modName;\n    this.pk = ConfigParseUtil.getStringAttribute(element, \"pk\", null);\n    this.processorName = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.PROCESSOR,null);\n    this.dataSourceName = ConfigParseUtil.getStringAttribute(element, DataImporter.DATA_SRC, null);\n    \n    String rawDocRootValue = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.ROOT_ENTITY, null);\n    if (!docRootFound && !\"false\".equals(rawDocRootValue)) {\n      // if in this chain no document root is found()\n      docRoot = true;\n    } else {\n      docRoot = false;\n    }\n    \n    Map<String,String> modAttributes = ConfigParseUtil\n        .getAllAttributes(element);\n    modAttributes.put(ConfigNameConstants.DATA_SRC, this.dataSourceName);\n    this.allAttributes = Collections.unmodifiableMap(modAttributes);\n    \n    List<Element> n = ConfigParseUtil.getChildNodes(element, \"field\");\n    List<EntityField> modFields = new ArrayList<EntityField>(n.size());\n    Map<String,Set<EntityField>> modColNameVsField = new HashMap<String,Set<EntityField>>();\n    List<Map<String,String>> modAllFieldAttributes = new ArrayList<Map<String,String>>();\n    for (Element elem : n) {\n      EntityField.Builder fieldBuilder = new EntityField.Builder(elem);\n      if (di.getSchema() != null) {\n        if (fieldBuilder.getNameOrColumn() != null\n            && fieldBuilder.getNameOrColumn().contains(\"${\")) {\n          fieldBuilder.dynamicName = true;\n        } else {\n          SchemaField schemaField = di.getSchemaField(fieldBuilder\n              .getNameOrColumn());\n          if (schemaField != null) {\n            fieldBuilder.name = schemaField.getName();\n            fieldBuilder.multiValued = schemaField.multiValued();\n            fieldBuilder.allAttributes.put(DataImporter.MULTI_VALUED, Boolean\n                .toString(schemaField.multiValued()));\n            fieldBuilder.allAttributes.put(DataImporter.TYPE, schemaField\n                .getType().getTypeName());\n            fieldBuilder.allAttributes.put(\"indexed\", Boolean\n                .toString(schemaField.indexed()));\n            fieldBuilder.allAttributes.put(\"stored\", Boolean\n                .toString(schemaField.stored()));\n            fieldBuilder.allAttributes.put(\"defaultValue\", schemaField\n                .getDefaultValue());\n          } else {\n            fieldBuilder.toWrite = false;\n          }\n        }\n      }\n      Set<EntityField> fieldSet = modColNameVsField.get(fieldBuilder.column);\n      if (fieldSet == null) {\n        fieldSet = new HashSet<EntityField>();\n        modColNameVsField.put(fieldBuilder.column, fieldSet);\n      }\n      fieldBuilder.allAttributes.put(\"boost\", Float\n          .toString(fieldBuilder.boost));\n      fieldBuilder.allAttributes.put(\"toWrite\", Boolean\n          .toString(fieldBuilder.toWrite));\n      modAllFieldAttributes.add(fieldBuilder.allAttributes);\n      fieldBuilder.entity = this;\n      EntityField field = new EntityField(fieldBuilder);\n      fieldSet.add(field);\n      modFields.add(field);\n    }\n    Map<String,Set<EntityField>> modColNameVsField1 = new HashMap<String,Set<EntityField>>();\n    for (Map.Entry<String,Set<EntityField>> entry : modColNameVsField\n        .entrySet()) {\n      if (entry.getValue().size() > 0) {\n        modColNameVsField1.put(entry.getKey(), Collections\n            .unmodifiableSet(entry.getValue()));\n      }\n    }\n    this.colNameVsField = Collections.unmodifiableMap(modColNameVsField1);\n    this.fields = Collections.unmodifiableList(modFields);\n    this.allFieldAttributes = Collections\n        .unmodifiableList(modAllFieldAttributes);\n    \n    String modPkMappingFromSchema = null;\n    if (di.getSchema() != null) {\n      SchemaField uniqueKey = di.getSchema().getUniqueKeyField();\n      if (uniqueKey != null) {\n        modPkMappingFromSchema = uniqueKey.getName();\n        // if no fields are mentioned . solr uniqueKey is same as dih 'pk'\n        for (EntityField field : fields) {\n          if (field.getName().equals(modPkMappingFromSchema)) {\n            modPkMappingFromSchema = field.getColumn();\n            // get the corresponding column mapping for the solr uniqueKey\n            // But if there are multiple columns mapping to the solr uniqueKey,\n            // it will fail\n            // so , in one off cases we may need pk\n            break;\n          }\n        }\n      }\n    }\n    pkMappingFromSchema = modPkMappingFromSchema;\n    n = ConfigParseUtil.getChildNodes(element, \"entity\");\n    List<Entity> modEntities = new ArrayList<Entity>();\n    for (Element elem : n) {\n      modEntities\n          .add(new Entity((docRootFound || this.docRoot), elem, di, this));\n    }\n    this.children = Collections.unmodifiableList(modEntities);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"08970e5b8411182a29412c177eff67ec1110095b","date":1366640815,"type":5,"author":"Steven Rowe","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/Entity#Entity(boolean,Element,DataImporter,DIHConfiguration,Entity).mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/config/Entity#Entity(boolean,Element,DataImporter,Entity).mjava","sourceNew":"  public Entity(boolean docRootFound, Element element, DataImporter di, DIHConfiguration config, Entity parent) {\n    this.parentEntity = parent;\n    this.config = config;\n    \n    String modName = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.NAME, null);\n    if (modName == null) {\n      throw new DataImportHandlerException(SEVERE, \"Entity must have a name.\");\n    }\n    if (modName.indexOf(\".\") != -1) {\n      throw new DataImportHandlerException(SEVERE,\n          \"Entity name must not have period (.): '\" + modName);\n    }\n    if (ConfigNameConstants.RESERVED_WORDS.contains(modName)) {\n      throw new DataImportHandlerException(SEVERE, \"Entity name : '\" + modName\n          + \"' is a reserved keyword. Reserved words are: \" + ConfigNameConstants.RESERVED_WORDS);\n    }\n    this.name = modName;\n    this.pk = ConfigParseUtil.getStringAttribute(element, \"pk\", null);\n    this.processorName = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.PROCESSOR,null);\n    this.dataSourceName = ConfigParseUtil.getStringAttribute(element, DataImporter.DATA_SRC, null);\n    \n    String rawDocRootValue = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.ROOT_ENTITY, null);\n    if (!docRootFound && !\"false\".equals(rawDocRootValue)) {\n      // if in this chain no document root is found()\n      docRoot = true;\n    } else {\n      docRoot = false;\n    }\n    \n    Map<String,String> modAttributes = ConfigParseUtil\n        .getAllAttributes(element);\n    modAttributes.put(ConfigNameConstants.DATA_SRC, this.dataSourceName);\n    this.allAttributes = Collections.unmodifiableMap(modAttributes);\n    \n    List<Element> n = ConfigParseUtil.getChildNodes(element, \"field\");\n    List<EntityField> modFields = new ArrayList<EntityField>(n.size());\n    Map<String,Set<EntityField>> modColNameVsField = new HashMap<String,Set<EntityField>>();\n    List<Map<String,String>> modAllFieldAttributes = new ArrayList<Map<String,String>>();\n    for (Element elem : n) {\n      EntityField.Builder fieldBuilder = new EntityField.Builder(elem);\n      if (config.getSchema() != null) {\n        if (fieldBuilder.getNameOrColumn() != null\n            && fieldBuilder.getNameOrColumn().contains(\"${\")) {\n          fieldBuilder.dynamicName = true;\n        } else {\n          SchemaField schemaField = config.getSchemaField\n              (fieldBuilder.getNameOrColumn());\n          if (schemaField != null) {\n            fieldBuilder.name = schemaField.getName();\n            fieldBuilder.multiValued = schemaField.multiValued();\n            fieldBuilder.allAttributes.put(DataImporter.MULTI_VALUED, Boolean\n                .toString(schemaField.multiValued()));\n            fieldBuilder.allAttributes.put(DataImporter.TYPE, schemaField\n                .getType().getTypeName());\n            fieldBuilder.allAttributes.put(\"indexed\", Boolean\n                .toString(schemaField.indexed()));\n            fieldBuilder.allAttributes.put(\"stored\", Boolean\n                .toString(schemaField.stored()));\n            fieldBuilder.allAttributes.put(\"defaultValue\", schemaField\n                .getDefaultValue());\n          } else {\n            fieldBuilder.toWrite = false;\n          }\n        }\n      }\n      Set<EntityField> fieldSet = modColNameVsField.get(fieldBuilder.column);\n      if (fieldSet == null) {\n        fieldSet = new HashSet<EntityField>();\n        modColNameVsField.put(fieldBuilder.column, fieldSet);\n      }\n      fieldBuilder.allAttributes.put(\"boost\", Float\n          .toString(fieldBuilder.boost));\n      fieldBuilder.allAttributes.put(\"toWrite\", Boolean\n          .toString(fieldBuilder.toWrite));\n      modAllFieldAttributes.add(fieldBuilder.allAttributes);\n      fieldBuilder.entity = this;\n      EntityField field = new EntityField(fieldBuilder);\n      fieldSet.add(field);\n      modFields.add(field);\n    }\n    Map<String,Set<EntityField>> modColNameVsField1 = new HashMap<String,Set<EntityField>>();\n    for (Map.Entry<String,Set<EntityField>> entry : modColNameVsField\n        .entrySet()) {\n      if (entry.getValue().size() > 0) {\n        modColNameVsField1.put(entry.getKey(), Collections\n            .unmodifiableSet(entry.getValue()));\n      }\n    }\n    this.colNameVsField = Collections.unmodifiableMap(modColNameVsField1);\n    this.fields = Collections.unmodifiableList(modFields);\n    this.allFieldAttributes = Collections\n        .unmodifiableList(modAllFieldAttributes);\n    \n    String modPkMappingFromSchema = null;\n    if (config.getSchema() != null) {\n      SchemaField uniqueKey = config.getSchema().getUniqueKeyField();\n      if (uniqueKey != null) {\n        modPkMappingFromSchema = uniqueKey.getName();\n        // if no fields are mentioned . solr uniqueKey is same as dih 'pk'\n        for (EntityField field : fields) {\n          if (field.getName().equals(modPkMappingFromSchema)) {\n            modPkMappingFromSchema = field.getColumn();\n            // get the corresponding column mapping for the solr uniqueKey\n            // But if there are multiple columns mapping to the solr uniqueKey,\n            // it will fail\n            // so , in one off cases we may need pk\n            break;\n          }\n        }\n      }\n    }\n    pkMappingFromSchema = modPkMappingFromSchema;\n    n = ConfigParseUtil.getChildNodes(element, \"entity\");\n    List<Entity> modEntities = new ArrayList<Entity>();\n    for (Element elem : n) {\n      modEntities.add(new Entity((docRootFound || this.docRoot), elem, di, config, this));\n    }\n    this.children = Collections.unmodifiableList(modEntities);\n  }\n\n","sourceOld":"  public Entity(boolean docRootFound, Element element, DataImporter di, Entity parent) {\n    this.parentEntity = parent;\n    \n    String modName = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.NAME, null);\n    if (modName == null) {\n      throw new DataImportHandlerException(SEVERE, \"Entity must have a name.\");\n    }\n    if (modName.indexOf(\".\") != -1) {\n      throw new DataImportHandlerException(SEVERE,\n          \"Entity name must not have period (.): '\" + modName);\n    }\n    if (ConfigNameConstants.RESERVED_WORDS.contains(modName)) {\n      throw new DataImportHandlerException(SEVERE, \"Entity name : '\" + modName\n          + \"' is a reserved keyword. Reserved words are: \" + ConfigNameConstants.RESERVED_WORDS);\n    }\n    this.name = modName;\n    this.pk = ConfigParseUtil.getStringAttribute(element, \"pk\", null);\n    this.processorName = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.PROCESSOR,null);\n    this.dataSourceName = ConfigParseUtil.getStringAttribute(element, DataImporter.DATA_SRC, null);\n    \n    String rawDocRootValue = ConfigParseUtil.getStringAttribute(element, ConfigNameConstants.ROOT_ENTITY, null);\n    if (!docRootFound && !\"false\".equals(rawDocRootValue)) {\n      // if in this chain no document root is found()\n      docRoot = true;\n    } else {\n      docRoot = false;\n    }\n    \n    Map<String,String> modAttributes = ConfigParseUtil\n        .getAllAttributes(element);\n    modAttributes.put(ConfigNameConstants.DATA_SRC, this.dataSourceName);\n    this.allAttributes = Collections.unmodifiableMap(modAttributes);\n    \n    List<Element> n = ConfigParseUtil.getChildNodes(element, \"field\");\n    List<EntityField> modFields = new ArrayList<EntityField>(n.size());\n    Map<String,Set<EntityField>> modColNameVsField = new HashMap<String,Set<EntityField>>();\n    List<Map<String,String>> modAllFieldAttributes = new ArrayList<Map<String,String>>();\n    for (Element elem : n) {\n      EntityField.Builder fieldBuilder = new EntityField.Builder(elem);\n      if (di.getSchema() != null) {\n        if (fieldBuilder.getNameOrColumn() != null\n            && fieldBuilder.getNameOrColumn().contains(\"${\")) {\n          fieldBuilder.dynamicName = true;\n        } else {\n          SchemaField schemaField = di.getSchemaField(fieldBuilder\n              .getNameOrColumn());\n          if (schemaField != null) {\n            fieldBuilder.name = schemaField.getName();\n            fieldBuilder.multiValued = schemaField.multiValued();\n            fieldBuilder.allAttributes.put(DataImporter.MULTI_VALUED, Boolean\n                .toString(schemaField.multiValued()));\n            fieldBuilder.allAttributes.put(DataImporter.TYPE, schemaField\n                .getType().getTypeName());\n            fieldBuilder.allAttributes.put(\"indexed\", Boolean\n                .toString(schemaField.indexed()));\n            fieldBuilder.allAttributes.put(\"stored\", Boolean\n                .toString(schemaField.stored()));\n            fieldBuilder.allAttributes.put(\"defaultValue\", schemaField\n                .getDefaultValue());\n          } else {\n            fieldBuilder.toWrite = false;\n          }\n        }\n      }\n      Set<EntityField> fieldSet = modColNameVsField.get(fieldBuilder.column);\n      if (fieldSet == null) {\n        fieldSet = new HashSet<EntityField>();\n        modColNameVsField.put(fieldBuilder.column, fieldSet);\n      }\n      fieldBuilder.allAttributes.put(\"boost\", Float\n          .toString(fieldBuilder.boost));\n      fieldBuilder.allAttributes.put(\"toWrite\", Boolean\n          .toString(fieldBuilder.toWrite));\n      modAllFieldAttributes.add(fieldBuilder.allAttributes);\n      fieldBuilder.entity = this;\n      EntityField field = new EntityField(fieldBuilder);\n      fieldSet.add(field);\n      modFields.add(field);\n    }\n    Map<String,Set<EntityField>> modColNameVsField1 = new HashMap<String,Set<EntityField>>();\n    for (Map.Entry<String,Set<EntityField>> entry : modColNameVsField\n        .entrySet()) {\n      if (entry.getValue().size() > 0) {\n        modColNameVsField1.put(entry.getKey(), Collections\n            .unmodifiableSet(entry.getValue()));\n      }\n    }\n    this.colNameVsField = Collections.unmodifiableMap(modColNameVsField1);\n    this.fields = Collections.unmodifiableList(modFields);\n    this.allFieldAttributes = Collections\n        .unmodifiableList(modAllFieldAttributes);\n    \n    String modPkMappingFromSchema = null;\n    if (di.getSchema() != null) {\n      SchemaField uniqueKey = di.getSchema().getUniqueKeyField();\n      if (uniqueKey != null) {\n        modPkMappingFromSchema = uniqueKey.getName();\n        // if no fields are mentioned . solr uniqueKey is same as dih 'pk'\n        for (EntityField field : fields) {\n          if (field.getName().equals(modPkMappingFromSchema)) {\n            modPkMappingFromSchema = field.getColumn();\n            // get the corresponding column mapping for the solr uniqueKey\n            // But if there are multiple columns mapping to the solr uniqueKey,\n            // it will fail\n            // so , in one off cases we may need pk\n            break;\n          }\n        }\n      }\n    }\n    pkMappingFromSchema = modPkMappingFromSchema;\n    n = ConfigParseUtil.getChildNodes(element, \"entity\");\n    List<Entity> modEntities = new ArrayList<Entity>();\n    for (Element elem : n) {\n      modEntities\n          .add(new Entity((docRootFound || this.docRoot), elem, di, this));\n    }\n    this.children = Collections.unmodifiableList(modEntities);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["08970e5b8411182a29412c177eff67ec1110095b"],"08970e5b8411182a29412c177eff67ec1110095b":["4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c"]},"commit2Childs":{"4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c":["08970e5b8411182a29412c177eff67ec1110095b"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"08970e5b8411182a29412c177eff67ec1110095b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}