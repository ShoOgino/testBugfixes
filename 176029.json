{"path":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","commits":[{"id":"969718c368b28ed1b2335ea2deb275c696cddb4f","date":1498803580,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<ReplicaPosition, String> tryAPermutationOfRules(int[] rulePermutation, List<ReplicaPosition> replicaPositions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<ReplicaPosition, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (ReplicaPosition replicaPosition : replicaPositions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, replicaPosition.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(replicaPosition, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(replicaPosition.shard);\n        if (nodeNames == null) copyOfCurrentState.put(replicaPosition.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (replicaPositions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<ReplicaPosition, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0d92226151c91fb4bebcca6d18782d1c84aee2cd","date":1498804792,"type":1,"author":"Noble Paul","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[Position],boolean).mjava","sourceNew":"  private Map<ReplicaPosition, String> tryAPermutationOfRules(int[] rulePermutation, List<ReplicaPosition> replicaPositions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<ReplicaPosition, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (ReplicaPosition replicaPosition : replicaPositions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, replicaPosition.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(replicaPosition, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(replicaPosition.shard);\n        if (nodeNames == null) copyOfCurrentState.put(replicaPosition.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (replicaPositions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<ReplicaPosition, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<Position, String> tryAPermutationOfRules(int[] rulePermutation, List<Position> positions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<Position, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (Position position : positions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, position.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(position, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(position.shard);\n        if (nodeNames == null) copyOfCurrentState.put(position.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (positions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<Position, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06a8891f085f71282bb3ece1b1732b68f07813a3","date":1591912889,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/rule/ReplicaAssigner#tryAPermutationOfRules(int[],List[ReplicaPosition],boolean).mjava","sourceNew":"  @SuppressWarnings({\"unchecked\"})\n  private Map<ReplicaPosition, String> tryAPermutationOfRules(int[] rulePermutation, List<ReplicaPosition> replicaPositions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<ReplicaPosition, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (ReplicaPosition replicaPosition : replicaPositions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, replicaPosition.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(replicaPosition, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(replicaPosition.shard);\n        if (nodeNames == null) copyOfCurrentState.put(replicaPosition.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (replicaPositions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<ReplicaPosition, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","sourceOld":"  private Map<ReplicaPosition, String> tryAPermutationOfRules(int[] rulePermutation, List<ReplicaPosition> replicaPositions, boolean fuzzyPhase) {\n    Map<String, Map<String, Object>> nodeVsTagsCopy = getDeepCopy(nodeVsTags, 2);\n    Map<ReplicaPosition, String> result = new LinkedHashMap<>();\n    int startPosition = 0;\n    Map<String, Map<String, Integer>> copyOfCurrentState = getDeepCopy(shardVsNodes, 2);\n    List<String> sortedLiveNodes = new ArrayList<>(this.participatingLiveNodes);\n    Collections.sort(sortedLiveNodes, (String n1, String n2) -> {\n      int result1 = 0;\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        int val = rule.compare(n1, n2, nodeVsTagsCopy, copyOfCurrentState);\n        if (val != 0) {//atleast one non-zero compare break now\n          result1 = val;\n          break;\n        }\n        if (result1 == 0) {//if all else is equal, prefer nodes with fewer cores\n          AtomicInteger n1Count = nodeVsCores.get(n1);\n          AtomicInteger n2Count = nodeVsCores.get(n2);\n          int a = n1Count == null ? 0 : n1Count.get();\n          int b = n2Count == null ? 0 : n2Count.get();\n          result1 = a > b ? 1 : a == b ? 0 : -1;\n        }\n\n      }\n      return result1;\n    });\n    forEachPosition:\n    for (ReplicaPosition replicaPosition : replicaPositions) {\n      //trying to assign a node by verifying each rule in this rulePermutation\n      forEachNode:\n      for (int j = 0; j < sortedLiveNodes.size(); j++) {\n        String liveNode = sortedLiveNodes.get(startPosition % sortedLiveNodes.size());\n        startPosition++;\n        for (int i = 0; i < rulePermutation.length; i++) {\n          Rule rule = rules.get(rulePermutation[i]);\n          //trying to assign a replica into this node in this shard\n          Rule.MatchStatus status = rule.tryAssignNodeToShard(liveNode,\n              copyOfCurrentState, nodeVsTagsCopy, replicaPosition.shard, fuzzyPhase ? FUZZY_ASSIGN : ASSIGN);\n          if (status == Rule.MatchStatus.CANNOT_ASSIGN_FAIL) {\n            continue forEachNode;//try another node for this position\n          }\n        }\n        //We have reached this far means this node can be applied to this position\n        //and all rules are fine. So let us change the currentState\n        result.put(replicaPosition, liveNode);\n        Map<String, Integer> nodeNames = copyOfCurrentState.get(replicaPosition.shard);\n        if (nodeNames == null) copyOfCurrentState.put(replicaPosition.shard, nodeNames = new HashMap<>());\n        Integer n = nodeNames.get(liveNode);\n        n = n == null ? 1 : n + 1;\n        nodeNames.put(liveNode, n);\n        Map<String, Object> tagsMap = nodeVsTagsCopy.get(liveNode);\n        Number coreCount = tagsMap == null ? null: (Number) tagsMap.get(ImplicitSnitch.CORES);\n        if (coreCount != null) {\n          nodeVsTagsCopy.get(liveNode).put(ImplicitSnitch.CORES, coreCount.intValue() + 1);\n        }\n\n        continue forEachPosition;\n      }\n      //if it reached here, we could not find a node for this position\n      return null;\n    }\n\n    if (replicaPositions.size() > result.size()) {\n      return null;\n    }\n\n    for (Map.Entry<ReplicaPosition, String> e : result.entrySet()) {\n      for (int i = 0; i < rulePermutation.length; i++) {\n        Rule rule = rules.get(rulePermutation[i]);\n        Rule.MatchStatus matchStatus = rule.tryAssignNodeToShard(e.getValue(),\n            copyOfCurrentState, nodeVsTagsCopy, e.getKey().shard, fuzzyPhase ? FUZZY_VERIFY : VERIFY);\n        if (matchStatus != NODE_CAN_BE_ASSIGNED && matchStatus != NOT_APPLICABLE) return null;\n      }\n    }\n    return result;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"969718c368b28ed1b2335ea2deb275c696cddb4f":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"06a8891f085f71282bb3ece1b1732b68f07813a3":["969718c368b28ed1b2335ea2deb275c696cddb4f"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["06a8891f085f71282bb3ece1b1732b68f07813a3"]},"commit2Childs":{"969718c368b28ed1b2335ea2deb275c696cddb4f":["06a8891f085f71282bb3ece1b1732b68f07813a3"],"0d92226151c91fb4bebcca6d18782d1c84aee2cd":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["969718c368b28ed1b2335ea2deb275c696cddb4f","0d92226151c91fb4bebcca6d18782d1c84aee2cd"],"06a8891f085f71282bb3ece1b1732b68f07813a3":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0d92226151c91fb4bebcca6d18782d1c84aee2cd","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}