{"path":"lucene/src/java/org/apache/lucene/index/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","commits":[{"id":"3cc749c053615f5871f3b95715fe292f34e70a53","date":1321470575,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/index/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"/dev/null","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      \n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n\n      final boolean positions;\n\n      OffsetAttribute offsetAtt;\n\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      if (termsEnum.next() != null) {\n        assert numTerms > 0;\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        if (docsAndPositionsEnum != null) {\n          // has positions\n          positions = true;\n          if (docsAndPositionsEnum.attributes().hasAttribute(OffsetAttribute.class)) {\n            offsetAtt = docsAndPositionsEnum.attributes().getAttribute(OffsetAttribute.class);\n          } else {\n            offsetAtt = null;\n          }\n        } else {\n          positions = false;\n          offsetAtt = null;\n        }\n      } else {\n        // no terms in this field (hmm why is field present\n        // then...?)\n        assert numTerms == 0;\n        positions = false;\n        offsetAtt = null;\n      }\n      \n      startField(fieldInfo, numTerms, positions, offsetAtt != null);\n\n      int termCount = 1;\n\n      // NOTE: we already .next()'d the TermsEnum above, to\n      // peek @ first term to see if positions/offsets are\n      // present\n      while(true) {\n        final int freq = (int) termsEnum.totalTermFreq();\n        startTerm(termsEnum.term(), freq);\n\n        if (positions || offsetAtt != null) {\n          DocsAndPositionsEnum dp = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          // TODO: add startOffset()/endOffset() to d&pEnum... this is insanity\n          if (dp != docsAndPositionsEnum) {\n            // producer didnt reuse, must re-pull attributes\n            if (offsetAtt != null) {\n              assert dp.attributes().hasAttribute(OffsetAttribute.class);\n              offsetAtt = dp.attributes().getAttribute(OffsetAttribute.class);\n            }\n          }\n          docsAndPositionsEnum = dp;\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = offsetAtt == null ? -1 : offsetAtt.startOffset();\n            final int endOffset = offsetAtt == null ? -1 : offsetAtt.endOffset();\n            \n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n        \n        if (termsEnum.next() == null) {\n          assert termCount == numTerms;\n          break;\n        }\n        termCount++;\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc","5699a2da08aaf5a165f2ceefe7cf8f5c70a12efc"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"a0ae5e3ed1232483b7b8a014f175a5fe43595982","date":1324062192,"type":5,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/src/java/org/apache/lucene/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/codecs/TermVectorsWriter#addAllDocVectors(Fields,FieldInfos).mjava","sourceNew":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      \n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n\n      final boolean positions;\n\n      OffsetAttribute offsetAtt;\n\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      if (termsEnum.next() != null) {\n        assert numTerms > 0;\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        if (docsAndPositionsEnum != null) {\n          // has positions\n          positions = true;\n          if (docsAndPositionsEnum.attributes().hasAttribute(OffsetAttribute.class)) {\n            offsetAtt = docsAndPositionsEnum.attributes().getAttribute(OffsetAttribute.class);\n          } else {\n            offsetAtt = null;\n          }\n        } else {\n          positions = false;\n          offsetAtt = null;\n        }\n      } else {\n        // no terms in this field (hmm why is field present\n        // then...?)\n        assert numTerms == 0;\n        positions = false;\n        offsetAtt = null;\n      }\n      \n      startField(fieldInfo, numTerms, positions, offsetAtt != null);\n\n      int termCount = 1;\n\n      // NOTE: we already .next()'d the TermsEnum above, to\n      // peek @ first term to see if positions/offsets are\n      // present\n      while(true) {\n        final int freq = (int) termsEnum.totalTermFreq();\n        startTerm(termsEnum.term(), freq);\n\n        if (positions || offsetAtt != null) {\n          DocsAndPositionsEnum dp = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          // TODO: add startOffset()/endOffset() to d&pEnum... this is insanity\n          if (dp != docsAndPositionsEnum) {\n            // producer didnt reuse, must re-pull attributes\n            if (offsetAtt != null) {\n              assert dp.attributes().hasAttribute(OffsetAttribute.class);\n              offsetAtt = dp.attributes().getAttribute(OffsetAttribute.class);\n            }\n          }\n          docsAndPositionsEnum = dp;\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = offsetAtt == null ? -1 : offsetAtt.startOffset();\n            final int endOffset = offsetAtt == null ? -1 : offsetAtt.endOffset();\n            \n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n        \n        if (termsEnum.next() == null) {\n          assert termCount == numTerms;\n          break;\n        }\n        termCount++;\n      }\n    }\n  }\n\n","sourceOld":"  /** Safe (but, slowish) default method to write every\n   *  vector field in the document.  This default\n   *  implementation requires that the vectors implement\n   *  both Fields.getUniqueFieldCount and\n   *  Terms.getUniqueTermCount. */\n  protected final void addAllDocVectors(Fields vectors, FieldInfos fieldInfos) throws IOException {\n    if (vectors == null) {\n      startDocument(0);\n      return;\n    }\n\n    final int numFields = vectors.getUniqueFieldCount();\n    if (numFields == -1) {\n      throw new IllegalStateException(\"vectors.getUniqueFieldCount() must be implemented (it returned -1)\");\n    }\n    startDocument(numFields);\n    \n    final FieldsEnum fieldsEnum = vectors.iterator();\n    String fieldName;\n    String lastFieldName = null;\n\n    while((fieldName = fieldsEnum.next()) != null) {\n      \n      final FieldInfo fieldInfo = fieldInfos.fieldInfo(fieldName);\n\n      assert lastFieldName == null || fieldName.compareTo(lastFieldName) > 0: \"lastFieldName=\" + lastFieldName + \" fieldName=\" + fieldName;\n      lastFieldName = fieldName;\n\n      final Terms terms = fieldsEnum.terms();\n      if (terms == null) {\n        // FieldsEnum shouldn't lie...\n        continue;\n      }\n      final int numTerms = (int) terms.getUniqueTermCount();\n      if (numTerms == -1) {\n        throw new IllegalStateException(\"vector.getUniqueTermCount() must be implemented (it returned -1)\");\n      }\n\n      final boolean positions;\n\n      OffsetAttribute offsetAtt;\n\n      final TermsEnum termsEnum = terms.iterator(null);\n\n      DocsAndPositionsEnum docsAndPositionsEnum = null;\n\n      if (termsEnum.next() != null) {\n        assert numTerms > 0;\n        docsAndPositionsEnum = termsEnum.docsAndPositions(null, null);\n        if (docsAndPositionsEnum != null) {\n          // has positions\n          positions = true;\n          if (docsAndPositionsEnum.attributes().hasAttribute(OffsetAttribute.class)) {\n            offsetAtt = docsAndPositionsEnum.attributes().getAttribute(OffsetAttribute.class);\n          } else {\n            offsetAtt = null;\n          }\n        } else {\n          positions = false;\n          offsetAtt = null;\n        }\n      } else {\n        // no terms in this field (hmm why is field present\n        // then...?)\n        assert numTerms == 0;\n        positions = false;\n        offsetAtt = null;\n      }\n      \n      startField(fieldInfo, numTerms, positions, offsetAtt != null);\n\n      int termCount = 1;\n\n      // NOTE: we already .next()'d the TermsEnum above, to\n      // peek @ first term to see if positions/offsets are\n      // present\n      while(true) {\n        final int freq = (int) termsEnum.totalTermFreq();\n        startTerm(termsEnum.term(), freq);\n\n        if (positions || offsetAtt != null) {\n          DocsAndPositionsEnum dp = termsEnum.docsAndPositions(null, docsAndPositionsEnum);\n          // TODO: add startOffset()/endOffset() to d&pEnum... this is insanity\n          if (dp != docsAndPositionsEnum) {\n            // producer didnt reuse, must re-pull attributes\n            if (offsetAtt != null) {\n              assert dp.attributes().hasAttribute(OffsetAttribute.class);\n              offsetAtt = dp.attributes().getAttribute(OffsetAttribute.class);\n            }\n          }\n          docsAndPositionsEnum = dp;\n          final int docID = docsAndPositionsEnum.nextDoc();\n          assert docID != DocsEnum.NO_MORE_DOCS;\n          assert docsAndPositionsEnum.freq() == freq;\n\n          for(int posUpto=0; posUpto<freq; posUpto++) {\n            final int pos = docsAndPositionsEnum.nextPosition();\n            final int startOffset = offsetAtt == null ? -1 : offsetAtt.startOffset();\n            final int endOffset = offsetAtt == null ? -1 : offsetAtt.endOffset();\n            \n            addPosition(pos, startOffset, endOffset);\n          }\n        }\n        \n        if (termsEnum.next() == null) {\n          assert termCount == numTerms;\n          break;\n        }\n        termCount++;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"3cc749c053615f5871f3b95715fe292f34e70a53":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["3cc749c053615f5871f3b95715fe292f34e70a53"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3cc749c053615f5871f3b95715fe292f34e70a53"],"3cc749c053615f5871f3b95715fe292f34e70a53":["a0ae5e3ed1232483b7b8a014f175a5fe43595982"],"a0ae5e3ed1232483b7b8a014f175a5fe43595982":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}