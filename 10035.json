{"path":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","commits":[{"id":"e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6","date":1501264759,"type":1,"author":"Steve Rowe","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState().mjava","sourceNew":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   * \n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","sourceOld":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * @deprecated Don't call this, call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   */\n  @Deprecated\n  public void updateClusterState() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","date":1502192746,"type":1,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#updateClusterState().mjava","sourceNew":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   * \n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","sourceOld":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * @deprecated Don't call this, call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   */\n  @Deprecated\n  public void updateClusterState() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e92ecc804db94989e3c224b898b8dc978ebb584f","date":1556036948,"type":3,"author":"Gus Heck","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","sourceNew":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   *\n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","sourceOld":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   * \n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","bugFix":["e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"2668c99990e4c94a78bac005aa682b7c5986d23a","date":1561446137,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","sourceNew":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   * <p>\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   *\n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","sourceOld":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   *\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   *\n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5ad9c35f926b4bf8da0336d1300efc709c8d5a56","date":1591729157,"type":3,"author":"murblanc","isMerge":false,"pathNew":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","pathOld":"solr/solrj/src/java/org/apache/solr/common/cloud/ZkStateReader#forciblyRefreshAllClusterStateSlow().mjava","sourceNew":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   * <p>\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   *\n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","sourceOld":"  /**\n   * Forcibly refresh cluster state from ZK. Do this only to avoid race conditions because it's expensive.\n   * <p>\n   * It is cheaper to call {@link #forceUpdateCollection(String)} on a single collection if you must.\n   *\n   * @lucene.internal\n   */\n  public void forciblyRefreshAllClusterStateSlow() throws KeeperException, InterruptedException {\n    synchronized (getUpdateLock()) {\n      if (clusterState == null) {\n        // Never initialized, just run normal initialization.\n        createClusterStateWatchersAndUpdate();\n        return;\n      }\n      // No need to set watchers because we should already have watchers registered for everything.\n      refreshCollectionList(null);\n      refreshLiveNodes(null);\n      refreshLegacyClusterState(null);\n      // Need a copy so we don't delete from what we're iterating over.\n      Collection<String> safeCopy = new ArrayList<>(watchedCollectionStates.keySet());\n      Set<String> updatedCollections = new HashSet<>();\n      for (String coll : safeCopy) {\n        DocCollection newState = fetchCollectionState(coll, null);\n        if (updateWatchedCollection(coll, newState)) {\n          updatedCollections.add(coll);\n        }\n      }\n      constructState(updatedCollections);\n    }\n  }\n\n","bugFix":["1072b8e47b50f1c4fb039e1f54a736f381d6f809"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e92ecc804db94989e3c224b898b8dc978ebb584f":["e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"2668c99990e4c94a78bac005aa682b7c5986d23a":["e92ecc804db94989e3c224b898b8dc978ebb584f"],"e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"]},"commit2Childs":{"e92ecc804db94989e3c224b898b8dc978ebb584f":["2668c99990e4c94a78bac005aa682b7c5986d23a"],"5ad9c35f926b4bf8da0336d1300efc709c8d5a56":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7a23cf16c8fa265dc0a564adcabb55e3f054e0ac":[],"2668c99990e4c94a78bac005aa682b7c5986d23a":["5ad9c35f926b4bf8da0336d1300efc709c8d5a56"],"e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6":["e92ecc804db94989e3c224b898b8dc978ebb584f","7a23cf16c8fa265dc0a564adcabb55e3f054e0ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","e4a891bee704a4a1e21c33fc406a2c2c6de6d6f6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["7a23cf16c8fa265dc0a564adcabb55e3f054e0ac","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}