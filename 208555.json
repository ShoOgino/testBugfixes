{"path":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","commits":[{"id":"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91","date":1306767085,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n    document = dataImporter.getConfig().document;\n    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n    statusMessages.put(TIME_ELAPSED, new Object() {\n      @Override\n      public String toString() {\n        return getTimeElapsedSince(startTime.get());\n      }\n    });\n\n    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n            importStatistics.queryCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n            importStatistics.rowsCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n            importStatistics.docCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n            importStatistics.skipDocCount);\n\n    List<String> entities = requestParameters.entities;\n\n    // Trigger onImportStart\n    if (document.onImportStart != null) {\n      invokeEventListener(document.onImportStart);\n    }\n    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n    Properties lastIndexTimeProps = new Properties();\n    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n    for (DataConfig.Entity e : document.entities) {\n      if (entities != null && !entities.contains(e.name))\n        continue;\n      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      root = e;\n      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n        cleanByQuery(delQuery, fullCleanDone);\n        doDelta();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      } else {\n        cleanByQuery(delQuery, fullCleanDone);\n        doFullDump();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      }\n      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n    }\n\n    if (stop.get()) {\n      // Dont commit if aborted using command=abort\n      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      rollback();\n    } else {\n      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n      if (!requestParameters.clean) {\n        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n          finish(lastIndexTimeProps);\n        }\n      } else {\n        // Finished operation normally, commit now\n        finish(lastIndexTimeProps);\n      }\n      \n      if (writer != null) {\n        writer.finish();\n      }\n      \n      if (document.onImportEnd != null) {\n        invokeEventListener(document.onImportEnd);\n      }\n    }\n\n    statusMessages.remove(TIME_ELAPSED);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n    if(importStatistics.failedDocCount.get() > 0)\n      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n    document = dataImporter.getConfig().document;\n    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n    statusMessages.put(TIME_ELAPSED, new Object() {\n      @Override\n      public String toString() {\n        return getTimeElapsedSince(startTime.get());\n      }\n    });\n\n    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n            importStatistics.queryCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n            importStatistics.rowsCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n            importStatistics.docCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n            importStatistics.skipDocCount);\n\n    List<String> entities = requestParameters.entities;\n\n    // Trigger onImportStart\n    if (document.onImportStart != null) {\n      invokeEventListener(document.onImportStart);\n    }\n    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n    Properties lastIndexTimeProps = new Properties();\n    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n    for (DataConfig.Entity e : document.entities) {\n      if (entities != null && !entities.contains(e.name))\n        continue;\n      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      root = e;\n      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n        cleanByQuery(delQuery, fullCleanDone);\n        doDelta();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      } else {\n        cleanByQuery(delQuery, fullCleanDone);\n        doFullDump();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      }\n      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n    }\n\n    if (stop.get()) {\n      // Dont commit if aborted using command=abort\n      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      rollback();\n    } else {\n      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n      if (!requestParameters.clean) {\n        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n          finish(lastIndexTimeProps);\n        }\n      } else {\n        // Finished operation normally, commit now\n        finish(lastIndexTimeProps);\n      }\n      \n      if (writer != null) {\n        writer.finish();\n      }\n      \n      if (document.onImportEnd != null) {\n        invokeEventListener(document.onImportEnd);\n      }\n    }\n\n    statusMessages.remove(TIME_ELAPSED);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n    if(importStatistics.failedDocCount.get() > 0)\n      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/main/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n    document = dataImporter.getConfig().document;\n    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n    statusMessages.put(TIME_ELAPSED, new Object() {\n      @Override\n      public String toString() {\n        return getTimeElapsedSince(startTime.get());\n      }\n    });\n\n    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n            importStatistics.queryCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n            importStatistics.rowsCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n            importStatistics.docCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n            importStatistics.skipDocCount);\n\n    List<String> entities = requestParameters.entities;\n\n    // Trigger onImportStart\n    if (document.onImportStart != null) {\n      invokeEventListener(document.onImportStart);\n    }\n    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n    Properties lastIndexTimeProps = new Properties();\n    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n    for (DataConfig.Entity e : document.entities) {\n      if (entities != null && !entities.contains(e.name))\n        continue;\n      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      root = e;\n      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n        cleanByQuery(delQuery, fullCleanDone);\n        doDelta();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      } else {\n        cleanByQuery(delQuery, fullCleanDone);\n        doFullDump();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      }\n      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n    }\n\n    if (stop.get()) {\n      // Dont commit if aborted using command=abort\n      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      rollback();\n    } else {\n      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n      if (!requestParameters.clean) {\n        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n          finish(lastIndexTimeProps);\n        }\n      } else {\n        // Finished operation normally, commit now\n        finish(lastIndexTimeProps);\n      }\n      \n      if (writer != null) {\n        writer.finish();\n      }\n      \n      if (document.onImportEnd != null) {\n        invokeEventListener(document.onImportEnd);\n      }\n    }\n\n    statusMessages.remove(TIME_ELAPSED);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n    if(importStatistics.failedDocCount.get() > 0)\n      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n    document = dataImporter.getConfig().document;\n    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n    statusMessages.put(TIME_ELAPSED, new Object() {\n      @Override\n      public String toString() {\n        return getTimeElapsedSince(startTime.get());\n      }\n    });\n\n    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n            importStatistics.queryCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n            importStatistics.rowsCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n            importStatistics.docCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n            importStatistics.skipDocCount);\n\n    List<String> entities = requestParameters.entities;\n\n    // Trigger onImportStart\n    if (document.onImportStart != null) {\n      invokeEventListener(document.onImportStart);\n    }\n    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n    Properties lastIndexTimeProps = new Properties();\n    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n    for (DataConfig.Entity e : document.entities) {\n      if (entities != null && !entities.contains(e.name))\n        continue;\n      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      root = e;\n      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n        cleanByQuery(delQuery, fullCleanDone);\n        doDelta();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      } else {\n        cleanByQuery(delQuery, fullCleanDone);\n        doFullDump();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      }\n      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n    }\n\n    if (stop.get()) {\n      // Dont commit if aborted using command=abort\n      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      rollback();\n    } else {\n      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n      if (!requestParameters.clean) {\n        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n          finish(lastIndexTimeProps);\n        }\n      } else {\n        // Finished operation normally, commit now\n        finish(lastIndexTimeProps);\n      }\n      \n      if (writer != null) {\n        writer.finish();\n      }\n      \n      if (document.onImportEnd != null) {\n        invokeEventListener(document.onImportEnd);\n      }\n    }\n\n    statusMessages.remove(TIME_ELAPSED);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n    if(importStatistics.failedDocCount.get() > 0)\n      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7a136026dd5340a1feb1e3efd8cafe390616c1d8","date":1311317263,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    document = dataImporter.getConfig().document;\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = requestParameters.entities;\n\t\n\t    // Trigger onImportStart\n\t    if (document.onImportStart != null) {\n\t      invokeEventListener(document.onImportStart);\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    for (DataConfig.Entity e : document.entities) {\n\t      if (entities != null && !entities.contains(e.name))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      root = e;\n\t      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!requestParameters.clean) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (document.onImportEnd != null) {\n\t        invokeEventListener(document.onImportEnd);\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t}\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n    document = dataImporter.getConfig().document;\n    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n    statusMessages.put(TIME_ELAPSED, new Object() {\n      @Override\n      public String toString() {\n        return getTimeElapsedSince(startTime.get());\n      }\n    });\n\n    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n            importStatistics.queryCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n            importStatistics.rowsCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n            importStatistics.docCount);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n            importStatistics.skipDocCount);\n\n    List<String> entities = requestParameters.entities;\n\n    // Trigger onImportStart\n    if (document.onImportStart != null) {\n      invokeEventListener(document.onImportStart);\n    }\n    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n    Properties lastIndexTimeProps = new Properties();\n    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n    for (DataConfig.Entity e : document.entities) {\n      if (entities != null && !entities.contains(e.name))\n        continue;\n      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      root = e;\n      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n        cleanByQuery(delQuery, fullCleanDone);\n        doDelta();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      } else {\n        cleanByQuery(delQuery, fullCleanDone);\n        doFullDump();\n        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n        if (delQuery != null) {\n          fullCleanDone.set(false);\n          cleanByQuery(delQuery, fullCleanDone);\n        }\n      }\n      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n    }\n\n    if (stop.get()) {\n      // Dont commit if aborted using command=abort\n      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n      rollback();\n    } else {\n      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n      if (!requestParameters.clean) {\n        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n          finish(lastIndexTimeProps);\n        }\n      } else {\n        // Finished operation normally, commit now\n        finish(lastIndexTimeProps);\n      }\n      \n      if (writer != null) {\n        writer.finish();\n      }\n      \n      if (document.onImportEnd != null) {\n        invokeEventListener(document.onImportEnd);\n      }\n    }\n\n    statusMessages.remove(TIME_ELAPSED);\n    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n    if(importStatistics.failedDocCount.get() > 0)\n      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n  }\n\n","bugFix":null,"bugIntro":["3a6e343b1381a2a5e2c5ad686897b43066ab60a9"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f95755793ac5f02eed6154c705e8638e001a5a0a","date":1312178495,"type":3,"author":"Noble Paul","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    document = dataImporter.getConfig().document;\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = requestParameters.entities;\n\t\n\t    // Trigger onImportStart\n\t    if (document.onImportStart != null) {\n\t      invokeEventListener(document.onImportStart);\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    for (DataConfig.Entity e : document.entities) {\n\t      if (entities != null && !entities.contains(e.name))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      root = e;\n\t      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!requestParameters.clean) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (document.onImportEnd != null) {\n\t        invokeEventListener(document.onImportEnd);\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t\tif(requestParameters.debug) {\n\t\t\t\trequestParameters.debugVerboseOutput = getDebugLogger().output;\t\n\t\t\t}\n\t\t}\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    document = dataImporter.getConfig().document;\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = requestParameters.entities;\n\t\n\t    // Trigger onImportStart\n\t    if (document.onImportStart != null) {\n\t      invokeEventListener(document.onImportStart);\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    for (DataConfig.Entity e : document.entities) {\n\t      if (entities != null && !entities.contains(e.name))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      root = e;\n\t      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!requestParameters.clean) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (document.onImportEnd != null) {\n\t        invokeEventListener(document.onImportEnd);\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3a6e343b1381a2a5e2c5ad686897b43066ab60a9","date":1332870515,"type":3,"author":"Chris M. Hostetter","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    document = dataImporter.getConfig().document;\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = requestParameters.entities;\n\t\n\t    // Trigger onImportStart\n\t    if (document.onImportStart != null) {\n\t      invokeEventListener(document.onImportStart);\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    for (DataConfig.Entity e : document.entities) {\n\t      if (entities != null && !entities.contains(e.name))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      root = e;\n\t      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!requestParameters.clean) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (document.onImportEnd != null) {\n\t        invokeEventListener(document.onImportEnd);\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t\tif(requestParameters.debug) {\n\t\t\t\trequestParameters.debugVerboseOutput = getDebugLogger().output;\t\n\t\t\t}\n\t\t}\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    document = dataImporter.getConfig().document;\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = requestParameters.entities;\n\t\n\t    // Trigger onImportStart\n\t    if (document.onImportStart != null) {\n\t      invokeEventListener(document.onImportStart);\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    for (DataConfig.Entity e : document.entities) {\n\t      if (entities != null && !entities.contains(e.name))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      root = e;\n\t      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!requestParameters.clean) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (document.onImportEnd != null) {\n\t        invokeEventListener(document.onImportEnd);\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken \", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t\tif(requestParameters.debug) {\n\t\t\t\trequestParameters.debugVerboseOutput = getDebugLogger().output;\t\n\t\t\t}\n\t\t}\n  }\n\n","bugFix":["7a136026dd5340a1feb1e3efd8cafe390616c1d8"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c","date":1335805170,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    config = dataImporter.getConfig();\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = reqParams.getEntitiesToRun();\n\t\n\t    // Trigger onImportStart\n\t    if (config.getOnImportStart() != null) {\n\t      invokeEventListener(config.getOnImportStart());\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    \n\t    epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n\t    for (Entity e : config.getEntities()) {\n\t      epwList.add(getEntityProcessorWrapper(e));\n\t    }\t    \n\t    for (EntityProcessorWrapper epw : epwList) {\n\t      if (entities != null && !entities.contains(epw.getEntity().getName()))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      currentEntityProcessorWrapper = epw;\n\t      String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!reqParams.isClean()) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (config.getOnImportEnd() != null) {\n\t        invokeEventListener(config.getOnImportEnd());\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t\tif (epwList != null) {\n\t\t\t  closeEntityProcessorWrappers(epwList);\n\t\t\t}\n\t\t\tif(reqParams.isDebug()) {\n\t\t\t\treqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\t\n\t\t\t}\n\t\t}\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    document = dataImporter.getConfig().document;\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = requestParameters.entities;\n\t\n\t    // Trigger onImportStart\n\t    if (document.onImportStart != null) {\n\t      invokeEventListener(document.onImportStart);\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    for (DataConfig.Entity e : document.entities) {\n\t      if (entities != null && !entities.contains(e.name))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(e.name + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      root = e;\n\t      String delQuery = e.allAttributes.get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = e.allAttributes.get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!requestParameters.clean) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (document.onImportEnd != null) {\n\t        invokeEventListener(document.onImportEnd);\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t\tif(requestParameters.debug) {\n\t\t\t\trequestParameters.debugVerboseOutput = getDebugLogger().output;\t\n\t\t\t}\n\t\t}\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4093b270ba337f9c25a4c0e6cb2ae2c07f697376","date":1347897716,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Properties lastIndexTimeProps = new Properties();\n      lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.setProperty(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY,\n                DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n  \ttry {\n\t    dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n\t    config = dataImporter.getConfig();\n\t    final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n\t    statusMessages.put(TIME_ELAPSED, new Object() {\n\t      @Override\n\t      public String toString() {\n\t        return getTimeElapsedSince(startTime.get());\n\t      }\n\t    });\n\t\n\t    statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n\t            importStatistics.queryCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n\t            importStatistics.rowsCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n\t            importStatistics.docCount);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n\t            importStatistics.skipDocCount);\n\t\n\t    List<String> entities = reqParams.getEntitiesToRun();\n\t\n\t    // Trigger onImportStart\n\t    if (config.getOnImportStart() != null) {\n\t      invokeEventListener(config.getOnImportStart());\n\t    }\n\t    AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n\t    //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n\t    Properties lastIndexTimeProps = new Properties();\n\t    lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n\t            DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\t    \n\t    epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n\t    for (Entity e : config.getEntities()) {\n\t      epwList.add(getEntityProcessorWrapper(e));\n\t    }\t    \n\t    for (EntityProcessorWrapper epw : epwList) {\n\t      if (entities != null && !entities.contains(epw.getEntity().getName()))\n\t        continue;\n\t      lastIndexTimeProps.setProperty(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY,\n\t              DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      currentEntityProcessorWrapper = epw;\n\t      String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n\t      if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doDelta();\n\t        delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      } else {\n\t        cleanByQuery(delQuery, fullCleanDone);\n\t        doFullDump();\n\t        delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n\t        if (delQuery != null) {\n\t          fullCleanDone.set(false);\n\t          cleanByQuery(delQuery, fullCleanDone);\n\t        }\n\t      }\n\t      statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n\t    }\n\t\n\t    if (stop.get()) {\n\t      // Dont commit if aborted using command=abort\n\t      statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n\t      rollback();\n\t    } else {\n\t      // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n\t      if (!reqParams.isClean()) {\n\t        if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n\t          finish(lastIndexTimeProps);\n\t        }\n\t      } else {\n\t        // Finished operation normally, commit now\n\t        finish(lastIndexTimeProps);\n\t      } \n\t      \n\t      if (config.getOnImportEnd() != null) {\n\t        invokeEventListener(config.getOnImportEnd());\n\t      }\n\t    }\n\t\n\t    statusMessages.remove(TIME_ELAPSED);\n\t    statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n\t    if(importStatistics.failedDocCount.get() > 0)\n\t      statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\t\n\t    statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n\t    LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n\t  } catch(Exception e)\n\t\t{\n\t\t\tthrow new RuntimeException(e);\n\t\t} finally\n\t\t{\n\t\t\tif (writer != null) {\n\t      writer.close();\n\t    }\n\t\t\tif (epwList != null) {\n\t\t\t  closeEntityProcessorWrappers(epwList);\n\t\t\t}\n\t\t\tif(reqParams.isDebug()) {\n\t\t\t\treqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\t\n\t\t\t}\n\t\t}\n  }\n\n","bugFix":null,"bugIntro":["29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5","30ebe66024efbb9ef4d187eaa11ca4101443899c"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b4804614e0358954d5d9f51128fcf3cd79e6e25b","date":1352831451,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Properties lastIndexTimeProps = new Properties();\n      lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.setProperty(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY,\n                DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7c7b0ae5716b6c2044195a818e9ae58205175659","date":1353342230,"type":3,"author":"James Dyer","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"407687e67faf6e1f02a211ca078d8e3eed631027","date":1355157407,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Properties lastIndexTimeProps = new Properties();\n      lastIndexTimeProps.setProperty(LAST_INDEX_KEY,\n              DataImporter.DATE_TIME_FORMAT.get().format(dataImporter.getIndexStartTime()));\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.setProperty(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY,\n                DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", DataImporter.DATE_TIME_FORMAT.get().format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.currentTimeMillis());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"634f330c54fd3f9f491d52036dc3f40b4f4d8934","date":1394635157,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<String,Object>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<EntityProcessorWrapper>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5","date":1406290788,"type":3,"author":"Erik Hatcher","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        rollback();\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"30ebe66024efbb9ef4d187eaa11ca4101443899c","date":1425866380,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","date":1427779360,"type":3,"author":"Ryan Ernst","isMerge":true,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n        statusMessages.remove(DataImporter.MSG.TOTAL_DOC_PROCESSED);\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      log.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      LOG.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a966532d92cf9ba2856f15a8140151bb6b518e4b","date":1588290631,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      if (log.isInfoEnabled()) {\n        log.info(\"Time taken = {}\", getTimeElapsedSince(startTime.get()));\n      }\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      log.info(\"Time taken = \" + getTimeElapsedSince(startTime.get()));\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b264009df2094f05e5381f1b8c77c1a26e7bce3f","date":1597368091,"type":3,"author":"Jason Gerlowski","isMerge":false,"pathNew":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      if (log.isInfoEnabled()) {\n        log.info(\"Time taken = {}\", getTimeElapsedSince(startTime.get()));\n      }\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally {\n      // Cannot use IOUtils.closeQuietly since DIH relies on exceptions bubbling out of writer.close() to indicate\n      // success/failure of the run.\n      RuntimeException raisedDuringClose = null;\n      try {\n        if (writer != null) {\n          writer.close();\n        }\n      } catch (RuntimeException e) {\n        if (log.isWarnEnabled()) {\n          log.warn(\"Exception encountered while closing DIHWriter \" + writer + \"; temporarily suppressing to ensure other DocBuilder elements are closed\", e); // logOk\n        }\n        raisedDuringClose = e;\n      }\n\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n\n      if (raisedDuringClose != null) {\n        throw raisedDuringClose;\n      }\n    }\n  }\n\n","sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      if (log.isInfoEnabled()) {\n        log.info(\"Time taken = {}\", getTimeElapsedSince(startTime.get()));\n      }\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally\n    {\n      if (writer != null) {\n        writer.close();\n      }\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b","date":1598712724,"type":4,"author":"Alexandre Rafalovitch","isMerge":false,"pathNew":"/dev/null","pathOld":"solr/contrib/dataimporthandler/src/java/org/apache/solr/handler/dataimport/DocBuilder#execute().mjava","sourceNew":null,"sourceOld":"  @SuppressWarnings(\"unchecked\")\n  public void execute() {\n    List<EntityProcessorWrapper> epwList = null;\n    try {\n      dataImporter.store(DataImporter.STATUS_MSGS, statusMessages);\n      config = dataImporter.getConfig();\n      final AtomicLong startTime = new AtomicLong(System.nanoTime());\n      statusMessages.put(TIME_ELAPSED, new Object() {\n        @Override\n        public String toString() {\n          return getTimeElapsedSince(startTime.get());\n        }\n      });\n\n      statusMessages.put(DataImporter.MSG.TOTAL_QUERIES_EXECUTED,\n              importStatistics.queryCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_ROWS_EXECUTED,\n              importStatistics.rowsCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED,\n              importStatistics.docCount);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOCS_SKIPPED,\n              importStatistics.skipDocCount);\n\n      List<String> entities = reqParams.getEntitiesToRun();\n\n      // Trigger onImportStart\n      if (config.getOnImportStart() != null) {\n        invokeEventListener(config.getOnImportStart());\n      }\n      AtomicBoolean fullCleanDone = new AtomicBoolean(false);\n      //we must not do a delete of *:* multiple times if there are multiple root entities to be run\n      Map<String,Object> lastIndexTimeProps = new HashMap<>();\n      lastIndexTimeProps.put(LAST_INDEX_KEY, dataImporter.getIndexStartTime());\n\n      epwList = new ArrayList<>(config.getEntities().size());\n      for (Entity e : config.getEntities()) {\n        epwList.add(getEntityProcessorWrapper(e));\n      }\n      for (EntityProcessorWrapper epw : epwList) {\n        if (entities != null && !entities.contains(epw.getEntity().getName()))\n          continue;\n        lastIndexTimeProps.put(epw.getEntity().getName() + \".\" + LAST_INDEX_KEY, propWriter.getCurrentTimestamp());\n        currentEntityProcessorWrapper = epw;\n        String delQuery = epw.getEntity().getAllAttributes().get(\"preImportDeleteQuery\");\n        if (dataImporter.getStatus() == DataImporter.Status.RUNNING_DELTA_DUMP) {\n          cleanByQuery(delQuery, fullCleanDone);\n          doDelta();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        } else {\n          cleanByQuery(delQuery, fullCleanDone);\n          doFullDump();\n          delQuery = epw.getEntity().getAllAttributes().get(\"postImportDeleteQuery\");\n          if (delQuery != null) {\n            fullCleanDone.set(false);\n            cleanByQuery(delQuery, fullCleanDone);\n          }\n        }\n      }\n\n      if (stop.get()) {\n        // Dont commit if aborted using command=abort\n        statusMessages.put(\"Aborted\", new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\", Locale.ROOT).format(new Date()));\n        handleError(\"Aborted\", null);\n      } else {\n        // Do not commit unnecessarily if this is a delta-import and no documents were created or deleted\n        if (!reqParams.isClean()) {\n          if (importStatistics.docCount.get() > 0 || importStatistics.deletedDocCount.get() > 0) {\n            finish(lastIndexTimeProps);\n          }\n        } else {\n          // Finished operation normally, commit now\n          finish(lastIndexTimeProps);\n        }\n\n        if (config.getOnImportEnd() != null) {\n          invokeEventListener(config.getOnImportEnd());\n        }\n      }\n\n      statusMessages.remove(TIME_ELAPSED);\n      statusMessages.put(DataImporter.MSG.TOTAL_DOC_PROCESSED, \"\"+ importStatistics.docCount.get());\n      if(importStatistics.failedDocCount.get() > 0)\n        statusMessages.put(DataImporter.MSG.TOTAL_FAILED_DOCS, \"\"+ importStatistics.failedDocCount.get());\n\n      statusMessages.put(\"Time taken\", getTimeElapsedSince(startTime.get()));\n      if (log.isInfoEnabled()) {\n        log.info(\"Time taken = {}\", getTimeElapsedSince(startTime.get()));\n      }\n    } catch(Exception e)\n    {\n      throw new RuntimeException(e);\n    } finally {\n      // Cannot use IOUtils.closeQuietly since DIH relies on exceptions bubbling out of writer.close() to indicate\n      // success/failure of the run.\n      RuntimeException raisedDuringClose = null;\n      try {\n        if (writer != null) {\n          writer.close();\n        }\n      } catch (RuntimeException e) {\n        if (log.isWarnEnabled()) {\n          log.warn(\"Exception encountered while closing DIHWriter \" + writer + \"; temporarily suppressing to ensure other DocBuilder elements are closed\", e); // logOk\n        }\n        raisedDuringClose = e;\n      }\n\n      if (epwList != null) {\n        closeEntityProcessorWrappers(epwList);\n      }\n      if(reqParams.isDebug()) {\n        reqParams.getDebugInfo().debugVerboseOutput = getDebugLogger().output;\n      }\n\n      if (raisedDuringClose != null) {\n        throw raisedDuringClose;\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c":["3a6e343b1381a2a5e2c5ad686897b43066ab60a9"],"7c7b0ae5716b6c2044195a818e9ae58205175659":["b4804614e0358954d5d9f51128fcf3cd79e6e25b"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"407687e67faf6e1f02a211ca078d8e3eed631027":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376","7c7b0ae5716b6c2044195a818e9ae58205175659"],"f95755793ac5f02eed6154c705e8638e001a5a0a":["7a136026dd5340a1feb1e3efd8cafe390616c1d8"],"3a6e343b1381a2a5e2c5ad686897b43066ab60a9":["f95755793ac5f02eed6154c705e8638e001a5a0a"],"29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"30ebe66024efbb9ef4d187eaa11ca4101443899c":["29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["7c7b0ae5716b6c2044195a818e9ae58205175659"],"b4804614e0358954d5d9f51128fcf3cd79e6e25b":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":["29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5","30ebe66024efbb9ef4d187eaa11ca4101443899c"],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["b264009df2094f05e5381f1b8c77c1a26e7bce3f"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7a136026dd5340a1feb1e3efd8cafe390616c1d8":["c26f00b574427b55127e869b935845554afde1fa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"b264009df2094f05e5381f1b8c77c1a26e7bce3f":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["30ebe66024efbb9ef4d187eaa11ca4101443899c"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c"]},"commit2Childs":{"634f330c54fd3f9f491d52036dc3f40b4f4d8934":["29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5"],"4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c":["4093b270ba337f9c25a4c0e6cb2ae2c07f697376"],"7c7b0ae5716b6c2044195a818e9ae58205175659":["407687e67faf6e1f02a211ca078d8e3eed631027","fd5bc858b8426d40bbe90b94120ead37c77d7954"],"c26f00b574427b55127e869b935845554afde1fa":["7a136026dd5340a1feb1e3efd8cafe390616c1d8"],"407687e67faf6e1f02a211ca078d8e3eed631027":[],"f95755793ac5f02eed6154c705e8638e001a5a0a":["3a6e343b1381a2a5e2c5ad686897b43066ab60a9"],"3a6e343b1381a2a5e2c5ad686897b43066ab60a9":["4ebea96bbe279c4a8dc0cd5cd1f987cc9b33436c"],"29d10c9c22fbdfa86201e6eb9d1cdd3a3870dde5":["30ebe66024efbb9ef4d187eaa11ca4101443899c","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae"],"a966532d92cf9ba2856f15a8140151bb6b518e4b":["b264009df2094f05e5381f1b8c77c1a26e7bce3f"],"30ebe66024efbb9ef4d187eaa11ca4101443899c":["a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["634f330c54fd3f9f491d52036dc3f40b4f4d8934"],"b4804614e0358954d5d9f51128fcf3cd79e6e25b":["7c7b0ae5716b6c2044195a818e9ae58205175659"],"a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae":[],"d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"5128b7b3b73fedff05fdc5ea2e6be53c1020bb91":["c26f00b574427b55127e869b935845554afde1fa"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c26f00b574427b55127e869b935845554afde1fa","5128b7b3b73fedff05fdc5ea2e6be53c1020bb91"],"7a136026dd5340a1feb1e3efd8cafe390616c1d8":["f95755793ac5f02eed6154c705e8638e001a5a0a"],"4093b270ba337f9c25a4c0e6cb2ae2c07f697376":["407687e67faf6e1f02a211ca078d8e3eed631027","b4804614e0358954d5d9f51128fcf3cd79e6e25b"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["a966532d92cf9ba2856f15a8140151bb6b518e4b"],"b264009df2094f05e5381f1b8c77c1a26e7bce3f":["d2c8f5c46c2501b61e2f55eb7ee59e6c5372290b"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["407687e67faf6e1f02a211ca078d8e3eed631027","a0d1e2aaf870d9d4f740ed0aaaf5824ccd9394ae","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}