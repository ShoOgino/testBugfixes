{"path":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","commits":[{"id":"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4","date":1368446242,"type":0,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"/dev/null","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            _TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            _TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19275ba31e621f6da1b83bf13af75233876fd3d4","date":1374846698,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            _TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            _TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            _TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            _TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","date":1376366778,"type":3,"author":"Han Jiang","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            _TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            _TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            _TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            _TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6613659748fe4411a7dcf85266e55db1f95f7315","date":1392773913,"type":3,"author":"Benson Margulies","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            _TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            _TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7db7409bfbd77f7fc6c5b7fff4acca86d7114106","date":1409821428,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate());\n            checker.setFailFast(true);\n            checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n            CheckIndex.Status indexStatus = null;\n            try {\n              indexStatus = checker.checkIndex(null);\n            } catch (IOException ioe) {\n              // ok: we fallback below\n            } catch (RuntimeException re) {\n              // ok: we fallback below\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate\n            TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n          } catch (IOException e) {\n            throw new RuntimeException(e);\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          if (t instanceof RuntimeException) throw (RuntimeException) t;\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f7523916a1350712e1ae710affd4e88ccd7c431d","date":1412161942,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException ioe) {\n                // ok: we fallback below\n              } catch (RuntimeException re) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate());\n            checker.setFailFast(true);\n            checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n            CheckIndex.Status indexStatus = null;\n            try {\n              indexStatus = checker.checkIndex(null);\n            } catch (IOException ioe) {\n              // ok: we fallback below\n            } catch (RuntimeException re) {\n              // ok: we fallback below\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":["7db7409bfbd77f7fc6c5b7fff4acca86d7114106"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d9a47902d6207303f5ed3e7aaca62ca33433af66","date":1412435312,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException ioe) {\n                // ok: we fallback below\n              } catch (RuntimeException re) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate());\n            checker.setFailFast(true);\n            checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n            CheckIndex.Status indexStatus = null;\n            try {\n              indexStatus = checker.checkIndex(null);\n            } catch (IOException ioe) {\n              // ok: we fallback below\n            } catch (RuntimeException re) {\n              // ok: we fallback below\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6","date":1421884114,"type":3,"author":"Shalin Shekhar Mangar","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException ioe) {\n                // ok: we fallback below\n              } catch (RuntimeException re) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bfe104fc023fadc9e709f8d17403d2cc61133fe","date":1454446396,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b470f36a9372c97283360b1304eacbde22df6c0d","date":1454765175,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1e6acbaae7af722f17204ceccf0f7db5753eccf3","date":1454775255,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5a207d19eac354d649c3f0e2cce070017c78125e","date":1454776470,"type":3,"author":"Erick Erickson","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n            if (indexStatus == null || indexStatus.clean == false) {\n\n              // Because segments file for taxo index is replicated after\n              // main index's segments file, if there's an error while replicating\n              // main index's segments file and if virus checker prevents\n              // deletion of taxo index's segments file, it can look like corruption.\n              // But it should be \"false\" meaning if we remove the latest segments\n              // file then the index is intact.  It's like pulling a hideous\n              // looking rock out of the ground, but then you pull the cruft\n              // off the outside of it and discover it's actually a beautiful\n              // diamond:\n              String segmentsFileName = SegmentInfos.getLastCommitSegmentsFileName(handlerTaxoDir);\n              assertTrue(handlerTaxoDir.didTryToDelete(segmentsFileName));\n              handlerTaxoDir.getDelegate().deleteFile(segmentsFileName);\n              TestUtil.checkIndex(handlerTaxoDir.getDelegate());\n            }\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"11c6df42fb3eba174c3ca0d9a5194eaecd893b77","date":1465931757,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","pathOld":"lucene/replicator/src/test/org/apache/lucene/replicator/IndexAndTaxonomyReplicationClientTest#testConsistencyOnExceptions().mjava","sourceNew":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","sourceOld":"  /*\n   * This test verifies that the client and handler do not end up in a corrupt\n   * index if exceptions are thrown at any point during replication. Either when\n   * a client copies files from the server to the temporary space, or when the\n   * handler copies them to the index directory.\n   */\n  @Test\n  public void testConsistencyOnExceptions() throws Exception {\n    // so the handler's index isn't empty\n    replicator.publish(createRevision(1));\n    client.updateNow();\n    client.close();\n    callback.close();\n\n    // Replicator violates write-once policy. It may be that the\n    // handler copies files to the index dir, then fails to copy a\n    // file and reverts the copy operation. On the next attempt, it\n    // will copy the same file again. There is nothing wrong with this\n    // in a real system, but it does violate write-once, and MDW\n    // doesn't like it. Disabling it means that we won't catch cases\n    // where the handler overwrites an existing index file, but\n    // there's nothing currently we can do about it, unless we don't\n    // use MDW.\n    handlerIndexDir.setPreventDoubleWrite(false);\n    handlerTaxoDir.setPreventDoubleWrite(false);\n\n    // wrap sourceDirFactory to return a MockDirWrapper so we can simulate errors\n    final SourceDirectoryFactory in = sourceDirFactory;\n    final AtomicInteger failures = new AtomicInteger(atLeast(10));\n    sourceDirFactory = new SourceDirectoryFactory() {\n      \n      private long clientMaxSize = 100, handlerIndexMaxSize = 100, handlerTaxoMaxSize = 100;\n      private double clientExRate = 1.0, handlerIndexExRate = 1.0, handlerTaxoExRate = 1.0;\n      \n      @Override\n      public void cleanupSession(String sessionID) throws IOException {\n        in.cleanupSession(sessionID);\n      }\n      \n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      public Directory getDirectory(String sessionID, String source) throws IOException {\n        Directory dir = in.getDirectory(sessionID, source);\n        if (random().nextBoolean() && failures.get() > 0) { // client should fail, return wrapped dir\n          MockDirectoryWrapper mdw = new MockDirectoryWrapper(random(), dir);\n          mdw.setRandomIOExceptionRateOnOpen(clientExRate);\n          mdw.setMaxSizeInBytes(clientMaxSize);\n          mdw.setRandomIOExceptionRate(clientExRate);\n          mdw.setCheckIndexOnClose(false);\n          clientMaxSize *= 2;\n          clientExRate /= 2;\n          return mdw;\n        }\n        \n        if (failures.get() > 0 && random().nextBoolean()) { // handler should fail\n          if (random().nextBoolean()) { // index dir fail\n            handlerIndexDir.setMaxSizeInBytes(handlerIndexMaxSize);\n            handlerIndexDir.setRandomIOExceptionRate(handlerIndexExRate);\n            handlerIndexDir.setRandomIOExceptionRateOnOpen(handlerIndexExRate);\n            handlerIndexMaxSize *= 2;\n            handlerIndexExRate /= 2;\n          } else { // taxo dir fail\n            handlerTaxoDir.setMaxSizeInBytes(handlerTaxoMaxSize);\n            handlerTaxoDir.setRandomIOExceptionRate(handlerTaxoExRate);\n            handlerTaxoDir.setRandomIOExceptionRateOnOpen(handlerTaxoExRate);\n            handlerTaxoDir.setCheckIndexOnClose(false);\n            handlerTaxoMaxSize *= 2;\n            handlerTaxoExRate /= 2;\n          }\n        } else {\n          // disable all errors\n          handlerIndexDir.setMaxSizeInBytes(0);\n          handlerIndexDir.setRandomIOExceptionRate(0.0);\n          handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n          handlerTaxoDir.setMaxSizeInBytes(0);\n          handlerTaxoDir.setRandomIOExceptionRate(0.0);\n          handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n        }\n\n        return dir;\n      }\n    };\n    \n    handler = new IndexAndTaxonomyReplicationHandler(handlerIndexDir, handlerTaxoDir, new Callable<Boolean>() {\n      @Override\n      public Boolean call() throws Exception {\n        if (random().nextDouble() < 0.2 && failures.get() > 0) {\n          throw new RuntimeException(\"random exception from callback\");\n        }\n        return null;\n      }\n    });\n\n    final AtomicBoolean failed = new AtomicBoolean();\n\n    // wrap handleUpdateException so we can act on the thrown exception\n    client = new ReplicationClient(replicator, handler, sourceDirFactory) {\n      @SuppressWarnings(\"synthetic-access\")\n      @Override\n      protected void handleUpdateException(Throwable t) {\n        if (t instanceof IOException) {\n          try {\n            if (VERBOSE) {\n              System.out.println(\"hit exception during update: \" + t);\n              t.printStackTrace(System.out);\n            }\n\n            // test that the index can be read and also some basic statistics\n            DirectoryReader reader = DirectoryReader.open(handlerIndexDir.getDelegate());\n            try {\n              int numDocs = reader.numDocs();\n              int version = Integer.parseInt(reader.getIndexCommit().getUserData().get(VERSION_ID), 16);\n              assertEquals(numDocs, version);\n            } finally {\n              reader.close();\n            }\n            // verify index is fully consistent\n            TestUtil.checkIndex(handlerIndexDir.getDelegate());\n            \n            // verify taxonomy index is fully consistent (since we only add one\n            // category to all documents, there's nothing much more to validate.\n            ByteArrayOutputStream bos = new ByteArrayOutputStream(1024);\n            CheckIndex.Status indexStatus = null;\n\n            try (CheckIndex checker = new CheckIndex(handlerTaxoDir.getDelegate())) {\n              checker.setFailFast(true);\n              checker.setInfoStream(new PrintStream(bos, false, IOUtils.UTF_8), false);\n              try {\n                indexStatus = checker.checkIndex(null);\n              } catch (IOException | RuntimeException ioe) {\n                // ok: we fallback below\n              }\n            }\n\n          } catch (IOException e) {\n            failed.set(true);\n            throw new RuntimeException(e);\n          } catch (RuntimeException e) {\n            failed.set(true);\n            throw e;\n          } finally {\n            // count-down number of failures\n            failures.decrementAndGet();\n            assert failures.get() >= 0 : \"handler failed too many times: \" + failures.get();\n            if (VERBOSE) {\n              if (failures.get() == 0) {\n                System.out.println(\"no more failures expected\");\n              } else {\n                System.out.println(\"num failures left: \" + failures.get());\n              }\n            }\n          }\n        } else {\n          failed.set(true);\n          if (t instanceof RuntimeException) {\n            throw (RuntimeException) t;\n          }\n          throw new RuntimeException(t);\n        }\n      }\n    };\n    \n    client.startUpdateThread(10, \"indexAndTaxo\");\n    \n    final Directory baseHandlerIndexDir = handlerIndexDir.getDelegate();\n    int numRevisions = atLeast(20) + 2;\n    for (int i = 2; i < numRevisions && failed.get() == false; i++) {\n      replicator.publish(createRevision(i));\n      assertHandlerRevision(i, baseHandlerIndexDir);\n    }\n\n    // disable errors -- maybe randomness didn't exhaust all allowed failures,\n    // and we don't want e.g. CheckIndex to hit false errors. \n    handlerIndexDir.setMaxSizeInBytes(0);\n    handlerIndexDir.setRandomIOExceptionRate(0.0);\n    handlerIndexDir.setRandomIOExceptionRateOnOpen(0.0);\n    handlerTaxoDir.setMaxSizeInBytes(0);\n    handlerTaxoDir.setRandomIOExceptionRate(0.0);\n    handlerTaxoDir.setRandomIOExceptionRateOnOpen(0.0);\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"6613659748fe4411a7dcf85266e55db1f95f7315":["19275ba31e621f6da1b83bf13af75233876fd3d4"],"5a207d19eac354d649c3f0e2cce070017c78125e":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6","b470f36a9372c97283360b1304eacbde22df6c0d"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6","b470f36a9372c97283360b1304eacbde22df6c0d"],"f7523916a1350712e1ae710affd4e88ccd7c431d":["7db7409bfbd77f7fc6c5b7fff4acca86d7114106"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["5a207d19eac354d649c3f0e2cce070017c78125e"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":["7db7409bfbd77f7fc6c5b7fff4acca86d7114106","f7523916a1350712e1ae710affd4e88ccd7c431d"],"19275ba31e621f6da1b83bf13af75233876fd3d4":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"7db7409bfbd77f7fc6c5b7fff4acca86d7114106":["6613659748fe4411a7dcf85266e55db1f95f7315"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["5a207d19eac354d649c3f0e2cce070017c78125e","11c6df42fb3eba174c3ca0d9a5194eaecd893b77"],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6":["f7523916a1350712e1ae710affd4e88ccd7c431d"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["5891bd634d5ddbf7c48cff0f4818c682ca42a4a6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77"]},"commit2Childs":{"6613659748fe4411a7dcf85266e55db1f95f7315":["7db7409bfbd77f7fc6c5b7fff4acca86d7114106"],"5a207d19eac354d649c3f0e2cce070017c78125e":["11c6df42fb3eba174c3ca0d9a5194eaecd893b77","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"1e6acbaae7af722f17204ceccf0f7db5753eccf3":[],"f7523916a1350712e1ae710affd4e88ccd7c431d":["d9a47902d6207303f5ed3e7aaca62ca33433af66","5891bd634d5ddbf7c48cff0f4818c682ca42a4a6"],"11c6df42fb3eba174c3ca0d9a5194eaecd893b77":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"d9a47902d6207303f5ed3e7aaca62ca33433af66":[],"19275ba31e621f6da1b83bf13af75233876fd3d4":["6613659748fe4411a7dcf85266e55db1f95f7315"],"7db7409bfbd77f7fc6c5b7fff4acca86d7114106":["f7523916a1350712e1ae710affd4e88ccd7c431d","d9a47902d6207303f5ed3e7aaca62ca33433af66"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"9854b7e4603d5c26909c27363aa7bc9fc4d11ef4":["19275ba31e621f6da1b83bf13af75233876fd3d4","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee"],"5891bd634d5ddbf7c48cff0f4818c682ca42a4a6":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3","b470f36a9372c97283360b1304eacbde22df6c0d","6bfe104fc023fadc9e709f8d17403d2cc61133fe"],"b470f36a9372c97283360b1304eacbde22df6c0d":["5a207d19eac354d649c3f0e2cce070017c78125e","1e6acbaae7af722f17204ceccf0f7db5753eccf3"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["9854b7e4603d5c26909c27363aa7bc9fc4d11ef4"],"8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee":[],"6bfe104fc023fadc9e709f8d17403d2cc61133fe":["b470f36a9372c97283360b1304eacbde22df6c0d"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["1e6acbaae7af722f17204ceccf0f7db5753eccf3","d9a47902d6207303f5ed3e7aaca62ca33433af66","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","8989a9672fc1bb2d9a549a4f9005a7d0b0d728ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}