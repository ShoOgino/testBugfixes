{"path":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","commits":[{"id":"3f4ef2de7b0fd59ef22e20888773ad260c90bfb4","date":1400183621,"type":0,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d637064d608752565d4f9f41b2497dfdfdde50e","date":1400798123,"type":0,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"/dev/null","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6bcc4b6a839799ea8a62ca12ac44438c5607f786","date":1406654443,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // nocommit?\n            //if (exactOnly) {\n            //fillTerm();\n            //termExists = true;\n            //}\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f","date":1406654493,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            // nocommit?\n            //if (exactOnly) {\n            //fillTerm();\n            //termExists = true;\n            //}\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","date":1407854805,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length);\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":["3f4ef2de7b0fd59ef22e20888773ad260c90bfb4"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3e8715d826e588419327562287d5d6a8040d63d6","date":1427987148,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    nextTerm: while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      if (versionAutoPrefix == false) {\n        suffix = code >>> 1;\n      } else {\n        suffix = code >>> 2;\n      }\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (versionAutoPrefix == false) {\n        ste.termExists = (code & 1) == 0;\n        if (ste.termExists) {\n          state.termBlockOrd++;\n          subCode = 0;\n        } else {\n          subCode = suffixesReader.readVLong();\n          lastSubFP = fp - subCode;\n        }\n      } else {\n        switch (code & 3) {\n        case 0:\n          // Normal term\n          ste.termExists = true;\n          state.termBlockOrd++;\n          subCode = 0;\n          break;\n        case 1:\n          // Sub-block\n          ste.termExists = false;\n          subCode = suffixesReader.readVLong();\n          lastSubFP = fp - subCode;\n          break;\n        case 2:\n        case 3:\n          // Floor prefix term: skip it\n          //if (DEBUG) System.out.println(\"        skip floor prefix term\");\n          suffixesReader.readByte();\n          ste.termExists = false;\n          state.termBlockOrd++;\n          continue;\n        }\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while (true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n          continue nextTerm;\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n          if (!exactOnly && !ste.termExists) {\n            //System.out.println(\"  now pushFrame\");\n            // TODO this \n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d2638f781be724518ff6c2263d14a48cf6e68017","date":1427989059,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    nextTerm: while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      if (versionAutoPrefix == false) {\n        suffix = code >>> 1;\n      } else {\n        suffix = code >>> 2;\n      }\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (versionAutoPrefix == false) {\n        ste.termExists = (code & 1) == 0;\n        if (ste.termExists) {\n          state.termBlockOrd++;\n          subCode = 0;\n        } else {\n          subCode = suffixesReader.readVLong();\n          lastSubFP = fp - subCode;\n        }\n      } else {\n        switch (code & 3) {\n        case 0:\n          // Normal term\n          ste.termExists = true;\n          state.termBlockOrd++;\n          subCode = 0;\n          break;\n        case 1:\n          // Sub-block\n          ste.termExists = false;\n          subCode = suffixesReader.readVLong();\n          lastSubFP = fp - subCode;\n          break;\n        case 2:\n        case 3:\n          // Floor prefix term: skip it\n          //if (DEBUG) System.out.println(\"        skip floor prefix term\");\n          suffixesReader.readByte();\n          ste.termExists = false;\n          state.termBlockOrd++;\n          continue;\n        }\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while (true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n          continue nextTerm;\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n          if (!exactOnly && !ste.termExists) {\n            //System.out.println(\"  now pushFrame\");\n            // TODO this \n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(term));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    //nextTerm: while(nextEnt < entCount) {\n    nextTerm: while (true) {\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n      // if (DEBUG) {\n      //   BytesRef suffixBytesRef = new BytesRef();\n      //   suffixBytesRef.bytes = suffixBytes;\n      //   suffixBytesRef.offset = suffixesReader.getPosition();\n      //   suffixBytesRef.length = suffix;\n      //   System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      // }\n\n      ste.termExists = (code & 1) == 0;\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while(true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n\n          if (nextEnt == entCount) {\n            if (exactOnly) {\n              fillTerm();\n              //termExists = true;\n            }\n            // We are done scanning this block\n            break nextTerm;\n          } else {\n            continue nextTerm;\n          }\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          if (!exactOnly && !ste.termExists) {\n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b7d165dc88e14a2b2f1cc4ac8133ffdde44acfd5","date":1488285484,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    nextTerm: while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while (true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n          continue nextTerm;\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n          if (!exactOnly && !ste.termExists) {\n            //System.out.println(\"  now pushFrame\");\n            // TODO this \n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    nextTerm: while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      if (versionAutoPrefix == false) {\n        suffix = code >>> 1;\n      } else {\n        suffix = code >>> 2;\n      }\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      if (versionAutoPrefix == false) {\n        ste.termExists = (code & 1) == 0;\n        if (ste.termExists) {\n          state.termBlockOrd++;\n          subCode = 0;\n        } else {\n          subCode = suffixesReader.readVLong();\n          lastSubFP = fp - subCode;\n        }\n      } else {\n        switch (code & 3) {\n        case 0:\n          // Normal term\n          ste.termExists = true;\n          state.termBlockOrd++;\n          subCode = 0;\n          break;\n        case 1:\n          // Sub-block\n          ste.termExists = false;\n          subCode = suffixesReader.readVLong();\n          lastSubFP = fp - subCode;\n          break;\n        case 2:\n        case 3:\n          // Floor prefix term: skip it\n          //if (DEBUG) System.out.println(\"        skip floor prefix term\");\n          suffixesReader.readByte();\n          ste.termExists = false;\n          state.termBlockOrd++;\n          continue;\n        }\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while (true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n          continue nextTerm;\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n          if (!exactOnly && !ste.termExists) {\n            //System.out.println(\"  now pushFrame\");\n            // TODO this \n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d305023fa6a3a568a5d704ecfcf8c9b1dff83415","date":1578578961,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n        if (!exactOnly && !ste.termExists) {\n          //System.out.println(\"  now pushFrame\");\n          // TODO this \n          // We are on a sub-block, and caller wants\n          // us to position to the next term after\n          // the target, so we must recurse into the\n          // sub-frame(s):\n          ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n          ste.currentFrame.loadBlock();\n          while (ste.currentFrame.next()) {\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n            ste.currentFrame.loadBlock();\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    nextTerm: while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while (true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n          continue nextTerm;\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n          if (!exactOnly && !ste.termExists) {\n            //System.out.println(\"  now pushFrame\");\n            // TODO this \n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24dab91095bdf34d602ca5a18f81df6cb308709f","date":1578594129,"type":3,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n        if (!exactOnly && !ste.termExists) {\n          //System.out.println(\"  now pushFrame\");\n          // TODO this \n          // We are on a sub-block, and caller wants\n          // us to position to the next term after\n          // the target, so we must recurse into the\n          // sub-frame(s):\n          ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n          ste.currentFrame.loadBlock();\n          while (ste.currentFrame.next()) {\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n            ste.currentFrame.loadBlock();\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    nextTerm: while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int targetLimit = target.offset + (target.length < termLen ? target.length : termLen);\n      int targetPos = target.offset + prefix;\n\n      // Loop over bytes in the suffix, comparing to\n      // the target\n      int bytePos = startBytePos;\n      while (true) {\n        final int cmp;\n        final boolean stop;\n        if (targetPos < targetLimit) {\n          cmp = (suffixBytes[bytePos++]&0xFF) - (target.bytes[targetPos++]&0xFF);\n          stop = false;\n        } else {\n          assert targetPos == targetLimit;\n          cmp = termLen - target.length;\n          stop = true;\n        }\n\n        if (cmp < 0) {\n          // Current entry is still before the target;\n          // keep scanning\n          continue nextTerm;\n        } else if (cmp > 0) {\n\n          // Done!  Current entry is after target --\n          // return NOT_FOUND:\n          fillTerm();\n\n          //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n          if (!exactOnly && !ste.termExists) {\n            //System.out.println(\"  now pushFrame\");\n            // TODO this \n            // We are on a sub-block, and caller wants\n            // us to position to the next term after\n            // the target, so we must recurse into the\n            // sub-frame(s):\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n            ste.currentFrame.loadBlock();\n            while (ste.currentFrame.next()) {\n              ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n              ste.currentFrame.loadBlock();\n            }\n          }\n                \n          //if (DEBUG) System.out.println(\"        not found\");\n          return SeekStatus.NOT_FOUND;\n        } else if (stop) {\n          // Exact match!\n\n          // This cannot be a sub-block because we\n          // would have followed the index to this\n          // sub-block from the start:\n\n          assert ste.termExists;\n          fillTerm();\n          //if (DEBUG) System.out.println(\"        found!\");\n          return SeekStatus.FOUND;\n        }\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9407318969e8504257b4c5764c65755a043e5404","date":1579873617,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/codecs/blocktree/SegmentTermsEnumFrame#scanToTermNonLeaf(BytesRef,boolean).mjava","sourceNew":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixLengthsReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixLengthsReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n        if (!exactOnly && !ste.termExists) {\n          //System.out.println(\"  now pushFrame\");\n          // TODO this \n          // We are on a sub-block, and caller wants\n          // us to position to the next term after\n          // the target, so we must recurse into the\n          // sub-frame(s):\n          ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n          ste.currentFrame.loadBlock();\n          while (ste.currentFrame.next()) {\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n            ste.currentFrame.loadBlock();\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","sourceOld":"  // Target's prefix matches this block's prefix; we\n  // scan the entries check if the suffix matches.\n  public SeekStatus scanToTermNonLeaf(BytesRef target, boolean exactOnly) throws IOException {\n\n    //if (DEBUG) System.out.println(\"    scanToTermNonLeaf: block fp=\" + fp + \" prefix=\" + prefix + \" nextEnt=\" + nextEnt + \" (of \" + entCount + \") target=\" + brToString(target) + \" term=\" + brToString(target));\n\n    assert nextEnt != -1;\n\n    if (nextEnt == entCount) {\n      if (exactOnly) {\n        fillTerm();\n        ste.termExists = subCode == 0;\n      }\n      return SeekStatus.END;\n    }\n\n    assert prefixMatches(target);\n\n    // Loop over each entry (term or sub-block) in this block:\n    while(nextEnt < entCount) {\n\n      nextEnt++;\n\n      final int code = suffixesReader.readVInt();\n      suffix = code >>> 1;\n\n      //if (DEBUG) {\n      //  BytesRef suffixBytesRef = new BytesRef();\n      //  suffixBytesRef.bytes = suffixBytes;\n      //  suffixBytesRef.offset = suffixesReader.getPosition();\n      //  suffixBytesRef.length = suffix;\n      //  System.out.println(\"      cycle: \" + ((code&1)==1 ? \"sub-block\" : \"term\") + \" \" + (nextEnt-1) + \" (of \" + entCount + \") suffix=\" + brToString(suffixBytesRef));\n      //}\n\n      final int termLen = prefix + suffix;\n      startBytePos = suffixesReader.getPosition();\n      suffixesReader.skipBytes(suffix);\n      ste.termExists = (code & 1) == 0;\n      if (ste.termExists) {\n        state.termBlockOrd++;\n        subCode = 0;\n      } else {\n        subCode = suffixesReader.readVLong();\n        lastSubFP = fp - subCode;\n      }\n\n      final int cmp = Arrays.compareUnsigned(\n          suffixBytes, startBytePos, startBytePos + suffix,\n          target.bytes, target.offset + prefix, target.offset + target.length);\n\n      if (cmp < 0) {\n        // Current entry is still before the target;\n        // keep scanning\n      } else if (cmp > 0) {\n        // Done!  Current entry is after target --\n        // return NOT_FOUND:\n        fillTerm();\n\n        //if (DEBUG) System.out.println(\"        maybe done exactOnly=\" + exactOnly + \" ste.termExists=\" + ste.termExists);\n\n        if (!exactOnly && !ste.termExists) {\n          //System.out.println(\"  now pushFrame\");\n          // TODO this \n          // We are on a sub-block, and caller wants\n          // us to position to the next term after\n          // the target, so we must recurse into the\n          // sub-frame(s):\n          ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, termLen);\n          ste.currentFrame.loadBlock();\n          while (ste.currentFrame.next()) {\n            ste.currentFrame = ste.pushFrame(null, ste.currentFrame.lastSubFP, ste.term.length());\n            ste.currentFrame.loadBlock();\n          }\n        }\n\n        //if (DEBUG) System.out.println(\"        not found\");\n        return SeekStatus.NOT_FOUND;\n      } else {\n        // Exact match!\n\n        // This cannot be a sub-block because we\n        // would have followed the index to this\n        // sub-block from the start:\n\n        assert ste.termExists;\n        fillTerm();\n        //if (DEBUG) System.out.println(\"        found!\");\n        return SeekStatus.FOUND;\n      }\n    }\n\n    // It is possible (and OK) that terms index pointed us\n    // at this block, but, we scanned the entire block and\n    // did not find the term to position to.  This happens\n    // when the target is after the last term in the block\n    // (but, before the next term in the index).  EG\n    // target could be foozzz, and terms index pointed us\n    // to the foo* block, but the last term in this block\n    // was fooz (and, eg, first term in the next block will\n    // bee fop).\n    //if (DEBUG) System.out.println(\"      block end\");\n    if (exactOnly) {\n      fillTerm();\n    }\n\n    // TODO: not consistent that in the\n    // not-exact case we don't next() into the next\n    // frame here\n    return SeekStatus.END;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f":["6bcc4b6a839799ea8a62ca12ac44438c5607f786"],"3f4ef2de7b0fd59ef22e20888773ad260c90bfb4":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f"],"6bcc4b6a839799ea8a62ca12ac44438c5607f786":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","3f4ef2de7b0fd59ef22e20888773ad260c90bfb4"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"d2638f781be724518ff6c2263d14a48cf6e68017":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50","3e8715d826e588419327562287d5d6a8040d63d6"],"9407318969e8504257b4c5764c65755a043e5404":["d305023fa6a3a568a5d704ecfcf8c9b1dff83415"],"24dab91095bdf34d602ca5a18f81df6cb308709f":["b7d165dc88e14a2b2f1cc4ac8133ffdde44acfd5","d305023fa6a3a568a5d704ecfcf8c9b1dff83415"],"3e8715d826e588419327562287d5d6a8040d63d6":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"d305023fa6a3a568a5d704ecfcf8c9b1dff83415":["b7d165dc88e14a2b2f1cc4ac8133ffdde44acfd5"],"b7d165dc88e14a2b2f1cc4ac8133ffdde44acfd5":["3e8715d826e588419327562287d5d6a8040d63d6"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9407318969e8504257b4c5764c65755a043e5404"]},"commit2Childs":{"f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f":["7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50"],"3f4ef2de7b0fd59ef22e20888773ad260c90bfb4":["4d637064d608752565d4f9f41b2497dfdfdde50e"],"7dc6ea5fd38ce7aa8f36b3bac8b757da77f31d50":["d2638f781be724518ff6c2263d14a48cf6e68017","3e8715d826e588419327562287d5d6a8040d63d6"],"6bcc4b6a839799ea8a62ca12ac44438c5607f786":["f33b0fbfa9799ee8e87c59af19055bf0c62f0e0f"],"4d637064d608752565d4f9f41b2497dfdfdde50e":["6bcc4b6a839799ea8a62ca12ac44438c5607f786"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3f4ef2de7b0fd59ef22e20888773ad260c90bfb4","4d637064d608752565d4f9f41b2497dfdfdde50e"],"d2638f781be724518ff6c2263d14a48cf6e68017":[],"9407318969e8504257b4c5764c65755a043e5404":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"24dab91095bdf34d602ca5a18f81df6cb308709f":[],"3e8715d826e588419327562287d5d6a8040d63d6":["d2638f781be724518ff6c2263d14a48cf6e68017","b7d165dc88e14a2b2f1cc4ac8133ffdde44acfd5"],"d305023fa6a3a568a5d704ecfcf8c9b1dff83415":["9407318969e8504257b4c5764c65755a043e5404","24dab91095bdf34d602ca5a18f81df6cb308709f"],"b7d165dc88e14a2b2f1cc4ac8133ffdde44acfd5":["24dab91095bdf34d602ca5a18f81df6cb308709f","d305023fa6a3a568a5d704ecfcf8c9b1dff83415"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["d2638f781be724518ff6c2263d14a48cf6e68017","24dab91095bdf34d602ca5a18f81df6cb308709f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}