{"path":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean).mjava","commits":[{"id":"11bf766bfc5fc48f7099fd6d555b16d5ad4478f9","date":1384729182,"type":1,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryResponse,String).mjava","sourceNew":"  private boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean isHiddenFile(SolrQueryResponse rsp, String fnameIn) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      log.error(\"Cannot access \" + fname);\n      rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      log.error(\"Invalid path: \" + fname);\n      rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      return true;\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7455ee5c847b2ee7e44656e4218141f62dacb572","date":1386032125,"type":5,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean,Set[String]).mjava","pathOld":"solr/core/src/java/org/apache/solr/handler/admin/ShowFileRequestHandler#isHiddenFile(SolrQueryRequest,SolrQueryResponse,String,boolean).mjava","sourceNew":"  public static boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError,\n                                     Set<String> hiddenFiles) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(SolrException.ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","sourceOld":"  private boolean isHiddenFile(SolrQueryRequest req, SolrQueryResponse rsp, String fnameIn, boolean reportError) {\n    String fname = fnameIn.toUpperCase(Locale.ROOT);\n    if (hiddenFiles.contains(fname) || hiddenFiles.contains(\"*\")) {\n      if (reportError) {\n        log.error(\"Cannot access \" + fname);\n        rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Can not access: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // This is slightly off, a valid path is something like ./schema.xml. I don't think it's worth the effort though\n    // to fix it to handle all possibilities though.\n    if (fname.indexOf(\"..\") >= 0 || fname.startsWith(\".\")) {\n      if (reportError) {\n        log.error(\"Invalid path: \" + fname);\n        rsp.setException(new SolrException(ErrorCode.FORBIDDEN, \"Invalid path: \" + fnameIn));\n      }\n      return true;\n    }\n\n    // Make sure that if the schema is managed, we don't allow editing. Don't really want to put\n    // this in the init since we're not entirely sure when the managed schema will get initialized relative to this\n    // handler.\n    SolrCore core = req.getCore();\n    IndexSchema schema = core.getLatestSchema();\n    if (schema instanceof ManagedIndexSchema) {\n      String managed = schema.getResourceName();\n\n      if (fname.equalsIgnoreCase(managed)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"11bf766bfc5fc48f7099fd6d555b16d5ad4478f9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"7455ee5c847b2ee7e44656e4218141f62dacb572":["11bf766bfc5fc48f7099fd6d555b16d5ad4478f9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7455ee5c847b2ee7e44656e4218141f62dacb572"]},"commit2Childs":{"11bf766bfc5fc48f7099fd6d555b16d5ad4478f9":["7455ee5c847b2ee7e44656e4218141f62dacb572"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["11bf766bfc5fc48f7099fd6d555b16d5ad4478f9"],"7455ee5c847b2ee7e44656e4218141f62dacb572":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}