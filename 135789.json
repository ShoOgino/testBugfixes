{"path":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","commits":[{"id":"80931fa1f3b04650bde7b20e61b02063a7093ced","date":1333130683,"type":0,"author":"Robert Muir","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","pathOld":"/dev/null","sourceNew":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7530de27b87b961b51f01bd1299b7004d46e8823","date":1355236261,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","sourceNew":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","sourceOld":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d3fcb70cf561547c7bb1506e0cf32ca7b1287064","date":1357616416,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","sourceNew":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","sourceOld":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0158ced21948b6626f733c1c42c1e18d94449789","date":1462994341,"type":3,"author":"Bartosz KrasiÅ„ski","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","sourceNew":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iterative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","sourceOld":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d470c8182e92b264680e34081b75e70a9f2b3c89","date":1463985353,"type":3,"author":"Noble Paul","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","sourceNew":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iterative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","sourceOld":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","pathOld":"solr/core/src/java/org/apache/solr/internal/csv/ExtendedBufferedReader#read(char[],int,int).mjava","sourceNew":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iterative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","sourceOld":"  /**\n   * Non-blocking reading of len chars into buffer buf starting\n   * at bufferposition off.\n   * \n   * performs an iteratative read on the underlying stream\n   * as long as the following conditions hold:\n   *   - less than len chars have been read\n   *   - end of stream has not been reached\n   *   - next read is not blocking\n   * \n   * @return nof chars actually read or END_OF_STREAM\n   */\n  @Override\n  public int read(char[] buf, int off, int len) throws IOException {\n    // do not claim if len == 0\n    if (len == 0) {\n      return 0;\n    } \n    \n    // init lookahead, but do not block !!\n    if (lookaheadChar == UNDEFINED) {\n        if (ready()) {\n         lookaheadChar = super.read();\n        } else {\n          return -1;\n        }\n    }\n    // 'first read of underlying stream'\n    if (lookaheadChar == -1) {\n      return -1;\n    }\n    // continue until the lookaheadChar would block\n    int cOff = off;\n    while (len > 0 && ready()) {\n      if (lookaheadChar == -1) {\n        // eof stream reached, do not continue\n        return cOff - off;\n      } else {\n        buf[cOff++] = (char) lookaheadChar;\n        if (lookaheadChar == '\\n') {\n          lineCounter++;\n        } \n        lastChar = lookaheadChar;\n        lookaheadChar = super.read();\n        len--;\n      }\n    }\n    return cOff - off;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":["80931fa1f3b04650bde7b20e61b02063a7093ced","7530de27b87b961b51f01bd1299b7004d46e8823"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"80931fa1f3b04650bde7b20e61b02063a7093ced":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"7530de27b87b961b51f01bd1299b7004d46e8823":["80931fa1f3b04650bde7b20e61b02063a7093ced"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["7530de27b87b961b51f01bd1299b7004d46e8823","d470c8182e92b264680e34081b75e70a9f2b3c89"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["d470c8182e92b264680e34081b75e70a9f2b3c89"],"d470c8182e92b264680e34081b75e70a9f2b3c89":["7530de27b87b961b51f01bd1299b7004d46e8823","0158ced21948b6626f733c1c42c1e18d94449789"],"0158ced21948b6626f733c1c42c1e18d94449789":["7530de27b87b961b51f01bd1299b7004d46e8823"]},"commit2Childs":{"d3fcb70cf561547c7bb1506e0cf32ca7b1287064":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["80931fa1f3b04650bde7b20e61b02063a7093ced"],"80931fa1f3b04650bde7b20e61b02063a7093ced":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","7530de27b87b961b51f01bd1299b7004d46e8823"],"7530de27b87b961b51f01bd1299b7004d46e8823":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","d470c8182e92b264680e34081b75e70a9f2b3c89","0158ced21948b6626f733c1c42c1e18d94449789"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"d470c8182e92b264680e34081b75e70a9f2b3c89":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"0158ced21948b6626f733c1c42c1e18d94449789":["d470c8182e92b264680e34081b75e70a9f2b3c89"]},"heads":["d3fcb70cf561547c7bb1506e0cf32ca7b1287064","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}