{"path":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(FSTCompiler[T],FSTCompiler.UnCompiledNode[T]).mjava","commits":[{"id":"0f5661e6a04d3172e262ad741b717924f2f1b6a5","date":1576244274,"type":1,"author":"Bruno Roustant","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(FSTCompiler[T],FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = fstCompiler.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(fstCompiler, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (fstCompiler.numBytesPerArc.length < nodeIn.numArcs) {\n        fstCompiler.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        fstCompiler.numLabelBytesPerArc = new int[fstCompiler.numBytesPerArc.length];\n      }\n    }\n\n    fstCompiler.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = fstCompiler.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final FSTCompiler.CompiledNode target = (FSTCompiler.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (fstCompiler.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      fstCompiler.bytes.writeByte((byte) flags);\n      long labelStart = fstCompiler.bytes.getPosition();\n      writeLabel(fstCompiler.bytes, arc.label);\n      int numLabelBytes = (int) (fstCompiler.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, fstCompiler.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, fstCompiler.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        fstCompiler.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (fstCompiler.bytes.getPosition() - lastArcStart);\n        fstCompiler.numBytesPerArc[arcIdx] = numArcBytes;\n        fstCompiler.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = fstCompiler.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(fstCompiler, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(fstCompiler, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        fstCompiler.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(fstCompiler, nodeIn, startAddress, maxBytesPerArc);\n        fstCompiler.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = fstCompiler.bytes.getPosition()-1;\n    fstCompiler.bytes.reverse(startAddress, thisNodeAddress);\n    fstCompiler.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(builder, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (builder.numBytesPerArc.length < nodeIn.numArcs) {\n        builder.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        builder.numLabelBytesPerArc = new int[builder.numBytesPerArc.length];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      long labelStart = builder.bytes.getPosition();\n      writeLabel(builder.bytes, arc.label);\n      int numLabelBytes = (int) (builder.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (builder.bytes.getPosition() - lastArcStart);\n        builder.numBytesPerArc[arcIdx] = numArcBytes;\n        builder.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(builder, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(builder, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        builder.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(builder, nodeIn, startAddress, maxBytesPerArc);\n        builder.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","date":1576247714,"type":1,"author":"Dawid Weiss","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(FSTCompiler[T],FSTCompiler.UnCompiledNode[T]).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/util/fst/FST#addNode(Builder[T],Builder.UnCompiledNode[T]).mjava","sourceNew":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(FSTCompiler<T> fstCompiler, FSTCompiler.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = fstCompiler.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(fstCompiler, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (fstCompiler.numBytesPerArc.length < nodeIn.numArcs) {\n        fstCompiler.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        fstCompiler.numLabelBytesPerArc = new int[fstCompiler.numBytesPerArc.length];\n      }\n    }\n\n    fstCompiler.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = fstCompiler.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final FSTCompiler.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final FSTCompiler.CompiledNode target = (FSTCompiler.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (fstCompiler.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      fstCompiler.bytes.writeByte((byte) flags);\n      long labelStart = fstCompiler.bytes.getPosition();\n      writeLabel(fstCompiler.bytes, arc.label);\n      int numLabelBytes = (int) (fstCompiler.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, fstCompiler.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, fstCompiler.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        fstCompiler.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (fstCompiler.bytes.getPosition() - lastArcStart);\n        fstCompiler.numBytesPerArc[arcIdx] = numArcBytes;\n        fstCompiler.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = fstCompiler.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(fstCompiler, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(fstCompiler, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        fstCompiler.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(fstCompiler, nodeIn, startAddress, maxBytesPerArc);\n        fstCompiler.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = fstCompiler.bytes.getPosition()-1;\n    fstCompiler.bytes.reverse(startAddress, thisNodeAddress);\n    fstCompiler.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","sourceOld":"  // serializes new node by appending its bytes to the end\n  // of the current byte[]\n  long addNode(Builder<T> builder, Builder.UnCompiledNode<T> nodeIn) throws IOException {\n    T NO_OUTPUT = outputs.getNoOutput();\n\n    //System.out.println(\"FST.addNode pos=\" + bytes.getPosition() + \" numArcs=\" + nodeIn.numArcs);\n    if (nodeIn.numArcs == 0) {\n      if (nodeIn.isFinal) {\n        return FINAL_END_NODE;\n      } else {\n        return NON_FINAL_END_NODE;\n      }\n    }\n    final long startAddress = builder.bytes.getPosition();\n    //System.out.println(\"  startAddr=\" + startAddress);\n\n    final boolean doFixedLengthArcs = shouldExpandNodeWithFixedLengthArcs(builder, nodeIn);\n    if (doFixedLengthArcs) {\n      //System.out.println(\"  fixed length arcs\");\n      if (builder.numBytesPerArc.length < nodeIn.numArcs) {\n        builder.numBytesPerArc = new int[ArrayUtil.oversize(nodeIn.numArcs, Integer.BYTES)];\n        builder.numLabelBytesPerArc = new int[builder.numBytesPerArc.length];\n      }\n    }\n\n    builder.arcCount += nodeIn.numArcs;\n    \n    final int lastArc = nodeIn.numArcs-1;\n\n    long lastArcStart = builder.bytes.getPosition();\n    int maxBytesPerArc = 0;\n    int maxBytesPerArcWithoutLabel = 0;\n    for(int arcIdx=0; arcIdx < nodeIn.numArcs; arcIdx++) {\n      final Builder.Arc<T> arc = nodeIn.arcs[arcIdx];\n      final Builder.CompiledNode target = (Builder.CompiledNode) arc.target;\n      int flags = 0;\n      //System.out.println(\"  arc \" + arcIdx + \" label=\" + arc.label + \" -> target=\" + target.node);\n\n      if (arcIdx == lastArc) {\n        flags += BIT_LAST_ARC;\n      }\n\n      if (builder.lastFrozenNode == target.node && !doFixedLengthArcs) {\n        // TODO: for better perf (but more RAM used) we\n        // could avoid this except when arc is \"near\" the\n        // last arc:\n        flags += BIT_TARGET_NEXT;\n      }\n\n      if (arc.isFinal) {\n        flags += BIT_FINAL_ARC;\n        if (arc.nextFinalOutput != NO_OUTPUT) {\n          flags += BIT_ARC_HAS_FINAL_OUTPUT;\n        }\n      } else {\n        assert arc.nextFinalOutput == NO_OUTPUT;\n      }\n\n      boolean targetHasArcs = target.node > 0;\n\n      if (!targetHasArcs) {\n        flags += BIT_STOP_NODE;\n      }\n\n      if (arc.output != NO_OUTPUT) {\n        flags += BIT_ARC_HAS_OUTPUT;\n      }\n\n      builder.bytes.writeByte((byte) flags);\n      long labelStart = builder.bytes.getPosition();\n      writeLabel(builder.bytes, arc.label);\n      int numLabelBytes = (int) (builder.bytes.getPosition() - labelStart);\n\n      // System.out.println(\"  write arc: label=\" + (char) arc.label + \" flags=\" + flags + \" target=\" + target.node + \" pos=\" + bytes.getPosition() + \" output=\" + outputs.outputToString(arc.output));\n\n      if (arc.output != NO_OUTPUT) {\n        outputs.write(arc.output, builder.bytes);\n        //System.out.println(\"    write output\");\n      }\n\n      if (arc.nextFinalOutput != NO_OUTPUT) {\n        //System.out.println(\"    write final output\");\n        outputs.writeFinalOutput(arc.nextFinalOutput, builder.bytes);\n      }\n\n      if (targetHasArcs && (flags & BIT_TARGET_NEXT) == 0) {\n        assert target.node > 0;\n        //System.out.println(\"    write target\");\n        builder.bytes.writeVLong(target.node);\n      }\n\n      // just write the arcs \"like normal\" on first pass, but record how many bytes each one took\n      // and max byte size:\n      if (doFixedLengthArcs) {\n        int numArcBytes = (int) (builder.bytes.getPosition() - lastArcStart);\n        builder.numBytesPerArc[arcIdx] = numArcBytes;\n        builder.numLabelBytesPerArc[arcIdx] = numLabelBytes;\n        lastArcStart = builder.bytes.getPosition();\n        maxBytesPerArc = Math.max(maxBytesPerArc, numArcBytes);\n        maxBytesPerArcWithoutLabel = Math.max(maxBytesPerArcWithoutLabel, numArcBytes - numLabelBytes);\n        //System.out.println(\"    arcBytes=\" + numArcBytes + \" labelBytes=\" + numLabelBytes);\n      }\n    }\n\n    // TODO: try to avoid wasteful cases: disable doFixedLengthArcs in that case\n    /* \n     * \n     * LUCENE-4682: what is a fair heuristic here?\n     * It could involve some of these:\n     * 1. how \"busy\" the node is: nodeIn.inputCount relative to frontier[0].inputCount?\n     * 2. how much binSearch saves over scan: nodeIn.numArcs\n     * 3. waste: numBytes vs numBytesExpanded\n     * \n     * the one below just looks at #3\n    if (doFixedLengthArcs) {\n      // rough heuristic: make this 1.25 \"waste factor\" a parameter to the phd ctor????\n      int numBytes = lastArcStart - startAddress;\n      int numBytesExpanded = maxBytesPerArc * nodeIn.numArcs;\n      if (numBytesExpanded > numBytes*1.25) {\n        doFixedLengthArcs = false;\n      }\n    }\n    */\n\n    if (doFixedLengthArcs) {\n      assert maxBytesPerArc > 0;\n      // 2nd pass just \"expands\" all arcs to take up a fixed byte size\n\n      int labelRange = nodeIn.arcs[nodeIn.numArcs - 1].label - nodeIn.arcs[0].label + 1;\n      assert labelRange > 0;\n      if (shouldExpandNodeWithDirectAddressing(builder, nodeIn, maxBytesPerArc, maxBytesPerArcWithoutLabel, labelRange)) {\n        writeNodeForDirectAddressing(builder, nodeIn, startAddress, maxBytesPerArcWithoutLabel, labelRange);\n        builder.directAddressingNodeCount++;\n      } else {\n        writeNodeForBinarySearch(builder, nodeIn, startAddress, maxBytesPerArc);\n        builder.binarySearchNodeCount++;\n      }\n    }\n\n    final long thisNodeAddress = builder.bytes.getPosition()-1;\n    builder.bytes.reverse(startAddress, thisNodeAddress);\n    builder.nodeCount++;\n    return thisNodeAddress;\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["0f5661e6a04d3172e262ad741b717924f2f1b6a5"]},"commit2Childs":{"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","0f5661e6a04d3172e262ad741b717924f2f1b6a5"],"c5db9bff3aeb942c848a2ab8fa4b8b0737377deb":[],"0f5661e6a04d3172e262ad741b717924f2f1b6a5":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["c5db9bff3aeb942c848a2ab8fa4b8b0737377deb","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}