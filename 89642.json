{"path":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","commits":[{"id":"b5125dbd3878ae934da6ff9243253c2f88b7b6c5","date":1463994309,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"/dev/null","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) > 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","date":1464066565,"type":0,"author":"Noble Paul","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"/dev/null","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) > 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7f8f801963be1c08f8a2df42c9cf4d314a36fce8","date":1464587501,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) > 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"da8a02bef7458089240404614139b53c9f875ec7","date":1464597207,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) > 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b8ee93140fd0efef7e101786e3ed5160a700b5f","date":1464820111,"type":3,"author":"Mike McCandless","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) > 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":0,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"/dev/null","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9798d0818e7a880546802b509792d3f3d57babd2","date":1528358901,"type":3,"author":"Nhat Nguyen","isMerge":false,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = ArrayUtil.copyOfSubArray(values, 0, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b70042a8a492f7054d480ccdd2be9796510d4327","date":1528386658,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = ArrayUtil.copyOfSubArray(values, 0, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","pathOld":"lucene/sandbox/src/test/org/apache/lucene/document/TestHalfFloatPoint#testRounding().mjava","sourceNew":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = ArrayUtil.copyOfSubArray(values, 0, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","sourceOld":"  public void testRounding() {\n    float[] values = new float[0];\n    int o = 0;\n    for (int i = Short.MIN_VALUE; i <= Short.MAX_VALUE; ++i) {\n      float v = HalfFloatPoint.sortableShortToHalfFloat((short) i);\n      if (Float.isFinite(v)) {\n        if (o == values.length) {\n          values = ArrayUtil.grow(values);\n        }\n        values[o++] = v;\n      }\n    }\n    values = Arrays.copyOf(values, o);\n\n    int iters = atLeast(1000000);\n    for (int iter = 0; iter < iters; ++iter) {\n      float f;\n      if (random().nextBoolean()) {\n        int floatBits = random().nextInt();\n        f = Float.intBitsToFloat(floatBits);\n      } else {\n        f =  (float) ((2 * random().nextFloat() - 1) * Math.pow(2, TestUtil.nextInt(random(), -16, 16)));\n      }\n      float rounded = HalfFloatPoint.shortBitsToHalfFloat(HalfFloatPoint.halfFloatToShortBits(f));\n      if (Float.isFinite(f) == false) {\n        assertEquals(Float.floatToIntBits(f), Float.floatToIntBits(rounded), 0f);\n      } else if (Float.isFinite(rounded) == false) {\n        assertFalse(Float.isNaN(rounded));\n        assertTrue(Math.abs(f) >= 65520);\n      } else {\n        int index = Arrays.binarySearch(values, f);\n        float closest;\n        if (index >= 0) {\n          closest = values[index];\n        } else {\n          index = -1 - index;\n          closest = Float.POSITIVE_INFINITY;\n          if (index < values.length) {\n            closest = values[index];\n          }\n          if (index - 1 >= 0) {\n            if (f - values[index - 1] < closest - f) {\n              closest = values[index - 1];\n            } else if (f - values[index - 1] == closest - f\n                && Integer.numberOfTrailingZeros(Float.floatToIntBits(values[index - 1])) > Integer.numberOfTrailingZeros(Float.floatToIntBits(closest))) {\n              // in case of tie, round to even\n              closest = values[index - 1];\n            }\n          }\n        }\n        assertEquals(closest, rounded, 0f);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"da8a02bef7458089240404614139b53c9f875ec7":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","7f8f801963be1c08f8a2df42c9cf4d314a36fce8"],"b5125dbd3878ae934da6ff9243253c2f88b7b6c5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"b70042a8a492f7054d480ccdd2be9796510d4327":["7f8f801963be1c08f8a2df42c9cf4d314a36fce8","9798d0818e7a880546802b509792d3f3d57babd2"],"7f8f801963be1c08f8a2df42c9cf4d314a36fce8":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","b5125dbd3878ae934da6ff9243253c2f88b7b6c5"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","7f8f801963be1c08f8a2df42c9cf4d314a36fce8"],"9798d0818e7a880546802b509792d3f3d57babd2":["7f8f801963be1c08f8a2df42c9cf4d314a36fce8"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","7f8f801963be1c08f8a2df42c9cf4d314a36fce8"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9798d0818e7a880546802b509792d3f3d57babd2"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["7f8f801963be1c08f8a2df42c9cf4d314a36fce8","9798d0818e7a880546802b509792d3f3d57babd2"]},"commit2Childs":{"da8a02bef7458089240404614139b53c9f875ec7":[],"b5125dbd3878ae934da6ff9243253c2f88b7b6c5":["e616cfbf284ecbd0f40b4b9e4196daa27e92abd5"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["b5125dbd3878ae934da6ff9243253c2f88b7b6c5","e616cfbf284ecbd0f40b4b9e4196daa27e92abd5","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"b70042a8a492f7054d480ccdd2be9796510d4327":[],"e616cfbf284ecbd0f40b4b9e4196daa27e92abd5":["da8a02bef7458089240404614139b53c9f875ec7","7f8f801963be1c08f8a2df42c9cf4d314a36fce8","5b8ee93140fd0efef7e101786e3ed5160a700b5f"],"7f8f801963be1c08f8a2df42c9cf4d314a36fce8":["da8a02bef7458089240404614139b53c9f875ec7","b70042a8a492f7054d480ccdd2be9796510d4327","5b8ee93140fd0efef7e101786e3ed5160a700b5f","9798d0818e7a880546802b509792d3f3d57babd2","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"5b8ee93140fd0efef7e101786e3ed5160a700b5f":[],"9798d0818e7a880546802b509792d3f3d57babd2":["b70042a8a492f7054d480ccdd2be9796510d4327","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["da8a02bef7458089240404614139b53c9f875ec7","b70042a8a492f7054d480ccdd2be9796510d4327","5b8ee93140fd0efef7e101786e3ed5160a700b5f","4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}