{"path":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","commits":[{"id":"c903c3d15906a3da96b8c0c2fb704491005fdbdb","date":1453508227,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a258fbb26824fd104ed795e5d9033d2d040049ee","date":1453508252,"type":1,"author":"Dawid Weiss","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c26f00b574427b55127e869b935845554afde1fa","date":1310252513,"type":1,"author":"Steven Rowe","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c01638f4dd94981c1d3d52c4f7991246a5a24aba","date":1327876712,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":["243885d7a8da5b172092cfac738e33970bec02e1","97fc5a00245e9b31c118c53df88b1376237ea87b"],"bugIntro":["19f02bb04467ed179738a398a7da80bbbe161c16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"817882884229bace7dc5d1b75f6b0e4aa1e47122","date":1327879145,"type":3,"author":"Uwe Schindler","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5b6fdfce35d0adb18836cf8711abe487a934df33","date":1327946200,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexVersion version of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexVersion, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexVersion, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd5bc858b8426d40bbe90b94120ead37c77d7954","date":1393812525,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.currentTimeMillis() + reserveTime;\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":["19f02bb04467ed179738a398a7da80bbbe161c16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"dea8e36e8c36d610840396c282a5affe3f722f4e","date":1422297045,"type":3,"author":"Mark Robert Miller","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) {\n        LOG.debug(\"Commit point reservation for generation {} set to {} (requested reserve time of {})\",\n            indexGen, timeToSet, reserveTime);\n        break;\n      }\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) break;\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":["19f02bb04467ed179738a398a7da80bbbe161c16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","date":1534976797,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) {\n        log.debug(\"Commit point reservation for generation {} set to {} (requested reserve time of {})\",\n            indexGen, timeToSet, reserveTime);\n        break;\n      }\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) {\n        LOG.debug(\"Commit point reservation for generation {} set to {} (requested reserve time of {})\",\n            indexGen, timeToSet, reserveTime);\n        break;\n      }\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":null,"bugIntro":["19f02bb04467ed179738a398a7da80bbbe161c16"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"19f02bb04467ed179738a398a7da80bbbe161c16","date":1573660732,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","pathOld":"solr/core/src/java/org/apache/solr/core/IndexDeletionPolicyWrapper#setReserveDuration(Long,long).mjava","sourceNew":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   * <p>\n   * <b>NOTE:</b> This method does not make any garuntees that the specified index generation exists, \n   * or that the specified generation has not already ben deleted.  The only garuntee is that \n   * <em>if</em> the specified generation exists now, or is created at some point in the future, then \n   * it will be resered for <em>at least</em> the specified <code>reserveTime</code>.\n   * </p>\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime durration in milliseconds (relative to 'now') for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    // since 'reserves' is a concurrent HashMap, we don't need to synchronize this method as long as all\n    // operations on 'reserves' are done atomically.\n    //\n    // Here we'll use Map.merge to ensure that we atomically replace any existing timestamp if\n    // and only if our new reservation timetsamp is larger.\n    final long reserveAsNanoTime\n      = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    reserves.merge(indexGen, reserveAsNanoTime, BinaryOperator.maxBy(Comparator.naturalOrder()));\n  }\n\n","sourceOld":"  /**\n   * Set the duration for which commit point is to be reserved by the deletion policy.\n   *\n   * @param indexGen gen of the commit point to be reserved\n   * @param reserveTime  time in milliseconds for which the commit point is to be reserved\n   */\n  public void setReserveDuration(Long indexGen, long reserveTime) {\n    long timeToSet = System.nanoTime() + TimeUnit.NANOSECONDS.convert(reserveTime, TimeUnit.MILLISECONDS);\n    for(;;) {\n      Long previousTime = reserves.put(indexGen, timeToSet);\n\n      // this is the common success case: the older time didn't exist, or\n      // came before the new time.\n      if (previousTime == null || previousTime <= timeToSet) {\n        log.debug(\"Commit point reservation for generation {} set to {} (requested reserve time of {})\",\n            indexGen, timeToSet, reserveTime);\n        break;\n      }\n\n      // At this point, we overwrote a longer reservation, so we want to restore the older one.\n      // the problem is that an even longer reservation may come in concurrently\n      // and we don't want to overwrite that one too.  We simply keep retrying in a loop\n      // with the maximum time value we have seen.\n      timeToSet = previousTime;      \n    }\n  }\n\n","bugFix":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd","fd5bc858b8426d40bbe90b94120ead37c77d7954","dea8e36e8c36d610840396c282a5affe3f722f4e","c01638f4dd94981c1d3d52c4f7991246a5a24aba","243885d7a8da5b172092cfac738e33970bec02e1","97fc5a00245e9b31c118c53df88b1376237ea87b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["c26f00b574427b55127e869b935845554afde1fa"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":["c26f00b574427b55127e869b935845554afde1fa","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"19f02bb04467ed179738a398a7da80bbbe161c16":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"c26f00b574427b55127e869b935845554afde1fa":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85","c903c3d15906a3da96b8c0c2fb704491005fdbdb"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["fd5bc858b8426d40bbe90b94120ead37c77d7954"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"5b6fdfce35d0adb18836cf8711abe487a934df33":["c26f00b574427b55127e869b935845554afde1fa","c01638f4dd94981c1d3d52c4f7991246a5a24aba"],"a258fbb26824fd104ed795e5d9033d2d040049ee":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["19f02bb04467ed179738a398a7da80bbbe161c16"],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["c01638f4dd94981c1d3d52c4f7991246a5a24aba"]},"commit2Childs":{"c01638f4dd94981c1d3d52c4f7991246a5a24aba":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","fd5bc858b8426d40bbe90b94120ead37c77d7954"],"c903c3d15906a3da96b8c0c2fb704491005fdbdb":["c26f00b574427b55127e869b935845554afde1fa"],"817882884229bace7dc5d1b75f6b0e4aa1e47122":[],"c26f00b574427b55127e869b935845554afde1fa":["c01638f4dd94981c1d3d52c4f7991246a5a24aba","817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33"],"19f02bb04467ed179738a398a7da80bbbe161c16":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["c903c3d15906a3da96b8c0c2fb704491005fdbdb","c26f00b574427b55127e869b935845554afde1fa","a258fbb26824fd104ed795e5d9033d2d040049ee"],"dea8e36e8c36d610840396c282a5affe3f722f4e":["e9c81f7e703d7ccca5bc78beb61253f0a8a22afd"],"5b6fdfce35d0adb18836cf8711abe487a934df33":[],"a258fbb26824fd104ed795e5d9033d2d040049ee":[],"e9c81f7e703d7ccca5bc78beb61253f0a8a22afd":["19f02bb04467ed179738a398a7da80bbbe161c16"],"fd5bc858b8426d40bbe90b94120ead37c77d7954":["dea8e36e8c36d610840396c282a5affe3f722f4e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["817882884229bace7dc5d1b75f6b0e4aa1e47122","5b6fdfce35d0adb18836cf8711abe487a934df33","a258fbb26824fd104ed795e5d9033d2d040049ee","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}