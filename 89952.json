{"path":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","commits":[{"id":"0ef4d3aeb733ae886f562af3b735f50503926a12","date":1438854939,"type":1,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.ScoringMaxScoreCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n\n      if (comparators.length == 1) {\n        return new OneComparatorLeafCollector(comparators[0], reverseMul[0], mayNeedScoresTwice) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = Float.NaN;\n            if (trackMaxScore) {\n              score = scorer.score();\n              if (score > maxScore) {\n                maxScore = score;\n              }\n            }\n\n            ++totalHits;\n            if (queueFull) {\n              if (reverseMul * comparator.compareBottom(doc) <= 0) {\n                // since docs are visited in doc Id order, if compare is 0, it means\n                // this document is largest than anything else in the queue, and\n                // therefore not competitive.\n                return;\n              }\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // This hit is competitive - replace bottom element in queue & adjustTop\n              comparator.copy(bottom.slot, doc);\n              updateBottom(doc, score);\n              comparator.setBottom(bottom.slot);\n            } else {\n              // Startup transient: queue hasn't gathered numHits yet\n              final int slot = totalHits - 1;\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // Copy hit into queue\n              comparator.copy(slot, doc);\n              add(slot, doc, score);\n              if (queueFull) {\n                comparator.setBottom(bottom.slot);\n              }\n            }\n          }\n\n        };\n      } else {\n        return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = Float.NaN;\n            if (trackMaxScore) {\n              score = scorer.score();\n              if (score > maxScore) {\n                maxScore = score;\n              }\n            }\n\n            ++totalHits;\n            if (queueFull) {\n              if (compareBottom(doc) <= 0) {\n                // since docs are visited in doc Id order, if compare is 0, it means\n                // this document is largest than anything else in the queue, and\n                // therefore not competitive.\n                return;\n              }\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // This hit is competitive - replace bottom element in queue & adjustTop\n              copy(bottom.slot, doc);\n              updateBottom(doc, score);\n              setBottom(bottom.slot);\n            } else {\n              // Startup transient: queue hasn't gathered numHits yet\n              final int slot = totalHits - 1;\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // Copy hit into queue\n              copy(slot, doc);\n              add(slot, doc, score);\n              if (queueFull) {\n                setBottom(bottom.slot);\n              }\n            }\n          }\n\n        };\n      }\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n\n      if (comparators.length == 1) {\n        return new OneComparatorLeafCollector(comparators[0], reverseMul[0]) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final float score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n            ++totalHits;\n            if (queueFull) {\n              if (reverseMul * comparator.compareBottom(doc) <= 0) {\n                // since docs are visited in doc Id order, if compare is 0, it means\n                // this document is largest than anything else in the queue, and\n                // therefore not competitive.\n                return;\n              }\n\n              // This hit is competitive - replace bottom element in queue & adjustTop\n              comparator.copy(bottom.slot, doc);\n              updateBottom(doc, score);\n              comparator.setBottom(bottom.slot);\n            } else {\n              // Startup transient: queue hasn't gathered numHits yet\n              final int slot = totalHits - 1;\n              // Copy hit into queue\n              comparator.copy(slot, doc);\n              add(slot, doc, score);\n              if (queueFull) {\n                comparator.setBottom(bottom.slot);\n              }\n            }\n          }\n\n        };\n      } else {\n        return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            final float score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n            ++totalHits;\n            if (queueFull) {\n              if (compareBottom(doc) <= 0) {\n                // since docs are visited in doc Id order, if compare is 0, it means\n                // this document is largest than anything else in the queue, and\n                // therefore not competitive.\n                return;\n              }\n\n              // This hit is competitive - replace bottom element in queue & adjustTop\n              copy(bottom.slot, doc);\n              updateBottom(doc, score);\n              setBottom(bottom.slot);\n            } else {\n              // Startup transient: queue hasn't gathered numHits yet\n              final int slot = totalHits - 1;\n              // Copy hit into queue\n              copy(slot, doc);\n              add(slot, doc, score);\n              if (queueFull) {\n                setBottom(bottom.slot);\n              }\n            }\n          }\n\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a3f4b84749cf975e026f3cd024d9f2911e0cc2e0","date":1488289604,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              return;\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n\n      if (comparators.length == 1) {\n        return new OneComparatorLeafCollector(comparators[0], reverseMul[0], mayNeedScoresTwice) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = Float.NaN;\n            if (trackMaxScore) {\n              score = scorer.score();\n              if (score > maxScore) {\n                maxScore = score;\n              }\n            }\n\n            ++totalHits;\n            if (queueFull) {\n              if (reverseMul * comparator.compareBottom(doc) <= 0) {\n                // since docs are visited in doc Id order, if compare is 0, it means\n                // this document is largest than anything else in the queue, and\n                // therefore not competitive.\n                return;\n              }\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // This hit is competitive - replace bottom element in queue & adjustTop\n              comparator.copy(bottom.slot, doc);\n              updateBottom(doc, score);\n              comparator.setBottom(bottom.slot);\n            } else {\n              // Startup transient: queue hasn't gathered numHits yet\n              final int slot = totalHits - 1;\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // Copy hit into queue\n              comparator.copy(slot, doc);\n              add(slot, doc, score);\n              if (queueFull) {\n                comparator.setBottom(bottom.slot);\n              }\n            }\n          }\n\n        };\n      } else {\n        return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n          @Override\n          public void collect(int doc) throws IOException {\n            float score = Float.NaN;\n            if (trackMaxScore) {\n              score = scorer.score();\n              if (score > maxScore) {\n                maxScore = score;\n              }\n            }\n\n            ++totalHits;\n            if (queueFull) {\n              if (compareBottom(doc) <= 0) {\n                // since docs are visited in doc Id order, if compare is 0, it means\n                // this document is largest than anything else in the queue, and\n                // therefore not competitive.\n                return;\n              }\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // This hit is competitive - replace bottom element in queue & adjustTop\n              copy(bottom.slot, doc);\n              updateBottom(doc, score);\n              setBottom(bottom.slot);\n            } else {\n              // Startup transient: queue hasn't gathered numHits yet\n              final int slot = totalHits - 1;\n\n              if (trackDocScores && !trackMaxScore) {\n                score = scorer.score();\n              }\n\n              // Copy hit into queue\n              copy(slot, doc);\n              add(slot, doc, score);\n              if (queueFull) {\n                setBottom(bottom.slot);\n              }\n            }\n          }\n\n        };\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"404d1ab7f6f396235047017c88d545fec15dafb7","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              return;\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":["e4184751347df4dfb7bc0e2d4dc1b412857f301d"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              return;\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"e4184751347df4dfb7bc0e2d4dc1b412857f301d","date":1512652126,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":["404d1ab7f6f396235047017c88d545fec15dafb7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"417142ff08fda9cf0b72d5133e63097a166c6458","date":1512729693,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          canEarlyTerminate(sort, context.reader().getMetaData().getSort());\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"81fff83bdb893c1471efd78f6a9a3ce4f98120b9","date":1531895937,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          trackMaxScore == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n          if (trackMaxScore) {\n            score = scorer.score();\n            if (score > maxScore) {\n              maxScore = score;\n            }\n          }\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores && !trackMaxScore) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1d3f7ab1a502671bbdb03bcced21e764d2483221","date":1532329609,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul, mayNeedScoresTwice) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            if (trackDocScores) {\n              score = scorer.score();\n            }\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c6d71c47cb42702580f18a54321282c0238c2d2a","date":1532960436,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          float score = Float.NaN;\n\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc, score);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc, score);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"83788ad129a5154d5c6562c4e8ce3db48793aada","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n      final int initialTotalHits = totalHits;\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                // scale totalHits linearly based on the number of docs\n                // and terminate collection\n                totalHits += estimateRemainingHits(totalHits - initialTotalHits, doc, context.reader().maxDoc());\n                earlyTerminated = true;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fe3c6364bed04a73ad0884b05401d80ce96027a9","date":1532961485,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate && totalHits >= totalHitsThreshold) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = trackTotalHits == false &&\n          indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7","date":1535640296,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate && totalHits >= totalHitsThreshold) {\n                totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                throw new CollectionTerminatedException();\n              } else {\n                // just move to the next doc\n                return;\n              }\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5003664d14ef48a0557ce1d8a684b15d62efe912","date":1539883534,"type":3,"author":"Jim Ferenczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"741f39e242cff4c0c77a2beea34fb865a3fd2372","date":1542392009,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = indexSort != null &&\n          canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5374ec368ef9441d694af8df95b2ffbae3d7f03b","date":1548748689,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits > totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits >= totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":["fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"e19eef45a852c3316ae52fdf941731448ece967a","date":1567670879,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (totalHits > totalHitsThreshold) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"5319c194edd3bf49f39c6d198107ed213c1d3670","date":1569842580,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO || shouldUpdateMinScore()) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f00d3f1ad3bbb957062c4871ec23f49edda800c6","date":1569925943,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer, true);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO || shouldUpdateMinScore()) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"74844ead01492c17079ed382d0924f4df2fa72e3","date":1569970726,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer, true);\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer, true);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0db0ef4e326916fc107ab6e066754d3ecba5197b","date":1570005243,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if we just\n                // reached totalHitsThreshold\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer);\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer, true);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else {\n                updateMinCompetitiveScore(scorer, totalHitsRelation == Relation.EQUAL_TO);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer, true);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer, true);\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f0c10c01b195758b50e02599868e4093eb712f57","date":1570008306,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          // reset the minimum competitive score\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == TotalHits.Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if we just\n                // reached totalHitsThreshold\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n            }\n            updateMinCompetitiveScore(scorer);\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"807314aa41c10866aec273a0e54fd0d24d8971de","date":1570435832,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6e0066943a75c6f4af395bcd7728a812943cbb63","date":1570723011,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"344fda225893210c79fc615c612df728a78bfbc6","date":1571224186,"type":3,"author":"jimczi","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && totalHits % minScoreAcc.modInterval == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f","date":1571662992,"type":3,"author":"Jim Ferenczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          updateMinCompetitiveScore(scorer);\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we just reached totalHitsThreshold, we can start setting the min\n                // competitive score now\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b9bcfed304f4a24121ffcf592ea90abdda674363","date":1582808749,"type":3,"author":"Michael Sokolov","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/TopFieldCollector.SimpleFieldCollector#getLeafCollector(LeafReaderContext).mjava","sourceNew":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      return new TopFieldLeafCollector(queue, sort, context) {\n\n        @Override\n        public void collect(int doc) throws IOException {\n          countHit(doc);\n          if (queueFull) {\n            if (thresholdCheck(doc)) {\n              return;\n            }\n            collectCompetitiveHit(doc);\n          } else {\n            collectAnyHit(doc, totalHits);\n          }\n        }\n      };\n    }\n\n","sourceOld":"    @Override\n    public LeafCollector getLeafCollector(LeafReaderContext context) throws IOException {\n      docBase = context.docBase;\n\n      final LeafFieldComparator[] comparators = queue.getComparators(context);\n      final int[] reverseMul = queue.getReverseMul();\n      final Sort indexSort = context.reader().getMetaData().getSort();\n      final boolean canEarlyTerminate = canEarlyTerminate(sort, indexSort);\n\n      return new MultiComparatorLeafCollector(comparators, reverseMul) {\n\n        boolean collectedAllCompetitiveHits = false;\n\n        @Override\n        public void setScorer(Scorable scorer) throws IOException {\n          super.setScorer(scorer);\n          minCompetitiveScore = 0f;\n          updateMinCompetitiveScore(scorer);\n          if (minScoreAcc != null) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n        }\n\n        @Override\n        public void collect(int doc) throws IOException {\n          ++totalHits;\n          hitsThresholdChecker.incrementHitCount();\n\n          if (minScoreAcc != null && (totalHits & minScoreAcc.modInterval) == 0) {\n            updateGlobalMinCompetitiveScore(scorer);\n          }\n\n          if (queueFull) {\n            if (collectedAllCompetitiveHits || reverseMul * comparator.compareBottom(doc) <= 0) {\n              // since docs are visited in doc Id order, if compare is 0, it means\n              // this document is largest than anything else in the queue, and\n              // therefore not competitive.\n              if (canEarlyTerminate) {\n                if (hitsThresholdChecker.isThresholdReached()) {\n                  totalHitsRelation = Relation.GREATER_THAN_OR_EQUAL_TO;\n                  throw new CollectionTerminatedException();\n                } else {\n                  collectedAllCompetitiveHits = true;\n                }\n              } else if (totalHitsRelation == Relation.EQUAL_TO) {\n                // we can start setting the min competitive score if the\n                // threshold is reached for the first time here.\n                updateMinCompetitiveScore(scorer);\n              }\n              return;\n            }\n\n            // This hit is competitive - replace bottom element in queue & adjustTop\n            comparator.copy(bottom.slot, doc);\n            updateBottom(doc);\n            comparator.setBottom(bottom.slot);\n            updateMinCompetitiveScore(scorer);\n          } else {\n            // Startup transient: queue hasn't gathered numHits yet\n            final int slot = totalHits - 1;\n\n            // Copy hit into queue\n            comparator.copy(slot, doc);\n            add(slot, doc);\n            if (queueFull) {\n              comparator.setBottom(bottom.slot);\n              updateMinCompetitiveScore(scorer);\n            }\n          }\n        }\n\n      };\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"e19eef45a852c3316ae52fdf941731448ece967a":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"e4184751347df4dfb7bc0e2d4dc1b412857f301d":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7"],"c6d71c47cb42702580f18a54321282c0238c2d2a":["1d3f7ab1a502671bbdb03bcced21e764d2483221"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["a3f4b84749cf975e026f3cd024d9f2911e0cc2e0","404d1ab7f6f396235047017c88d545fec15dafb7"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["417142ff08fda9cf0b72d5133e63097a166c6458","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"a3f4b84749cf975e026f3cd024d9f2911e0cc2e0":["0ef4d3aeb733ae886f562af3b735f50503926a12"],"0ef4d3aeb733ae886f562af3b735f50503926a12":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"741f39e242cff4c0c77a2beea34fb865a3fd2372":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"f0c10c01b195758b50e02599868e4093eb712f57":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["c6d71c47cb42702580f18a54321282c0238c2d2a"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["741f39e242cff4c0c77a2beea34fb865a3fd2372"],"344fda225893210c79fc615c612df728a78bfbc6":["6e0066943a75c6f4af395bcd7728a812943cbb63"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["e19eef45a852c3316ae52fdf941731448ece967a"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"807314aa41c10866aec273a0e54fd0d24d8971de":["f0c10c01b195758b50e02599868e4093eb712f57"],"404d1ab7f6f396235047017c88d545fec15dafb7":["a3f4b84749cf975e026f3cd024d9f2911e0cc2e0"],"b9bcfed304f4a24121ffcf592ea90abdda674363":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["5319c194edd3bf49f39c6d198107ed213c1d3670"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"417142ff08fda9cf0b72d5133e63097a166c6458":["1aad05eeff7818b0833c02ac6b743aa72054963b","e4184751347df4dfb7bc0e2d4dc1b412857f301d"],"6e0066943a75c6f4af395bcd7728a812943cbb63":["807314aa41c10866aec273a0e54fd0d24d8971de"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["e19eef45a852c3316ae52fdf941731448ece967a","344fda225893210c79fc615c612df728a78bfbc6"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["74844ead01492c17079ed382d0924f4df2fa72e3"],"74844ead01492c17079ed382d0924f4df2fa72e3":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["417142ff08fda9cf0b72d5133e63097a166c6458"],"fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["b9bcfed304f4a24121ffcf592ea90abdda674363"]},"commit2Childs":{"e19eef45a852c3316ae52fdf941731448ece967a":["5319c194edd3bf49f39c6d198107ed213c1d3670","3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"e4184751347df4dfb7bc0e2d4dc1b412857f301d":["417142ff08fda9cf0b72d5133e63097a166c6458"],"5003664d14ef48a0557ce1d8a684b15d62efe912":["741f39e242cff4c0c77a2beea34fb865a3fd2372"],"c6d71c47cb42702580f18a54321282c0238c2d2a":["83788ad129a5154d5c6562c4e8ce3db48793aada"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["e4184751347df4dfb7bc0e2d4dc1b412857f301d","417142ff08fda9cf0b72d5133e63097a166c6458"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a3f4b84749cf975e026f3cd024d9f2911e0cc2e0":["1aad05eeff7818b0833c02ac6b743aa72054963b","404d1ab7f6f396235047017c88d545fec15dafb7"],"0ef4d3aeb733ae886f562af3b735f50503926a12":["a3f4b84749cf975e026f3cd024d9f2911e0cc2e0"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["0ef4d3aeb733ae886f562af3b735f50503926a12"],"741f39e242cff4c0c77a2beea34fb865a3fd2372":["5374ec368ef9441d694af8df95b2ffbae3d7f03b"],"f0c10c01b195758b50e02599868e4093eb712f57":["807314aa41c10866aec273a0e54fd0d24d8971de"],"83788ad129a5154d5c6562c4e8ce3db48793aada":["fe3c6364bed04a73ad0884b05401d80ce96027a9"],"5374ec368ef9441d694af8df95b2ffbae3d7f03b":["e19eef45a852c3316ae52fdf941731448ece967a"],"344fda225893210c79fc615c612df728a78bfbc6":["3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f"],"5319c194edd3bf49f39c6d198107ed213c1d3670":["f00d3f1ad3bbb957062c4871ec23f49edda800c6"],"fe3c6364bed04a73ad0884b05401d80ce96027a9":["fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7"],"807314aa41c10866aec273a0e54fd0d24d8971de":["6e0066943a75c6f4af395bcd7728a812943cbb63"],"404d1ab7f6f396235047017c88d545fec15dafb7":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"b9bcfed304f4a24121ffcf592ea90abdda674363":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"f00d3f1ad3bbb957062c4871ec23f49edda800c6":["74844ead01492c17079ed382d0924f4df2fa72e3"],"1d3f7ab1a502671bbdb03bcced21e764d2483221":["c6d71c47cb42702580f18a54321282c0238c2d2a"],"417142ff08fda9cf0b72d5133e63097a166c6458":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","81fff83bdb893c1471efd78f6a9a3ce4f98120b9"],"6e0066943a75c6f4af395bcd7728a812943cbb63":["344fda225893210c79fc615c612df728a78bfbc6"],"0db0ef4e326916fc107ab6e066754d3ecba5197b":["f0c10c01b195758b50e02599868e4093eb712f57"],"3fc6bc0fbd97ca2f45fd376fa8e733728e665c4f":["b9bcfed304f4a24121ffcf592ea90abdda674363"],"74844ead01492c17079ed382d0924f4df2fa72e3":["0db0ef4e326916fc107ab6e066754d3ecba5197b"],"81fff83bdb893c1471efd78f6a9a3ce4f98120b9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","1d3f7ab1a502671bbdb03bcced21e764d2483221"],"fd455b5d7287554ad0f83cd9d9f3c1e5ae3862b7":["5003664d14ef48a0557ce1d8a684b15d62efe912"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}