{"path":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","commits":[{"id":"3a119bbc8703c10faa329ec201c654b3a35a1e3e","date":1328644745,"type":1,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges as isMaxNumSegments:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for ( final MergePolicy.OneMerge merge: runningMerges ) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges as isMaxNumSegments:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for ( final MergePolicy.OneMerge merge: runningMerges ) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"22b3128eea8c61f8f1f387dac6b3e9504bc8036e","date":1337625491,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges as isMaxNumSegments:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for ( final MergePolicy.OneMerge merge: runningMerges ) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"034b8e37ade96af2cef0172233d24b652b432f99","date":1337636665,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"9d153abcf92dc5329d98571a8c3035df9bd80648","date":1337702630,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fb5728b83dbb3e002cdd22adfe6caf103a96ef15","date":1337791289,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        // nocommit: remove this, except it causes\n        // TestExternalCodecs.testPerFieldCodec failures:\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"615ddbd81799980d0fdd95e0238e1c498b6f47b0","date":1338233290,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges as isMaxNumSegments:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for ( final MergePolicy.OneMerge merge: runningMerges ) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4d3e8520fd031bab31fd0e4d480e55958bc45efe","date":1340901565,"type":3,"author":"Steven Rowe","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"fe33227f6805edab2036cbb80645cc4e2d1fa424","date":1342713534,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws CorruptIndexException, IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"181b1aa5a99534972fbfd5595cdbb38bba5f39ee","date":1350576187,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"62e52115b56781006682fd92c6938efaf174304d","date":1351014780,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7af110b00ea8df9429309d83e38e0533d82e144f","date":1376924768,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"31d4861802ca404d78ca1d15f4550eec415b9199","date":1376947894,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"3dffec77fb8f7d0e9ca4869dddd6af94528b4576","date":1377875202,"type":3,"author":"Han Jiang","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","date":1383367127,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentInfoPerCommit info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"3de2e9a536c4115b4f53f14b6ab496ba3af1840c","date":1400252137,"type":3,"author":"Uwe Schindler","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"ccc69a67d5c846a04c7f71e28cb1914e3af895f3","date":1400252660,"type":3,"author":"Robert Muir","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"56572ec06f1407c066d6b7399413178b33176cd8","date":1400495675,"type":3,"author":"Michael McCandless","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                IOException err = new IOException(\"background merge hit exception: \" + merge.segString(directory));\n                final Throwable t = merge.getException();\n                if (t != null)\n                  err.initCause(t);\n                throw err;\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efcf27cd5ca23def8376b4c321970c14dd71623","date":1400662679,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ca044bd4a0bea8391cbebb44a34aba53a9b50541","date":1400784655,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"ee59f646cf24586a449cad77391a60a3ac8d8959","date":1408015131,"type":3,"author":"Shai Erera","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"949847c0040cd70a68222d526cb0da7bf6cbb3c2","date":1410997182,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   *\n   *  <p><b>NOTE</b>: if this method hits an OutOfMemoryError\n   *  you should immediately close the writer.  See <a\n   *  href=\"#OOME\">above</a> for details.</p>\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (hitOOM) {\n            throw new IllegalStateException(\"this writer hit an OutOfMemoryError; cannot complete forceMerge\");\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"5faf65b6692f15cca0f87bf8666c87899afc619f","date":1420468108,"type":3,"author":"Michael McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(directory), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","date":1477166077,"type":3,"author":"Christine Poerschke","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"80d0e6d59ae23f4a6f30eaf40bfb40742300287f","date":1477598926,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != -1) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f4363cd33f6eff7fb4753574a441e2d18c1022a4","date":1498067235,"type":3,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"b7dfa64bc2074fb87d0ca70095a644c1ead107e1","date":1498356339,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"28288370235ed02234a64753cdbf0c6ec096304a","date":1498726817,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1)\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n\n    flush(true, true);\n\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        segmentsToMerge.put(merge.info, Boolean.TRUE);\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"845b760a99e5f369fcd0a5d723a87b8def6a3f56","date":1521117993,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy.get());\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy);\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"68ba24d6f9380e2463dbe5130d27502647f64904","date":1554881362,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // this can be null since we register the merge under lock before we then do the actual merge and\n          // set the merge.info in _mergeInit\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // this can be null since we put the merge on runningMerges before we do the actual merge and\n          // set the merge.info in _mergeInit\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy.get());\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // TODO: explain why this is sometimes still null\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy.get());\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"737e811ac4583c640a0680e784121677f311a8af","date":1587558614,"type":3,"author":"Simon Willnauer","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/index/IndexWriter#forceMerge(int,boolean).mjava","sourceNew":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // this can be null since we register the merge under lock before we then do the actual merge and\n          // set the merge.info in _mergeInit\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // this can be null since we put the merge on runningMerges before we do the actual merge and\n          // set the merge.info in _mergeInit\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy.get());\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending()) {\n            testPoint(\"forceMergeBeforeWait\");\n            doWait();\n          } else {\n            break;\n          }\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","sourceOld":"  /** Just like {@link #forceMerge(int)}, except you can\n   *  specify whether the call should block until\n   *  all merging completes.  This is only meaningful with a\n   *  {@link MergeScheduler} that is able to run merges in\n   *  background threads.\n   */\n  public void forceMerge(int maxNumSegments, boolean doWait) throws IOException {\n    ensureOpen();\n\n    if (maxNumSegments < 1) {\n      throw new IllegalArgumentException(\"maxNumSegments must be >= 1; got \" + maxNumSegments);\n    }\n\n    if (infoStream.isEnabled(\"IW\")) {\n      infoStream.message(\"IW\", \"forceMerge: index now \" + segString());\n      infoStream.message(\"IW\", \"now flush at forceMerge\");\n    }\n    flush(true, true);\n    synchronized(this) {\n      resetMergeExceptions();\n      segmentsToMerge.clear();\n      for(SegmentCommitInfo info : segmentInfos) {\n        assert info != null;\n        segmentsToMerge.put(info, Boolean.TRUE);\n      }\n      mergeMaxNumSegments = maxNumSegments;\n\n      // Now mark all pending & running merges for forced\n      // merge:\n      for(final MergePolicy.OneMerge merge  : pendingMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // this can be null since we register the merge under lock before we then do the actual merge and\n          // set the merge.info in _mergeInit\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n\n      for (final MergePolicy.OneMerge merge: runningMerges) {\n        merge.maxNumSegments = maxNumSegments;\n        if (merge.info != null) {\n          // this can be null since we put the merge on runningMerges before we do the actual merge and\n          // set the merge.info in _mergeInit\n          segmentsToMerge.put(merge.info, Boolean.TRUE);\n        }\n      }\n    }\n\n    maybeMerge(config.getMergePolicy(), MergeTrigger.EXPLICIT, maxNumSegments);\n\n    if (doWait) {\n      synchronized(this) {\n        while(true) {\n\n          if (tragedy.get() != null) {\n            throw new IllegalStateException(\"this writer hit an unrecoverable error; cannot complete forceMerge\", tragedy.get());\n          }\n\n          if (mergeExceptions.size() > 0) {\n            // Forward any exceptions in background merge\n            // threads to the current thread:\n            final int size = mergeExceptions.size();\n            for(int i=0;i<size;i++) {\n              final MergePolicy.OneMerge merge = mergeExceptions.get(i);\n              if (merge.maxNumSegments != UNBOUNDED_MAX_MERGE_SEGMENTS) {\n                throw new IOException(\"background merge hit exception: \" + merge.segString(), merge.getException());\n              }\n            }\n          }\n\n          if (maxNumSegmentsMergesPending())\n            doWait();\n          else\n            break;\n        }\n      }\n\n      // If close is called while we are still\n      // running, throw an exception so the calling\n      // thread will know merging did not\n      // complete\n      ensureOpen();\n    }\n    // NOTE: in the ConcurrentMergeScheduler case, when\n    // doWait is false, we can return immediately while\n    // background threads accomplish the merging\n  }\n\n","bugFix":["d14e8d18c0e3970c20354dbeeb49da11bd587fbd"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["28288370235ed02234a64753cdbf0c6ec096304a"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["7af110b00ea8df9429309d83e38e0533d82e144f"],"7af110b00ea8df9429309d83e38e0533d82e144f":["181b1aa5a99534972fbfd5595cdbb38bba5f39ee"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["56572ec06f1407c066d6b7399413178b33176cd8"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c"],"737e811ac4583c640a0680e784121677f311a8af":["68ba24d6f9380e2463dbe5130d27502647f64904"],"56572ec06f1407c066d6b7399413178b33176cd8":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"68ba24d6f9380e2463dbe5130d27502647f64904":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"22b3128eea8c61f8f1f387dac6b3e9504bc8036e":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["ee59f646cf24586a449cad77391a60a3ac8d8959"],"3de2e9a536c4115b4f53f14b6ab496ba3af1840c":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0"],"fb5728b83dbb3e002cdd22adfe6caf103a96ef15":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":["181b1aa5a99534972fbfd5595cdbb38bba5f39ee","7af110b00ea8df9429309d83e38e0533d82e144f"],"31d4861802ca404d78ca1d15f4550eec415b9199":["181b1aa5a99534972fbfd5595cdbb38bba5f39ee","7af110b00ea8df9429309d83e38e0533d82e144f"],"9d153abcf92dc5329d98571a8c3035df9bd80648":["034b8e37ade96af2cef0172233d24b652b432f99"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"28288370235ed02234a64753cdbf0c6ec096304a":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","f4363cd33f6eff7fb4753574a441e2d18c1022a4"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["3a119bbc8703c10faa329ec201c654b3a35a1e3e","fb5728b83dbb3e002cdd22adfe6caf103a96ef15"],"62e52115b56781006682fd92c6938efaf174304d":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","181b1aa5a99534972fbfd5595cdbb38bba5f39ee"],"fe33227f6805edab2036cbb80645cc4e2d1fa424":["615ddbd81799980d0fdd95e0238e1c498b6f47b0","4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":["5faf65b6692f15cca0f87bf8666c87899afc619f","6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c"],"181b1aa5a99534972fbfd5595cdbb38bba5f39ee":["4d3e8520fd031bab31fd0e4d480e55958bc45efe"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"034b8e37ade96af2cef0172233d24b652b432f99":["22b3128eea8c61f8f1f387dac6b3e9504bc8036e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["737e811ac4583c640a0680e784121677f311a8af"]},"commit2Childs":{"845b760a99e5f369fcd0a5d723a87b8def6a3f56":["68ba24d6f9380e2463dbe5130d27502647f64904"],"73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0":["56572ec06f1407c066d6b7399413178b33176cd8","ccc69a67d5c846a04c7f71e28cb1914e3af895f3","3de2e9a536c4115b4f53f14b6ab496ba3af1840c"],"7af110b00ea8df9429309d83e38e0533d82e144f":["73b0a97ef3bd519a5e43398ea9eabe6eed97f6b0","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199"],"0efcf27cd5ca23def8376b4c321970c14dd71623":["ca044bd4a0bea8391cbebb44a34aba53a9b50541"],"ee59f646cf24586a449cad77391a60a3ac8d8959":["949847c0040cd70a68222d526cb0da7bf6cbb3c2"],"3a119bbc8703c10faa329ec201c654b3a35a1e3e":["22b3128eea8c61f8f1f387dac6b3e9504bc8036e","615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"f4363cd33f6eff7fb4753574a441e2d18c1022a4":["b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a"],"56572ec06f1407c066d6b7399413178b33176cd8":["0efcf27cd5ca23def8376b4c321970c14dd71623"],"737e811ac4583c640a0680e784121677f311a8af":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"ccc69a67d5c846a04c7f71e28cb1914e3af895f3":[],"6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c":["f4363cd33f6eff7fb4753574a441e2d18c1022a4","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","28288370235ed02234a64753cdbf0c6ec096304a","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"68ba24d6f9380e2463dbe5130d27502647f64904":["737e811ac4583c640a0680e784121677f311a8af"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["3a119bbc8703c10faa329ec201c654b3a35a1e3e"],"22b3128eea8c61f8f1f387dac6b3e9504bc8036e":["034b8e37ade96af2cef0172233d24b652b432f99"],"4d3e8520fd031bab31fd0e4d480e55958bc45efe":["62e52115b56781006682fd92c6938efaf174304d","fe33227f6805edab2036cbb80645cc4e2d1fa424","181b1aa5a99534972fbfd5595cdbb38bba5f39ee"],"949847c0040cd70a68222d526cb0da7bf6cbb3c2":["5faf65b6692f15cca0f87bf8666c87899afc619f"],"3de2e9a536c4115b4f53f14b6ab496ba3af1840c":["ee59f646cf24586a449cad77391a60a3ac8d8959","56572ec06f1407c066d6b7399413178b33176cd8","ccc69a67d5c846a04c7f71e28cb1914e3af895f3"],"fb5728b83dbb3e002cdd22adfe6caf103a96ef15":["615ddbd81799980d0fdd95e0238e1c498b6f47b0"],"ca044bd4a0bea8391cbebb44a34aba53a9b50541":[],"3dffec77fb8f7d0e9ca4869dddd6af94528b4576":[],"31d4861802ca404d78ca1d15f4550eec415b9199":[],"9d153abcf92dc5329d98571a8c3035df9bd80648":["fb5728b83dbb3e002cdd22adfe6caf103a96ef15"],"b7dfa64bc2074fb87d0ca70095a644c1ead107e1":[],"28288370235ed02234a64753cdbf0c6ec096304a":["845b760a99e5f369fcd0a5d723a87b8def6a3f56"],"615ddbd81799980d0fdd95e0238e1c498b6f47b0":["4d3e8520fd031bab31fd0e4d480e55958bc45efe","fe33227f6805edab2036cbb80645cc4e2d1fa424"],"62e52115b56781006682fd92c6938efaf174304d":[],"fe33227f6805edab2036cbb80645cc4e2d1fa424":[],"80d0e6d59ae23f4a6f30eaf40bfb40742300287f":[],"181b1aa5a99534972fbfd5595cdbb38bba5f39ee":["7af110b00ea8df9429309d83e38e0533d82e144f","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","62e52115b56781006682fd92c6938efaf174304d"],"5faf65b6692f15cca0f87bf8666c87899afc619f":["6b53db710c6b8fb48bb3a2bab4df8d1dfbd7906c","80d0e6d59ae23f4a6f30eaf40bfb40742300287f"],"034b8e37ade96af2cef0172233d24b652b432f99":["9d153abcf92dc5329d98571a8c3035df9bd80648"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["ccc69a67d5c846a04c7f71e28cb1914e3af895f3","ca044bd4a0bea8391cbebb44a34aba53a9b50541","3dffec77fb8f7d0e9ca4869dddd6af94528b4576","31d4861802ca404d78ca1d15f4550eec415b9199","b7dfa64bc2074fb87d0ca70095a644c1ead107e1","62e52115b56781006682fd92c6938efaf174304d","fe33227f6805edab2036cbb80645cc4e2d1fa424","80d0e6d59ae23f4a6f30eaf40bfb40742300287f","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}