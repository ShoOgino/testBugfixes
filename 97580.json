{"path":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","commits":[{"id":"a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","date":1491224823,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(boolean randomAccess) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":["1b92f673a8027e5fb106d73b5d3e321f2c4db3f6"],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"0e98a4d8e18e7296a274ca283df84a76544bd753","date":1491296430,"type":0,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"/dev/null","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(boolean randomAccess) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"24f3e9c0fc20b3107388ec853a6fbad9f891b461","date":1502359844,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(boolean randomAccess) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"7d6ba405c7c8192661bdf7ce782181d12f3162a6","date":1502361392,"type":3,"author":"Cao Manh Dat","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(boolean randomAccess) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"58884af1f68e9d61c217c753fbd6266d86a63b14","date":1502363401,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(boolean randomAccess) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","date":1502692251,"type":3,"author":"Shalin Shekhar Mangar","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(boolean randomAccess) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"706a7a3396c030cc66dda92a0492eb492131c4c0","date":1509705614,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      final IndexReader.CacheHelper cacheHelper = in.getCacheHelper(context);\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"d523b8189b211dd1630166aa77b8c88bb48b3fcc","date":1510144168,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      final IndexReader.CacheHelper cacheHelper = in.getCacheHelper(context);\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      // TODO: should it be pluggable, eg. for queries that run on doc values?\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"da1460d7a5dea2658e7b8e4f6e632e53ade440ac","date":1510316270,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      final IndexReader.CacheHelper cacheHelper = in.getCacheHelper(context);\n      if (cacheHelper == null) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"c7732a106554be0db3e03ac5211e46f6e0c285b8","date":1511975378,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        ScorerSupplier inSupplier = in.scorerSupplier(context);\n        if (inSupplier == null) {\n          putIfAbsent(in.getQuery(), context, DocIdSet.EMPTY, cacheHelper);\n          return null;\n        }\n        \n        if (policy.shouldCache(in.getQuery())) {\n          return new ScorerSupplier() {\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              double costFactor = (double) inSupplier.cost() / leadCost;\n              if (costFactor >= maxCostFactor) {\n                // too costly, caching might make the query much slower\n                return inSupplier.get(leadCost);\n              }\n              DocIdSet cached = cacheImpl(new DefaultBulkScorer(inSupplier.get(Long.MAX_VALUE)), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), context, cached, cacheHelper);\n              DocIdSetIterator iterator = cached.iterator();\n              if (iterator == null) {\n                // DIS.iterator() is allowed to return null when empty but we want a non-null iterator here\n                iterator = DocIdSetIterator.empty();\n              }\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, iterator);\n            }\n\n            @Override\n            public long cost() {\n              return inSupplier.cost();\n            }\n          };\n        } else {\n          return inSupplier;\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1aad05eeff7818b0833c02ac6b743aa72054963b","date":1512093122,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        ScorerSupplier inSupplier = in.scorerSupplier(context);\n        if (inSupplier == null) {\n          putIfAbsent(in.getQuery(), context, DocIdSet.EMPTY, cacheHelper);\n          return null;\n        }\n        \n        if (policy.shouldCache(in.getQuery())) {\n          return new ScorerSupplier() {\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              double costFactor = (double) inSupplier.cost() / leadCost;\n              if (costFactor >= maxCostFactor) {\n                // too costly, caching might make the query much slower\n                return inSupplier.get(leadCost);\n              }\n              DocIdSet cached = cacheImpl(new DefaultBulkScorer(inSupplier.get(Long.MAX_VALUE)), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), context, cached, cacheHelper);\n              DocIdSetIterator iterator = cached.iterator();\n              if (iterator == null) {\n                // DIS.iterator() is allowed to return null when empty but we want a non-null iterator here\n                iterator = DocIdSetIterator.empty();\n              }\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, iterator);\n            }\n\n            @Override\n            public long cost() {\n              return inSupplier.cost();\n            }\n          };\n        } else {\n          return inSupplier;\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"789fb338d3c53b4478938723d60f6623e764ca38","date":1521535944,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        ScorerSupplier inSupplier = in.scorerSupplier(context);\n        if (inSupplier == null) {\n          putIfAbsent(in.getQuery(), context, DocIdSet.EMPTY, cacheHelper);\n          return null;\n        }\n        \n        if (policy.shouldCache(in.getQuery())) {\n          return new ScorerSupplier() {\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              double costFactor = (double) inSupplier.cost() / leadCost;\n              if (costFactor >= maxCostFactor) {\n                // too costly, caching might make the query much slower\n                return inSupplier.get(leadCost);\n              }\n              DocIdSet cached = cacheImpl(new DefaultBulkScorer(inSupplier.get(Long.MAX_VALUE)), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), context, cached, cacheHelper);\n              DocIdSetIterator iterator = cached.iterator();\n              if (iterator == null) {\n                // DIS.iterator() is allowed to return null when empty but we want a non-null iterator here\n                iterator = DocIdSetIterator.empty();\n              }\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, iterator);\n            }\n\n            @Override\n            public long cost() {\n              return inSupplier.cost();\n            }\n          };\n        } else {\n          return inSupplier;\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","date":1521731438,"type":3,"author":"Karl Wright","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        ScorerSupplier inSupplier = in.scorerSupplier(context);\n        if (inSupplier == null) {\n          putIfAbsent(in.getQuery(), context, DocIdSet.EMPTY, cacheHelper);\n          return null;\n        }\n        \n        if (policy.shouldCache(in.getQuery())) {\n          return new ScorerSupplier() {\n\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              double costFactor = (double) inSupplier.cost() / leadCost;\n              if (costFactor >= maxCostFactor) {\n                // too costly, caching might make the query much slower\n                return inSupplier.get(leadCost);\n              }\n              DocIdSet cached = cacheImpl(new DefaultBulkScorer(inSupplier.get(Long.MAX_VALUE)), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), context, cached, cacheHelper);\n              DocIdSetIterator iterator = cached.iterator();\n              if (iterator == null) {\n                // DIS.iterator() is allowed to return null when empty but we want a non-null iterator here\n                iterator = DocIdSetIterator.empty();\n              }\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, iterator);\n            }\n\n            @Override\n            public long cost() {\n              return inSupplier.cost();\n            }\n          };\n        } else {\n          return inSupplier;\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"1b92f673a8027e5fb106d73b5d3e321f2c4db3f6","date":1523872632,"type":3,"author":"Alan Woodward","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9c226b0eeb8b028f572020f459851a663a2c064e","date":1542377651,"type":3,"author":"Christophe Bismuth","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"d4e703a107dabba92e897b4405f4a69f135565a2","date":1567669029,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), context, cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), context, docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"6f740a4cb7f5949ddb40a1647671c4a997223312","date":1569677340,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, synchronous caching will\n            // be performed, hence do not return the uncached value\n            if (cacheSynchronously == false) {\n              return in.scorerSupplier(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"4b9f74021389e2b32ee750fa5a24281c87951ec3","date":1569845983,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, synchronous caching will\n            // be performed, hence do not return the uncached value\n            if (cacheSynchronously == false) {\n              return in.scorerSupplier(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"906d4da7e00f8453a5a024fe1ee92d6b14c0627f","date":1570006475,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, synchronous caching will\n            // be performed, hence do not return the uncached value\n            if (cacheSynchronously == false) {\n              return in.scorerSupplier(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b0b597c65628ca9e73913a07e81691f8229bae35","date":1571224353,"type":3,"author":"jimczi","isMerge":true,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          boolean cacheSynchronously = executor == null;\n\n          // If asynchronous caching is requested, perform the same and return\n          // the uncached iterator\n          if (cacheSynchronously == false) {\n            cacheSynchronously = cacheAsynchronously(context, cacheHelper);\n\n            // If async caching failed, synchronous caching will\n            // be performed, hence do not return the uncached value\n            if (cacheSynchronously == false) {\n              return in.scorerSupplier(context);\n            }\n          }\n\n          if (cacheSynchronously) {\n            docIdSet = cache(context);\n            putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n          }\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"b5754bd6f04f13b67e9575f8b226a0303c31c7d5","date":1573506453,"type":3,"author":"ginger","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          final ScorerSupplier supplier = in.scorerSupplier(context);\n          if (supplier == null) {\n            putIfAbsent(in.getQuery(), DocIdSet.EMPTY, cacheHelper);\n            return null;\n          }\n\n          final long cost = supplier.cost();\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              // skip cache operation which would slow query down too much\n              if (cost / skipCacheFactor > leadCost) {\n                return supplier.get(leadCost);\n              }\n\n              Scorer scorer = supplier.get(Long.MAX_VALUE);\n              DocIdSet docIdSet = cacheImpl(new DefaultBulkScorer(scorer), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n              DocIdSetIterator disi = docIdSet.iterator();\n              if (disi == null) {\n                // docIdSet.iterator() is allowed to return null when empty but we want a non-null iterator here\n                disi = DocIdSetIterator.empty();\n              }\n\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n            }\n\n            @Override\n            public long cost() {\n              return cost;\n            }\n          };\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n\n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          docIdSet = cache(context);\n          putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n        \n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"1fbdd90cd58912788fecb1044df8f566a4420e59","date":1574749923,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          final ScorerSupplier supplier = in.scorerSupplier(context);\n          if (supplier == null) {\n            putIfAbsent(in.getQuery(), DocIdSet.EMPTY, cacheHelper);\n            return null;\n          }\n\n          final long cost = supplier.cost();\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              // skip cache operation which would slow query down too much\n              if (cost / skipCacheFactor > leadCost) {\n                return supplier.get(leadCost);\n              }\n\n              boolean cacheSynchronously = executor == null;\n              if (cacheSynchronously == false) {\n                boolean asyncCachingSucceeded = cacheAsynchronously(context, cacheHelper);\n\n                // If async caching failed, synchronous caching will\n                // be performed, hence do not return the uncached value\n                if (asyncCachingSucceeded) {\n                  return supplier.get(leadCost);\n                }\n              }\n              \n              Scorer scorer = supplier.get(Long.MAX_VALUE);\n              DocIdSet docIdSet = cacheImpl(new DefaultBulkScorer(scorer), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n              DocIdSetIterator disi = docIdSet.iterator();\n              if (disi == null) {\n                // docIdSet.iterator() is allowed to return null when empty but we want a non-null iterator here\n                disi = DocIdSetIterator.empty();\n              }\n\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n            }\n\n            @Override\n            public long cost() {\n              return cost;\n            }\n          };\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n\n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          final ScorerSupplier supplier = in.scorerSupplier(context);\n          if (supplier == null) {\n            putIfAbsent(in.getQuery(), DocIdSet.EMPTY, cacheHelper);\n            return null;\n          }\n\n          final long cost = supplier.cost();\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              // skip cache operation which would slow query down too much\n              if (cost / skipCacheFactor > leadCost) {\n                return supplier.get(leadCost);\n              }\n\n              Scorer scorer = supplier.get(Long.MAX_VALUE);\n              DocIdSet docIdSet = cacheImpl(new DefaultBulkScorer(scorer), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n              DocIdSetIterator disi = docIdSet.iterator();\n              if (disi == null) {\n                // docIdSet.iterator() is allowed to return null when empty but we want a non-null iterator here\n                disi = DocIdSetIterator.empty();\n              }\n\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n            }\n\n            @Override\n            public long cost() {\n              return cost;\n            }\n          };\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n\n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9bbc355b3e849ee4a34763155bb78e638d625419","date":1574952532,"type":3,"author":"Atri Sharma","isMerge":false,"pathNew":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","pathOld":"lucene/core/src/java/org/apache/lucene/search/LRUQueryCache.CachingWrapperWeight#scorerSupplier(LeafReaderContext).mjava","sourceNew":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          final ScorerSupplier supplier = in.scorerSupplier(context);\n          if (supplier == null) {\n            putIfAbsent(in.getQuery(), DocIdSet.EMPTY, cacheHelper);\n            return null;\n          }\n\n          final long cost = supplier.cost();\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              // skip cache operation which would slow query down too much\n              if (cost / skipCacheFactor > leadCost) {\n                return supplier.get(leadCost);\n              }\n\n              Scorer scorer = supplier.get(Long.MAX_VALUE);\n              DocIdSet docIdSet = cacheImpl(new DefaultBulkScorer(scorer), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n              DocIdSetIterator disi = docIdSet.iterator();\n              if (disi == null) {\n                // docIdSet.iterator() is allowed to return null when empty but we want a non-null iterator here\n                disi = DocIdSetIterator.empty();\n              }\n\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n            }\n\n            @Override\n            public long cost() {\n              return cost;\n            }\n          };\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n\n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","sourceOld":"    @Override\n    public ScorerSupplier scorerSupplier(LeafReaderContext context) throws IOException {\n      if (used.compareAndSet(false, true)) {\n        policy.onUse(getQuery());\n      }\n\n      if (in.isCacheable(context) == false) {\n        // this segment is not suitable for caching\n        return in.scorerSupplier(context);\n      }\n\n      // Short-circuit: Check whether this segment is eligible for caching\n      // before we take a lock because of #get\n      if (shouldCache(context) == false) {\n        return in.scorerSupplier(context);\n      }\n\n      final IndexReader.CacheHelper cacheHelper = context.reader().getCoreCacheHelper();\n      if (cacheHelper == null) {\n        // this reader has no cache helper\n        return in.scorerSupplier(context);\n      }\n\n      // If the lock is already busy, prefer using the uncached version than waiting\n      if (lock.tryLock() == false) {\n        return in.scorerSupplier(context);\n      }\n\n      DocIdSet docIdSet;\n      try {\n        docIdSet = get(in.getQuery(), cacheHelper);\n      } finally {\n        lock.unlock();\n      }\n\n      if (docIdSet == null) {\n        if (policy.shouldCache(in.getQuery())) {\n          final ScorerSupplier supplier = in.scorerSupplier(context);\n          if (supplier == null) {\n            putIfAbsent(in.getQuery(), DocIdSet.EMPTY, cacheHelper);\n            return null;\n          }\n\n          final long cost = supplier.cost();\n          return new ScorerSupplier() {\n            @Override\n            public Scorer get(long leadCost) throws IOException {\n              // skip cache operation which would slow query down too much\n              if (cost / skipCacheFactor > leadCost) {\n                return supplier.get(leadCost);\n              }\n\n              boolean cacheSynchronously = executor == null;\n              if (cacheSynchronously == false) {\n                boolean asyncCachingSucceeded = cacheAsynchronously(context, cacheHelper);\n\n                // If async caching failed, synchronous caching will\n                // be performed, hence do not return the uncached value\n                if (asyncCachingSucceeded) {\n                  return supplier.get(leadCost);\n                }\n              }\n              \n              Scorer scorer = supplier.get(Long.MAX_VALUE);\n              DocIdSet docIdSet = cacheImpl(new DefaultBulkScorer(scorer), context.reader().maxDoc());\n              putIfAbsent(in.getQuery(), docIdSet, cacheHelper);\n              DocIdSetIterator disi = docIdSet.iterator();\n              if (disi == null) {\n                // docIdSet.iterator() is allowed to return null when empty but we want a non-null iterator here\n                disi = DocIdSetIterator.empty();\n              }\n\n              return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n            }\n\n            @Override\n            public long cost() {\n              return cost;\n            }\n          };\n        } else {\n          return in.scorerSupplier(context);\n        }\n      }\n\n      assert docIdSet != null;\n      if (docIdSet == DocIdSet.EMPTY) {\n        return null;\n      }\n      final DocIdSetIterator disi = docIdSet.iterator();\n      if (disi == null) {\n        return null;\n      }\n\n      return new ScorerSupplier() {\n        @Override\n        public Scorer get(long LeadCost) throws IOException {\n          return new ConstantScoreScorer(CachingWrapperWeight.this, 0f, ScoreMode.COMPLETE_NO_SCORES, disi);\n        }\n\n        @Override\n        public long cost() {\n          return disi.cost();\n        }\n      };\n\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"706a7a3396c030cc66dda92a0492eb492131c4c0":["7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"1b92f673a8027e5fb106d73b5d3e321f2c4db3f6":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["1aad05eeff7818b0833c02ac6b743aa72054963b","789fb338d3c53b4478938723d60f6623e764ca38"],"24f3e9c0fc20b3107388ec853a6fbad9f891b461":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["7d6ba405c7c8192661bdf7ce782181d12f3162a6","706a7a3396c030cc66dda92a0492eb492131c4c0"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"58884af1f68e9d61c217c753fbd6266d86a63b14":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"789fb338d3c53b4478938723d60f6623e764ca38":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"6f740a4cb7f5949ddb40a1647671c4a997223312":["d4e703a107dabba92e897b4405f4a69f135565a2"],"9bbc355b3e849ee4a34763155bb78e638d625419":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"4b9f74021389e2b32ee750fa5a24281c87951ec3":["d4e703a107dabba92e897b4405f4a69f135565a2","6f740a4cb7f5949ddb40a1647671c4a997223312"],"906d4da7e00f8453a5a024fe1ee92d6b14c0627f":["6f740a4cb7f5949ddb40a1647671c4a997223312"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"b5754bd6f04f13b67e9575f8b226a0303c31c7d5":["906d4da7e00f8453a5a024fe1ee92d6b14c0627f"],"9c226b0eeb8b028f572020f459851a663a2c064e":["1b92f673a8027e5fb106d73b5d3e321f2c4db3f6"],"1fbdd90cd58912788fecb1044df8f566a4420e59":["b5754bd6f04f13b67e9575f8b226a0303c31c7d5"],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"7d6ba405c7c8192661bdf7ce782181d12f3162a6":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","24f3e9c0fc20b3107388ec853a6fbad9f891b461"],"d4e703a107dabba92e897b4405f4a69f135565a2":["9c226b0eeb8b028f572020f459851a663a2c064e"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":["0e98a4d8e18e7296a274ca283df84a76544bd753","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9bbc355b3e849ee4a34763155bb78e638d625419"],"b0b597c65628ca9e73913a07e81691f8229bae35":["4b9f74021389e2b32ee750fa5a24281c87951ec3","906d4da7e00f8453a5a024fe1ee92d6b14c0627f"],"0e98a4d8e18e7296a274ca283df84a76544bd753":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"]},"commit2Childs":{"706a7a3396c030cc66dda92a0492eb492131c4c0":["d523b8189b211dd1630166aa77b8c88bb48b3fcc"],"1b92f673a8027e5fb106d73b5d3e321f2c4db3f6":["9c226b0eeb8b028f572020f459851a663a2c064e"],"6815b5b5d6334b2245dd7be2f8b6cca949bf7f43":["1b92f673a8027e5fb106d73b5d3e321f2c4db3f6"],"24f3e9c0fc20b3107388ec853a6fbad9f891b461":["7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"d523b8189b211dd1630166aa77b8c88bb48b3fcc":["da1460d7a5dea2658e7b8e4f6e632e53ade440ac"],"1aad05eeff7818b0833c02ac6b743aa72054963b":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43","789fb338d3c53b4478938723d60f6623e764ca38"],"58884af1f68e9d61c217c753fbd6266d86a63b14":[],"789fb338d3c53b4478938723d60f6623e764ca38":["6815b5b5d6334b2245dd7be2f8b6cca949bf7f43"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b","0e98a4d8e18e7296a274ca283df84a76544bd753"],"6f740a4cb7f5949ddb40a1647671c4a997223312":["4b9f74021389e2b32ee750fa5a24281c87951ec3","906d4da7e00f8453a5a024fe1ee92d6b14c0627f"],"9bbc355b3e849ee4a34763155bb78e638d625419":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"4b9f74021389e2b32ee750fa5a24281c87951ec3":["b0b597c65628ca9e73913a07e81691f8229bae35"],"906d4da7e00f8453a5a024fe1ee92d6b14c0627f":["b5754bd6f04f13b67e9575f8b226a0303c31c7d5","b0b597c65628ca9e73913a07e81691f8229bae35"],"da1460d7a5dea2658e7b8e4f6e632e53ade440ac":["1aad05eeff7818b0833c02ac6b743aa72054963b","c7732a106554be0db3e03ac5211e46f6e0c285b8"],"b5754bd6f04f13b67e9575f8b226a0303c31c7d5":["1fbdd90cd58912788fecb1044df8f566a4420e59"],"9c226b0eeb8b028f572020f459851a663a2c064e":["d4e703a107dabba92e897b4405f4a69f135565a2"],"c7732a106554be0db3e03ac5211e46f6e0c285b8":["1aad05eeff7818b0833c02ac6b743aa72054963b"],"1fbdd90cd58912788fecb1044df8f566a4420e59":["9bbc355b3e849ee4a34763155bb78e638d625419"],"7d6ba405c7c8192661bdf7ce782181d12f3162a6":["706a7a3396c030cc66dda92a0492eb492131c4c0","d523b8189b211dd1630166aa77b8c88bb48b3fcc","58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"d4e703a107dabba92e897b4405f4a69f135565a2":["6f740a4cb7f5949ddb40a1647671c4a997223312","4b9f74021389e2b32ee750fa5a24281c87951ec3"],"93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be":[],"a94c3ed25a08dda75a7682a15aa4499e5cdc9d8b":["24f3e9c0fc20b3107388ec853a6fbad9f891b461","58884af1f68e9d61c217c753fbd6266d86a63b14","7d6ba405c7c8192661bdf7ce782181d12f3162a6"],"0e98a4d8e18e7296a274ca283df84a76544bd753":["93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"b0b597c65628ca9e73913a07e81691f8229bae35":[]},"heads":["58884af1f68e9d61c217c753fbd6266d86a63b14","93d40a0287bd8a5b69a8df49a797dcd4a8b1a7be","cd5edd1f2b162a5cfa08efd17851a07373a96817","b0b597c65628ca9e73913a07e81691f8229bae35"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}