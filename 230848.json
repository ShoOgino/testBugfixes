{"path":"solr/core/src/java/org/apache/solr/cloud/OverseerProcessor.Runner#run().mjava","commits":[{"id":"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac","date":1438841252,"type":1,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerCollectionProcessor.Runner#run().mjava","sourceNew":"    public void run() {\n      String statsName = messageHandler.getTimerName(operation);\n      final TimerContext timerContext = stats.time(statsName);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String taskKey = messageHandler.getTaskKey(message);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = messageHandler.processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats(statsName);\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(messageHandler, head.getId(), asyncId, taskKey);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(messageHandler.getName() + \": Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    @Override\n    public void run() {\n\n      final TimerContext timerContext = stats.time(\"collection_\" + operation);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String collectionName = message.containsKey(COLLECTION_PROP) ?\n          message.getStr(COLLECTION_PROP) : message.getStr(NAME);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats();\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(head.getId(), asyncId, collectionName);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(\"Overseer Collection Processor: Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(head.getId(), asyncId, collectionName);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(head.getId(), asyncId, collectionName);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"2209af2c265d2258ec4b29c8cc78622d36994a15","date":1440641916,"type":5,"author":"Gregory Chanan","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/cloud/OverseerTaskProcessor.Runner#run().mjava","pathOld":"solr/core/src/java/org/apache/solr/cloud/OverseerProcessor.Runner#run().mjava","sourceNew":"    public void run() {\n      String statsName = messageHandler.getTimerName(operation);\n      final TimerContext timerContext = stats.time(statsName);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String taskKey = messageHandler.getTaskKey(message);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = messageHandler.processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats(statsName);\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(messageHandler, head.getId(), asyncId, taskKey, message);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(messageHandler.getName() + \": Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey, message);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey, message);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","sourceOld":"    public void run() {\n      String statsName = messageHandler.getTimerName(operation);\n      final TimerContext timerContext = stats.time(statsName);\n\n      boolean success = false;\n      final String asyncId = message.getStr(ASYNC);\n      String taskKey = messageHandler.getTaskKey(message);\n\n      try {\n        try {\n          log.debug(\"Runner processing {}\", head.getId());\n          response = messageHandler.processMessage(message, operation);\n        } finally {\n          timerContext.stop();\n          updateStats(statsName);\n        }\n\n        if(asyncId != null) {\n          if (response != null && (response.getResponse().get(\"failure\") != null \n              || response.getResponse().get(\"exception\") != null)) {\n            failureMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated failed map for task with zkid:[{}]\", head.getId());\n          } else {\n            completedMap.put(asyncId, SolrResponse.serializable(response));\n            log.debug(\"Updated completed map for task with zkid:[{}]\", head.getId());\n          }\n        } else {\n          head.setBytes(SolrResponse.serializable(response));\n          log.debug(\"Completed task:[{}]\", head.getId());\n        }\n\n        markTaskComplete(messageHandler, head.getId(), asyncId, taskKey);\n        log.debug(\"Marked task [{}] as completed.\", head.getId());\n        printTrackingMaps();\n\n        log.info(messageHandler.getName() + \": Message id:\" + head.getId() +\n            \" complete, response:\" + response.getResponse().toString());\n        success = true;\n      } catch (KeeperException e) {\n        SolrException.log(log, \"\", e);\n      } catch (InterruptedException e) {\n        // Reset task from tracking data structures so that it can be retried.\n        resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey);\n        log.warn(\"Resetting task {} as the thread was interrupted.\", head.getId());\n        Thread.currentThread().interrupt();\n      } finally {\n        if(!success) {\n          // Reset task from tracking data structures so that it can be retried.\n          resetTaskWithException(messageHandler, head.getId(), asyncId, taskKey);\n        }\n        synchronized (waitLock){\n          waitLock.notifyAll();\n        }\n      }\n    }\n\n","bugFix":null,"bugIntro":["bb222a3f9d9421d5c95afce73013fbd8de07ea1f"],"isBuggy":true,"nexts":[],"revCommit":null}],"commit2Parents":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["2209af2c265d2258ec4b29c8cc78622d36994a15"]},"commit2Childs":{"e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac":["2209af2c265d2258ec4b29c8cc78622d36994a15"],"2209af2c265d2258ec4b29c8cc78622d36994a15":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["e31e6ce5848e5040d4c9ecbb25bc6ccf5d0894ac"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}