{"path":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","commits":[{"id":"5ae3b56523ea072233ba817a3da28207b44dc3a9","date":1523888644,"type":1,"author":"Alan Woodward","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrds#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    assumeFalse(\"Don't run this massive test with MemoryPostingsFormat, as it can OOM\",\n        Objects.equals(Codec.getDefault().postingsFormat().getName(), \"Memory\"));\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n    \n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"a1c374690db69470f6aa4bffc43dcacf1f4e3e49","date":1529007399,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26","date":1531589977,"type":3,"author":"Michael Braun","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","date":1531905561,"type":3,"author":"Alessandro Benedetti","isMerge":true,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","date":1536291831,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n// commented 4-Sep-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"44dd40f6c2c1465aebf4677bab10f696c7ea18d8","date":1539566013,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n// commented 4-Sep-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n// commented 4-Sep-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"8d35c84fdef07284c122012ca4000d3b7285a66e","date":1545962630,"type":3,"author":"Erick Erickson","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  // commented 4-Sep-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n// commented 4-Sep-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"06fb0ce62429b92162cf3072e51908720455df48","date":1554502010,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    // disk based Directory to reduce risk of OOM\n    Directory dir = newFSDirectory(createTempDir(\"TestDocTermOrdsUninvertLimit\"));\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  // commented 4-Sep-2018   @LuceneTestCase.BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 12-Jun-2018\n  // commented out on: 24-Dec-2018   @BadApple(bugUrl=\"https://issues.apache.org/jira/browse/SOLR-12028\") // 14-Oct-2018\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    Directory dir = newDirectory();\n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"9dc5c6ecb7a17052d4649b4b5a5608c92346eb5e","date":1557426883,"type":3,"author":"Chris Hostetter","isMerge":false,"pathNew":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","pathOld":"solr/core/src/test/org/apache/solr/uninverting/TestDocTermOrdsUninvertLimit#testTriggerUnInvertLimit().mjava","sourceNew":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    // disk based Directory and IWC settings to reduce risk of OOM\n    Directory dir = newFSDirectory(createTempDir(\"TestDocTermOrdsUninvertLimit\"));\n    final IndexWriter w = new IndexWriter(dir,\n                                          new IndexWriterConfig(new MockAnalyzer(random()))\n                                          .setMaxBufferedDocs(IndexWriterConfig.DISABLE_AUTO_FLUSH)\n                                          .setRAMBufferSizeMB(256.0)\n                                          .setMergeScheduler(new ConcurrentMergeScheduler())\n                                          .setMergePolicy(newLogMergePolicy(false, 10))\n                                          .setOpenMode(IndexWriterConfig.OpenMode.CREATE)\n                                          .setCodec(TestUtil.getDefaultCodec()));\n    \n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    w.close();\n    \n    final IndexReader r = DirectoryReader.open(dir);\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","sourceOld":"  /* UnInvertedField had a reference block limitation of 2^24. This unit test triggered it.\n   *\n   * With the current code, the test verifies that the old limit no longer applies.\n   * New limit is 2^31, which is not very realistic to unit-test. */\n  @SuppressWarnings({\"ConstantConditions\", \"PointlessBooleanExpression\"})\n  @Nightly\n  public void testTriggerUnInvertLimit() throws IOException {\n    final boolean SHOULD_TRIGGER = false; // Set this to true to use the test with the old implementation\n\n    // Ensure enough terms inside of a single UnInvert-pass-structure to trigger the limit\n    final int REF_LIMIT = (int) Math.pow(2, 24); // Maximum number of references within a single pass-structure\n    final int DOCS = (1<<16)-1;                  // The number of documents within a single pass (simplified)\n    final int TERMS = REF_LIMIT/DOCS;            // Each document must have this many references aka terms hit limit\n\n    // disk based Directory to reduce risk of OOM\n    Directory dir = newFSDirectory(createTempDir(\"TestDocTermOrdsUninvertLimit\"));\n    \n    final RandomIndexWriter w = new RandomIndexWriter(random(), dir,\n        newIndexWriterConfig(new MockAnalyzer(random())).setMergePolicy(newLogMergePolicy()));\n    Document doc = new Document();\n    Field field = newTextField(\"field\", \"\", Field.Store.NO);\n    doc.add(field);\n\n    StringBuilder sb = new StringBuilder(TERMS*(Integer.toString(TERMS).length()+1));\n    for (int i = 0 ; i < TERMS ; i++) {\n      sb.append(\" \").append(Integer.toString(i));\n    }\n    field.setStringValue(sb.toString());\n\n    for (int i = 0 ; i < DOCS ; i++) {\n      w.addDocument(doc);\n    }\n    //System.out.println(\"\\n Finished adding \" + DOCS + \" documents of \" + TERMS + \" unique terms\");\n    final IndexReader r = w.getReader();\n    w.close();\n\n    try {\n      final LeafReader ar = SlowCompositeReaderWrapper.wrap(r);\n      TestUtil.checkReader(ar);\n      final DocTermOrds dto = new DocTermOrds(ar, ar.getLiveDocs(), \"field\"); // bigTerms turned off\n      if (SHOULD_TRIGGER) {\n        fail(\"DocTermOrds should have failed with a \\\"Too many values for UnInvertedField\\\" message\");\n      }\n    } catch (IllegalStateException e) {\n      if (!SHOULD_TRIGGER) {\n        fail(\"DocTermsOrd should not have failed with this implementation, but got exception \" +\n            e.getClass().getSimpleName() + \" with message \" + e.getMessage());\n      }\n      // This is (hopefully) \"Too many values for UnInvertedField faceting on field field\", so all is as expected\n    } finally {\n      r.close();\n      dir.close();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a"],"5ae3b56523ea072233ba817a3da28207b44dc3a9":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":["5ae3b56523ea072233ba817a3da28207b44dc3a9","a1c374690db69470f6aa4bffc43dcacf1f4e3e49"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["a1c374690db69470f6aa4bffc43dcacf1f4e3e49"],"06fb0ce62429b92162cf3072e51908720455df48":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["9dc5c6ecb7a17052d4649b4b5a5608c92346eb5e"],"9dc5c6ecb7a17052d4649b4b5a5608c92346eb5e":["06fb0ce62429b92162cf3072e51908720455df48"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"a1c374690db69470f6aa4bffc43dcacf1f4e3e49":["5ae3b56523ea072233ba817a3da28207b44dc3a9"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":["5ae3b56523ea072233ba817a3da28207b44dc3a9","a1c374690db69470f6aa4bffc43dcacf1f4e3e49"]},"commit2Childs":{"44dd40f6c2c1465aebf4677bab10f696c7ea18d8":["8d35c84fdef07284c122012ca4000d3b7285a66e"],"5ae3b56523ea072233ba817a3da28207b44dc3a9":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","a1c374690db69470f6aa4bffc43dcacf1f4e3e49","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"0efc9f2cae117418f13ba9035f5e1d516ea7a2b5":[],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["5ae3b56523ea072233ba817a3da28207b44dc3a9"],"f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a":["44dd40f6c2c1465aebf4677bab10f696c7ea18d8"],"06fb0ce62429b92162cf3072e51908720455df48":["9dc5c6ecb7a17052d4649b4b5a5608c92346eb5e"],"a1c374690db69470f6aa4bffc43dcacf1f4e3e49":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","f7ba5de6e78dd9b7518e92274a8a4cf8823a9c4a","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"8d35c84fdef07284c122012ca4000d3b7285a66e":["06fb0ce62429b92162cf3072e51908720455df48"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[],"9dc5c6ecb7a17052d4649b4b5a5608c92346eb5e":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"7eeaaea0106c7d6a2de50acfc8d357121ef8bd26":[]},"heads":["0efc9f2cae117418f13ba9035f5e1d516ea7a2b5","cd5edd1f2b162a5cfa08efd17851a07373a96817","7eeaaea0106c7d6a2de50acfc8d357121ef8bd26"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}