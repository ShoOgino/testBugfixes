{"path":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","commits":[{"id":"4522ffca5a1f420c6a02198c9332d7c596a30ca5","date":1457270822,"type":1,"author":"Mike McCandless","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"367f57e2ee85b7f7e28cfe73370a22cf67624f65","date":1476778467,"type":3,"author":"Adrien Grand","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":true,"nexts":[],"revCommit":null},{"id":"4cce5816ef15a48a0bc11e5d400497ee4301dd3b","date":1476991456,"type":3,"author":"Kevin Risden","isMerge":true,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues();\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(\"field\", new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"71da933d30aea361ccc224d6544c451cbf49916d","date":1579874339,"type":3,"author":"Robert Muir","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(200);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(1000);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":["ca792c26af46bd6c4a08d81117c60440cf6a7e3d"],"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"59ed8c026ba85e3c42fb89605b2032dc6f9cc241","date":1581113294,"type":3,"author":"Nicholas Knize","isMerge":false,"pathNew":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","pathOld":"lucene/test-framework/src/java/org/apache/lucene/index/BasePointsFormatTestCase#testBigIntNDims().mjava","sourceNew":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(200);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_INDEX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","sourceOld":"  // Tests on N-dimensional points where each dimension is a BigInteger\n  public void testBigIntNDims() throws Exception {\n\n    int numDocs = atLeast(200);\n    try (Directory dir = getDirectory(numDocs)) {\n      int numBytesPerDim = TestUtil.nextInt(random(), 2, PointValues.MAX_NUM_BYTES);\n      int numDims = TestUtil.nextInt(random(), 1, PointValues.MAX_DIMENSIONS);\n      IndexWriterConfig iwc = newIndexWriterConfig(new MockAnalyzer(random()));\n      // We rely on docIDs not changing:\n      iwc.setMergePolicy(newLogMergePolicy());\n      RandomIndexWriter w = new RandomIndexWriter(random(), dir, iwc);\n      BigInteger[][] docs = new BigInteger[numDocs][];\n\n      for(int docID=0;docID<numDocs;docID++) {\n        BigInteger[] values = new BigInteger[numDims];\n        if (VERBOSE) {\n          System.out.println(\"  docID=\" + docID);\n        }\n        byte[][] bytes = new byte[numDims][];\n        for(int dim=0;dim<numDims;dim++) {\n          values[dim] = randomBigInt(numBytesPerDim);\n          bytes[dim] = new byte[numBytesPerDim];\n          NumericUtils.bigIntToSortableBytes(values[dim], numBytesPerDim, bytes[dim], 0);\n          if (VERBOSE) {\n            System.out.println(\"    \" + dim + \" -> \" + values[dim]);\n          }\n        }\n        docs[docID] = values;\n        Document doc = new Document();\n        doc.add(new BinaryPoint(\"field\", bytes));\n        w.addDocument(doc);\n      }\n\n      DirectoryReader r = w.getReader();\n      w.close();\n\n      int iters = atLeast(100);\n      for(int iter=0;iter<iters;iter++) {\n        if (VERBOSE) {\n          System.out.println(\"\\nTEST: iter=\" + iter);\n        }\n\n        // Random N dims rect query:\n        BigInteger[] queryMin = new BigInteger[numDims];\n        BigInteger[] queryMax = new BigInteger[numDims];    \n        for(int dim=0;dim<numDims;dim++) {\n          queryMin[dim] = randomBigInt(numBytesPerDim);\n          queryMax[dim] = randomBigInt(numBytesPerDim);\n          if (queryMin[dim].compareTo(queryMax[dim]) > 0) {\n            BigInteger x = queryMin[dim];\n            queryMin[dim] = queryMax[dim];\n            queryMax[dim] = x;\n          }\n          if (VERBOSE) {\n            System.out.println(\"  \" + dim + \"\\n    min=\" + queryMin[dim] + \"\\n    max=\" + queryMax[dim]);\n          }\n        }\n\n        final BitSet hits = new BitSet();\n        for(LeafReaderContext ctx : r.leaves()) {\n          PointValues dimValues = ctx.reader().getPointValues(\"field\");\n          if (dimValues == null) {\n            continue;\n          }\n\n          final int docBase = ctx.docBase;\n          \n          dimValues.intersect(new IntersectVisitor() {\n              @Override\n              public void visit(int docID) {\n                hits.set(docBase+docID);\n                //System.out.println(\"visit docID=\" + docID);\n              }\n\n              @Override\n              public void visit(int docID, byte[] packedValue) {\n                //System.out.println(\"visit check docID=\" + docID);\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger x = NumericUtils.sortableBytesToBigInt(packedValue, dim * numBytesPerDim, numBytesPerDim);\n                  if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n                    //System.out.println(\"  no\");\n                    return;\n                  }\n                }\n\n                //System.out.println(\"  yes\");\n                hits.set(docBase+docID);\n              }\n\n              @Override\n              public Relation compare(byte[] minPacked, byte[] maxPacked) {\n                boolean crosses = false;\n                for(int dim=0;dim<numDims;dim++) {\n                  BigInteger min = NumericUtils.sortableBytesToBigInt(minPacked, dim * numBytesPerDim, numBytesPerDim);\n                  BigInteger max = NumericUtils.sortableBytesToBigInt(maxPacked, dim * numBytesPerDim, numBytesPerDim);\n                  assert max.compareTo(min) >= 0;\n\n                  if (max.compareTo(queryMin[dim]) < 0 || min.compareTo(queryMax[dim]) > 0) {\n                    return Relation.CELL_OUTSIDE_QUERY;\n                  } else if (min.compareTo(queryMin[dim]) < 0 || max.compareTo(queryMax[dim]) > 0) {\n                    crosses = true;\n                  }\n                }\n\n                if (crosses) {\n                  return Relation.CELL_CROSSES_QUERY;\n                } else {\n                  return Relation.CELL_INSIDE_QUERY;\n                }\n              }\n            });\n        }\n\n        for(int docID=0;docID<numDocs;docID++) {\n          BigInteger[] docValues = docs[docID];\n          boolean expected = true;\n          for(int dim=0;dim<numDims;dim++) {\n            BigInteger x = docValues[dim];\n            if (x.compareTo(queryMin[dim]) < 0 || x.compareTo(queryMax[dim]) > 0) {\n              expected = false;\n              break;\n            }\n          }\n          boolean actual = hits.get(docID);\n          assertEquals(\"docID=\" + docID, expected, actual);\n        }\n      }\n      r.close();\n      }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["71da933d30aea361ccc224d6544c451cbf49916d"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":["4522ffca5a1f420c6a02198c9332d7c596a30ca5","367f57e2ee85b7f7e28cfe73370a22cf67624f65"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"71da933d30aea361ccc224d6544c451cbf49916d":["367f57e2ee85b7f7e28cfe73370a22cf67624f65"]},"commit2Childs":{"4522ffca5a1f420c6a02198c9332d7c596a30ca5":["367f57e2ee85b7f7e28cfe73370a22cf67624f65","4cce5816ef15a48a0bc11e5d400497ee4301dd3b"],"59ed8c026ba85e3c42fb89605b2032dc6f9cc241":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["4522ffca5a1f420c6a02198c9332d7c596a30ca5"],"367f57e2ee85b7f7e28cfe73370a22cf67624f65":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","71da933d30aea361ccc224d6544c451cbf49916d"],"4cce5816ef15a48a0bc11e5d400497ee4301dd3b":[],"71da933d30aea361ccc224d6544c451cbf49916d":["59ed8c026ba85e3c42fb89605b2032dc6f9cc241"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["4cce5816ef15a48a0bc11e5d400497ee4301dd3b","cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}