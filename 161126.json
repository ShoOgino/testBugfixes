{"path":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","commits":[{"id":"12ddd922ea96c1d0ea68a68506b6984a246cfb22","date":1554385731,"type":0,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","pathOld":"/dev/null","sourceNew":"  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      int timeSlept = 0;\n      while (!queue.isEmpty() && timeSlept < 30) {\n        try {\n          log.info(\"Async auditlogger queue still has {} elements, sleeping to let it drain...\", queue.size());\n          Thread.sleep(1000);\n          timeSlept ++;\n        } catch (InterruptedException ignored) {}\n      }\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n    }\n  }\n\n","sourceOld":null,"bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"144f2f24da0b8fe43f748fcb4c0c59cf52f9c2d8","date":1554812752,"type":3,"author":"Jan Høydahl","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","sourceNew":"  /**\n   * Waits 30s for async queue to drain, then closes executor threads.\n   * Subclasses should either call <code>super.close()</code> or {@link #waitForQueueToDrain(int)}\n   * <b>before</b> shutting itself down to make sure they can complete logging events in the queue. \n   */\n  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      waitForQueueToDrain(30);\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n    }\n  }\n\n","sourceOld":"  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      int timeSlept = 0;\n      while (!queue.isEmpty() && timeSlept < 30) {\n        try {\n          log.info(\"Async auditlogger queue still has {} elements, sleeping to let it drain...\", queue.size());\n          Thread.sleep(1000);\n          timeSlept ++;\n        } catch (InterruptedException ignored) {}\n      }\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa","date":1571411704,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","sourceNew":"  /**\n   * Waits 30s for async queue to drain, then closes executor threads.\n   * Subclasses should either call <code>super.close()</code> or {@link #waitForQueueToDrain(int)}\n   * <b>before</b> shutting itself down to make sure they can complete logging events in the queue. \n   */\n  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      waitForQueueToDrain(30);\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n      try {\n        SolrMetricProducer.super.close();\n      } catch (Exception e) {\n        throw new IOException(\"Exception closing\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Waits 30s for async queue to drain, then closes executor threads.\n   * Subclasses should either call <code>super.close()</code> or {@link #waitForQueueToDrain(int)}\n   * <b>before</b> shutting itself down to make sure they can complete logging events in the queue. \n   */\n  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      waitForQueueToDrain(30);\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null},{"id":"7c2af5a711bd6e2d33e0221ced0f47ac596ed275","date":1572877903,"type":3,"author":"Andrzej Bialecki","isMerge":false,"pathNew":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","pathOld":"solr/core/src/java/org/apache/solr/security/AuditLoggerPlugin#close().mjava","sourceNew":"  /**\n   * Waits 30s for async queue to drain, then closes executor threads.\n   * Subclasses should either call <code>super.close()</code> or {@link #waitForQueueToDrain(int)}\n   * <b>before</b> shutting itself down to make sure they can complete logging events in the queue. \n   */\n  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      waitForQueueToDrain(30);\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n      try {\n        SolrInfoBean.super.close();\n      } catch (Exception e) {\n        throw new IOException(\"Exception closing\", e);\n      }\n    }\n  }\n\n","sourceOld":"  /**\n   * Waits 30s for async queue to drain, then closes executor threads.\n   * Subclasses should either call <code>super.close()</code> or {@link #waitForQueueToDrain(int)}\n   * <b>before</b> shutting itself down to make sure they can complete logging events in the queue. \n   */\n  @Override\n  public void close() throws IOException {\n    if (async && executorService != null) {\n      waitForQueueToDrain(30);\n      closed = true;\n      log.info(\"Shutting down async Auditlogger background thread(s)\");\n      executorService.shutdownNow();\n      try {\n        SolrMetricProducer.super.close();\n      } catch (Exception e) {\n        throw new IOException(\"Exception closing\", e);\n      }\n    }\n  }\n\n","bugFix":null,"bugIntro":[],"isBuggy":false,"nexts":[],"revCommit":null}],"commit2Parents":{"7c2af5a711bd6e2d33e0221ced0f47ac596ed275":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["144f2f24da0b8fe43f748fcb4c0c59cf52f9c2d8"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":[],"cd5edd1f2b162a5cfa08efd17851a07373a96817":["7c2af5a711bd6e2d33e0221ced0f47ac596ed275"],"144f2f24da0b8fe43f748fcb4c0c59cf52f9c2d8":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"]},"commit2Childs":{"7c2af5a711bd6e2d33e0221ced0f47ac596ed275":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa":["7c2af5a711bd6e2d33e0221ced0f47ac596ed275"],"12ddd922ea96c1d0ea68a68506b6984a246cfb22":["144f2f24da0b8fe43f748fcb4c0c59cf52f9c2d8"],"a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85":["12ddd922ea96c1d0ea68a68506b6984a246cfb22"],"144f2f24da0b8fe43f748fcb4c0c59cf52f9c2d8":["c959a64c5b52cc12eb8daa17f4f0ed9cf2dfcaaa"],"cd5edd1f2b162a5cfa08efd17851a07373a96817":[]},"heads":["cd5edd1f2b162a5cfa08efd17851a07373a96817"],"roots":["a0e7ee9d0d12370e8d2b5ae0a23b6e687e018d85"],"pathCommit":null}